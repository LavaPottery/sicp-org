#+title: Estructura e Interpretación de Programas Informáticos
#+creator: https://github.com/ilmotta
#+description: SICP no oficial para usuarios de Org
#+startup: overview entitiespretty
#+options: num:nil
#+property: header-args :results silent
#+date: 2020-03-25
#+author: Harold Abelson
#+subauthor: Gerald Jay Sussman, Julie Sussman
#+begin_comment
Segunda Edición
(C) 1996 Massachusetts Institute of Technology
#+end_comment
* Dedicatoria
Este libro está dedicado, con respeto y admiración, al espíritu que vive en el ordenador.
#+begin_quote
"Creo que es extraordinariamente importante que en informática mantengamos la diversión en la computación. Cuando comenzó, era muy divertida. Por supuesto, los clientes que pagaban fueron perjudicados de vez en cuando, y después de un tiempo comenzamos a tomar sus quejas en serio. Empezamos a sentir como si realmente fuéramos responsables del uso exitoso, sin errores y perfecto de estas máquinas. No creo que lo seamos. Creo que somos responsables de expandirlas, llevarlas en nuevas direcciones y mantener la diversión en casa. Espero que el campo de la informática nunca pierda su sentido de diversión. Sobre todo, espero que no nos convirtamos en misioneros. No os sintáis como si fuerais vendedores de Biblias. El mundo ya tiene demasiados de esos. Lo que vosotros sabéis sobre computación otros lo aprenderán. No os sintáis como si la clave del éxito en la computación estuviera solo en vuestras manos. Lo que está en vuestras manos, creo y espero, es inteligencia: la capacidad de ver la máquina como algo más de lo que era cuando os la presentaron por primera vez, que podéis hacer más con ella."

--Alan J. Perlis (April 1, 1922 February 7, 1990)
#+end_quote
* Prólogo
Los educadores, generales, nutricionistas, psicólogos y padres programan. Los ejércitos, estudiantes y algunas sociedades son programados. Un asalto a problemas grandes emplea una sucesión de programas, la mayoría de los cuales surgen en el camino. Estos programas están plagados de cuestiones que parecen ser particulares al problema en cuestión. Para apreciar la programación como una actividad intelectual por derecho propio, debéis recurrir a la programación informática; debéis leer y escribir programas informáticos--muchos de ellos. No importa mucho de qué tratan los programas o qué aplicaciones sirven. Lo que sí importa es qué tan bien funcionan y qué tan suavemente encajan con otros programas en la creación de programas aún mayores. El programador debe buscar tanto la perfección de la parte como la adecuación del conjunto. En este libro el uso de "programa" se centra en la creación, ejecución y estudio de programas escritos en un dialecto de Lisp para su ejecución en un ordenador digital. Usando Lisp no restringimos o limitamos lo que podemos programar, sino solo la notación para nuestras descripciones de programas.
Nuestro trato con la materia de este libro nos involucra con tres focos de fenómenos: la mente humana, colecciones de programas informáticos y el ordenador. Cada programa informático es un modelo, concebido en la mente, de un proceso real o mental. Estos procesos, que surgen de la experiencia y el pensamiento humanos, son enormes en número, intrincados en detalle, y en cualquier momento solo parcialmente comprendidos. Rara vez son modelados a nuestra satisfacción permanente por nuestros programas informáticos. Así que aunque nuestros programas son colecciones discretas de símbolos cuidadosamente elaboradas a mano, mosaicos de funciones entrelazadas, evolucionan continuamente: los cambiamos a medida que nuestra percepción del modelo se profundiza, amplía, generaliza hasta que el modelo finalmente alcanza un lugar metaestable dentro de otro modelo con el que luchamos. La fuente de la exaltación asociada con la programación informática es el continuo despliegue dentro de la mente y en el ordenador de mecanismos expresados como programas y la explosión de percepción que generan. Si el arte interpreta nuestros sueños, ¡el ordenador los ejecuta bajo la apariencia de programas!
Por todo su poder, el ordenador es un capataz severo. Sus programas deben ser correctos, y lo que deseamos decir debe decirse con precisión en cada detalle. Como en toda otra actividad simbólica, nos convencemos de la verdad del programa mediante argumentación. A Lisp mismo se le puede asignar una semántica (otro modelo, por cierto), y si la función de un programa puede especificarse, digamos, en el cálculo de predicados, los métodos de prueba de la lógica pueden usarse para hacer un argumento de corrección aceptable. Desafortunadamente, a medida que los programas se vuelven grandes y complicados, como casi siempre lo hacen, la adecuación, consistencia y corrección de las especificaciones mismas se vuelven dudosas, de modo que rara vez los argumentos formales completos de corrección acompañan a programas grandes. Dado que los programas grandes crecen a partir de los pequeños, es crucial que desarrollemos un arsenal de estructuras de programa estándar de cuya corrección estemos seguros--las llamamos modismos--y aprendamos a combinarlas en estructuras más grandes usando técnicas organizativas de valor probado. Estas técnicas se tratan extensamente en este libro, y comprenderlas es esencial para la participación en la empresa prometeica llamada programación. Más que ninguna otra cosa, el descubrimiento y dominio de técnicas organizativas poderosas acelera nuestra capacidad de crear programas grandes y significativos. Por el contrario, dado que escribir programas grandes es muy agotador, nos vemos estimulados a inventar nuevos métodos para reducir la masa de función y detalle que debe ajustarse en programas grandes.
A diferencia de los programas, los ordenadores deben obedecer las leyes de la física. Si desean funcionar rápidamente--unos pocos nanosegundos por cambio de estado--deben transmitir electrones solo distancias pequeñas (como máximo 11 sobre 2 pies). El calor generado por el enorme número de dispositivos tan concentrados en el espacio tiene que ser eliminado. Se ha desarrollado un exquisito arte de ingeniería que equilibra entre la multiplicidad de funciones y la densidad de dispositivos. En cualquier caso, el hardware siempre opera a un nivel más primitivo que aquel en el que nos importa programar. Los procesos que transforman nuestros programas Lisp en programas "máquina" son ellos mismos modelos abstractos que programamos. Su estudio y creación brindan una gran cantidad de conocimiento sobre los programas organizativos asociados con la programación de modelos arbitrarios. Por supuesto, el ordenador mismo puede ser modelado así. Pensad en ello: ¡el comportamiento del elemento de conmutación física más pequeño es modelado por la mecánica cuántica descrita por ecuaciones diferenciales cuyo comportamiento detallado es capturado por aproximaciones numéricas representadas en programas informáticos ejecutándose en ordenadores compuestos de...!
No es meramente una cuestión de conveniencia táctica identificar por separado los tres focos. Aunque, como dicen, todo está en la cabeza, esta separación lógica induce una aceleración del tráfico simbólico entre estos focos cuya riqueza, vitalidad y potencial solo es superado en la experiencia humana por la evolución de la vida misma. En el mejor de los casos, las relaciones entre los focos son metaestables. Los ordenadores nunca son lo suficientemente grandes o rápidos. Cada avance en la tecnología de hardware conduce a empresas de programación más masivas, nuevos principios organizativos y un enriquecimiento de modelos abstractos. Cada lector debería preguntarse periódicamente "¿Hacia qué fin, hacia qué fin?"--pero no lo preguntéis con demasiada frecuencia no sea que renunciéis a la diversión de la programación por el estreñimiento de la filosofía agridulce.
Entre los programas que escribimos, algunos (pero nunca suficientes) realizan una función matemática precisa como ordenar o encontrar el máximo de una secuencia de números, determinar la primalidad o encontrar la raíz cuadrada. Llamamos a tales programas algoritmos, y se conoce mucho de su comportamiento óptimo, particularmente con respecto a los dos parámetros importantes de tiempo de ejecución y requisitos de almacenamiento de datos. Un programador debería adquirir buenos algoritmos y modismos. Aunque algunos programas resisten especificaciones precisas, es responsabilidad del programador estimar, y siempre intentar mejorar, su rendimiento.
Lisp es un superviviente, habiendo estado en uso durante aproximadamente un cuarto de siglo. Entre los lenguajes de programación activos, solo Fortran ha tenido una vida más larga. Ambos lenguajes han respaldado las necesidades de programación de áreas importantes de aplicación, Fortran para el cómputo científico e ingenieril y Lisp para la inteligencia artificial. Estas dos áreas continúan siendo importantes, y sus programadores están tan dedicados a estos dos lenguajes que Lisp y Fortran bien pueden continuar en uso activo durante al menos otro cuarto de siglo.
Lisp cambia. El dialecto Scheme usado en este texto ha evolucionado del Lisp original y difiere de este último en varias maneras importantes, incluyendo el ámbito estático para el enlace de variables y permitir que las funciones produzcan funciones como valores. En su estructura semántica, Scheme está tan estrechamente relacionado con Algol 60 como con los Lisps tempranos. Algol 60, que nunca volverá a ser un lenguaje activo, vive en los genes de Scheme y Pascal. Sería difícil encontrar dos lenguajes que sean la moneda comunicativa de dos culturas más diferentes que las reunidas alrededor de estos dos lenguajes. Pascal es para construir pirámides--estructuras imponentes, impresionantes, estáticas construidas por ejércitos empujando pesados bloques a su lugar. Lisp es para construir organismos--estructuras imponentes, impresionantes, dinámicas construidas por escuadrones encajando miríadas fluctuantes de organismos más simples en su lugar. Los principios organizativos utilizados son los mismos en ambos casos, excepto por una diferencia extraordinariamente importante: La funcionalidad exportable discrecional confiada al programador individual de Lisp es más de un orden de magnitud mayor que la que se encuentra dentro de las empresas Pascal. Los programas Lisp inflan las bibliotecas con funciones cuya utilidad trasciende la aplicación que las produjo. La lista, la estructura de datos nativa de Lisp, es en gran medida responsable de tal crecimiento de utilidad. La estructura simple y aplicabilidad natural de las listas se reflejan en funciones que son sorprendentemente no idiosincrásicas. En Pascal, la plétora de estructuras de datos declarables induce una especialización dentro de las funciones que inhibe y penaliza la cooperación casual. Es mejor tener 100 funciones que operen en una estructura de datos que tener 10 funciones que operen en 10 estructuras de datos. Como resultado, la pirámide debe permanecer sin cambios durante un milenio; el organismo debe evolucionar o perecer.
Para ilustrar esta diferencia, comparad el tratamiento del material y los ejercicios dentro de este libro con el de cualquier texto de primer curso que use Pascal. No trabajéis bajo la ilusión de que este es un texto digerible solo en MIT, peculiar a la raza que se encuentra allí. Es precisamente lo que un libro serio sobre programación en Lisp debe ser, sin importar quién sea el estudiante o dónde se use.
Notad que este es un texto sobre programación, a diferencia de la mayoría de los libros de Lisp, que se usan como preparación para el trabajo en inteligencia artificial. Después de todo, las preocupaciones críticas de programación de la ingeniería de software y la inteligencia artificial tienden a unirse a medida que los sistemas bajo investigación se vuelven más grandes. Esto explica por qué hay un creciente interés en Lisp fuera de la inteligencia artificial.
Como cabría esperar de sus objetivos, la investigación en inteligencia artificial genera muchos problemas de programación significativos. En otras culturas de programación, esta avalancha de problemas genera nuevos lenguajes. De hecho, en cualquier tarea de programación muy grande, un principio organizativo útil es controlar y aislar el tráfico dentro de los módulos de la tarea mediante la invención de lenguaje. Estos lenguajes tienden a volverse menos primitivos a medida que uno se acerca a los límites del sistema donde los humanos interactuamos con más frecuencia. Como resultado, tales sistemas contienen funciones complejas de procesamiento de lenguaje replicadas muchas veces. Lisp tiene una sintaxis y semántica tan simples que el análisis sintáctico puede tratarse como una tarea elemental. Así, la tecnología de análisis sintáctico casi no juega ningún papel en los programas Lisp, y la construcción de procesadores de lenguaje rara vez es un impedimento para la tasa de crecimiento y cambio de los grandes sistemas Lisp. Finalmente, es esta misma simplicidad de sintaxis y semántica la responsable de la carga y la libertad que soportan todos los programadores de Lisp. Ningún programa Lisp de cualquier tamaño más allá de unas pocas líneas puede escribirse sin estar saturado de funciones discrecionales. ¡Inventad y ajustad; tened ajustes y reinventad! Brindamos por el programador de Lisp que plasma sus pensamientos dentro de nidos de paréntesis.
Alan J. Perlis New Haven, Connecticut
* Prefacio a la Segunda Edición
#+begin_quote
¿Es posible que el software no se parezca a nada más, que esté destinado a ser desechado: que el objetivo completo sea verlo siempre como una pompa de jabón?

--Alan J. Perlis
#+end_quote
El material de este libro ha sido la base de la asignatura de informática de nivel inicial de MIT desde 1980. Habíamos estado enseñando este material durante cuatro años cuando se publicó la primera edición, y han transcurrido doce años más hasta la aparición de esta segunda edición. Estamos complacidos de que nuestro trabajo haya sido ampliamente adoptado e incorporado en otros textos. Hemos visto a nuestros estudiantes tomar las ideas y programas de este libro y construirlos como el núcleo de nuevos sistemas informáticos y lenguajes. En la realización literal de un antiguo juego de palabras talmúdico, nuestros estudiantes se han convertido en nuestros constructores. Somos afortunados de tener estudiantes tan capaces y constructores tan consumados.
Al preparar esta edición, hemos incorporado cientos de aclaraciones sugeridas por nuestra propia experiencia docente y los comentarios de colegas en MIT y otros lugares. Hemos rediseñado la mayoría de los principales sistemas de programación en el libro, incluyendo el sistema aritmético genérico, los intérpretes, el simulador de máquina de registros y el compilador; y hemos reescrito todos los ejemplos de programas para asegurar que cualquier implementación de Scheme que se ajuste al estándar IEEE Scheme (IEEE 1990) pueda ejecutar el código.
Esta edición enfatiza varios temas nuevos. El más importante de estos es el papel central desempeñado por diferentes enfoques para tratar el tiempo en los modelos computacionales: objetos con estado, programación concurrente, programación funcional, evaluación perezosa y programación no determinista. Hemos incluido nuevas secciones sobre concurrencia y no determinismo, y hemos intentado integrar este tema a lo largo del libro.
La primera edición del libro seguía de cerca el programa de estudios de nuestra asignatura de un semestre en MIT. Con todo el material nuevo en la segunda edición, no será posible cubrir todo en un solo semestre, por lo que el instructor tendrá que elegir. En nuestra propia enseñanza, a veces omitimos la sección sobre programación lógica (sección [[#section-4.4][4.4]]), hacemos que los estudiantes usen el simulador de máquina de registros pero no cubrimos su implementación (sección [[#section-5.2][5.2]]), y damos solo una visión general superficial del compilador (sección [[#section-5.5][5.5]]). Aun así, este sigue siendo un curso intenso. Algunos instructores pueden desear cubrir solo los primeros tres o cuatro capítulos, dejando el otro material para cursos posteriores.
El sitio World-Wide-Web <http://mitpress.mit.edu/sicp/> proporciona apoyo a los usuarios de este libro. Esto incluye programas del libro, tareas de programación de muestra, materiales complementarios e implementaciones descargables del dialecto Scheme de Lisp.
* Prefacio a la Primera Edición
#+begin_quote
Un ordenador es como un violín. Podéis imaginar a un novato probando primero un fonógrafo y luego un violín. Este último, dice, suena terrible. Ese es el argumento que hemos escuchado de nuestros humanistas y la mayoría de nuestros informáticos. Los programas informáticos son buenos, dicen, para propósitos particulares, pero no son flexibles. Tampoco lo es un violín, o una máquina de escribir, hasta que aprendes a usarla.

--Marvin Minsky, "Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas"
#+end_quote
"The Structure and Interpretation of Computer Programs" es la asignatura de nivel inicial en informática en el Massachusetts Institute of Technology. Es requerida para todos los estudiantes en MIT que se especializan en ingeniería eléctrica o en informática, como una cuarta parte del "currículo básico común", que también incluye dos asignaturas sobre circuitos y sistemas lineales y una asignatura sobre el diseño de sistemas digitales. Hemos estado involucrados en el desarrollo de esta asignatura desde 1978, y hemos enseñado este material en su forma actual desde el otoño de 1980 a entre 600 y 700 estudiantes cada año. La mayoría de estos estudiantes han tenido poca o ninguna formación formal previa en computación, aunque muchos han jugado un poco con ordenadores y unos pocos han tenido una extensa experiencia en programación o diseño de hardware.
Nuestro diseño de esta asignatura introductoria de informática refleja dos preocupaciones principales. Primero, queremos establecer la idea de que un lenguaje informático no es solo una forma de hacer que un ordenador realice operaciones, sino que es un medio formal novedoso para expresar ideas sobre metodología. Así, los programas deben escribirse para que las personas los lean, y solo incidentalmente para que las máquinas los ejecuten. Segundo, creemos que el material esencial que debe abordarse en una asignatura de este nivel no es la sintaxis de construcciones particulares de lenguajes de programación, ni algoritmos ingeniosos para computar funciones particulares eficientemente, ni siquiera el análisis matemático de algoritmos y los fundamentos de la computación, sino más bien las técnicas usadas para controlar la complejidad intelectual de grandes sistemas de software.
Nuestro objetivo es que los estudiantes que completen esta asignatura tengan una buena sensación por los elementos de estilo y la estética de la programación. Deberían tener dominio de las principales técnicas para controlar la complejidad en un sistema grande. Deberían ser capaces de leer un programa de 50 páginas de largo, si está escrito en un estilo ejemplar. Deberían saber qué no leer, y qué no necesitan entender en ningún momento. Deberían sentirse seguros al modificar un programa, reteniendo el espíritu y el estilo del autor original.
Estas habilidades no son en absoluto únicas de la programación informática. Las técnicas que enseñamos y sobre las que nos basamos son comunes a todo el diseño de ingeniería. Controlamos la complejidad construyendo abstracciones que ocultan detalles cuando es apropiado. Controlamos la complejidad estableciendo interfaces convencionales que nos permiten construir sistemas combinando piezas estándar y bien entendidas de una manera de "mezclar y combinar". Controlamos la complejidad estableciendo nuevos lenguajes para describir un diseño, cada uno de los cuales enfatiza aspectos particulares del diseño y desenfatiza otros.
Subyacente a nuestro enfoque de esta asignatura está nuestra convicción de que la "informática" no es una ciencia y que su importancia tiene poco que ver con los ordenadores. La revolución informática es una revolución en la forma en que pensamos y en la forma en que expresamos lo que pensamos. La esencia de este cambio es la emergencia de lo que mejor podría llamarse <<i300>> epistemología procedimental--el estudio de la estructura del conocimiento desde un punto de vista imperativo, en oposición al punto de vista más declarativo adoptado por las asignaturas matemáticas clásicas. Las matemáticas proporcionan un marco para tratar con precisión las nociones de "qué es". La computación proporciona un marco para tratar con precisión las nociones de "cómo hacer".
En la enseñanza de nuestro material usamos un dialecto del lenguaje de programación Lisp. Nunca enseñamos formalmente el lenguaje, porque no tenemos que hacerlo. Simplemente lo usamos, y los estudiantes lo aprenden en unos pocos días. Esta es una gran ventaja de los lenguajes tipo Lisp: tienen muy pocas formas de formar expresiones compuestas, y casi ninguna estructura sintáctica. Todas las propiedades formales pueden cubrirse en una hora, como las reglas del ajedrez. Después de poco tiempo nos olvidamos de los detalles sintácticos del lenguaje (porque no los hay) y seguimos con los problemas reales--descubrir qué queremos computar, cómo descompondremos los problemas en partes manejables, y cómo trabajaremos en las partes. Otra ventaja de Lisp es que soporta (pero no impone) más de las estrategias a gran escala para la descomposición modular de programas que cualquier otro lenguaje que conozcamos. Podemos hacer abstracciones procedimentales y de datos, podemos usar funciones de orden superior para capturar patrones comunes de uso, podemos modelar el estado local usando asignación y mutación de datos, podemos enlazar partes de un programa con flujos y evaluación retardada, y podemos implementar fácilmente lenguajes embebidos. Todo esto está embebido en un entorno interactivo con excelente soporte para el diseño, construcción, prueba y depuración incremental de programas. Agradecemos a todas las generaciones de magos de Lisp, comenzando con John McCarthy, que han forjado una herramienta fina de poder y elegancia sin precedentes.
Scheme, el dialecto de Lisp que usamos, es un intento de reunir el poder y la elegancia de Lisp y Algol. De Lisp tomamos el poder metalingüístico que deriva de la sintaxis simple, la representación uniforme de programas como objetos de datos, y los datos asignados en heap y recolectados por recolector de basura. De Algol tomamos el ámbito léxico y la estructura de bloques, que son regalos de los pioneros del diseño de lenguajes de programación que estaban en el comité Algol. Deseamos citar a John Reynolds y Peter Landin por sus conocimientos sobre la relación del cálculo [lambda] de Church con la estructura de los lenguajes de programación. También reconocemos nuestra deuda con los matemáticos que exploraron este territorio décadas antes de que los ordenadores aparecieran en escena. Estos pioneros incluyen a Alonzo Church, Barkley Rosser, Stephen Kleene y Haskell Curry.
* Agradecimientos
Nos gustaría agradecer a las muchas personas que nos han ayudado a desarrollar este libro y este currículo.
Nuestra asignatura es un claro descendiente intelectual de "6.231", una maravillosa asignatura sobre lingüística de programación y el cálculo [lambda] enseñada en MIT a finales de los años sesenta por Jack Wozencraft y Arthur Evans, Jr.
Debemos una gran deuda a Robert Fano, quien reorganizó el currículo introductorio de MIT en ingeniería eléctrica e informática para enfatizar los principios del diseño de ingeniería. Él nos guió al comenzar esta empresa y escribió el primer conjunto de notas de asignatura a partir de las cuales evolucionó este libro.
Gran parte del estilo y la estética de la programación que intentamos enseñar fueron desarrollados en conjunto con Guy Lewis Steele Jr., quien colaboró con Gerald Jay Sussman en el desarrollo inicial del lenguaje Scheme. Además, David Turner, Peter Henderson, Dan Friedman, David Wise y Will Clinger nos han enseñado muchas de las técnicas de la comunidad de programación funcional que aparecen en este libro.
Joel Moses nos enseñó sobre la estructuración de sistemas grandes. Su experiencia con el sistema Macsyma para computación simbólica proporcionó el conocimiento de que uno debería evitar las complejidades de control y concentrarse en organizar los datos para reflejar la estructura real del mundo que se está modelando.
Marvin Minsky y Seymour Papert formaron muchas de nuestras actitudes sobre la programación y su lugar en nuestras vidas intelectuales. A ellos les debemos la comprensión de que la computación proporciona un medio de expresión para explorar ideas que de otro modo serían demasiado complejas para tratar con precisión. Ellos enfatizan que la capacidad de un estudiante para escribir y modificar programas proporciona un medio poderoso en el cual explorar se convierte en una actividad natural.
También estamos fuertemente de acuerdo con Alan Perlis en que la programación es muy divertida y es mejor tener cuidado de apoyar la alegría de la programación. Parte de esta alegría deriva de observar a grandes maestros en el trabajo. Somos afortunados de haber sido programadores aprendices a los pies de Bill Gosper y Richard Greenblatt.
Es difícil identificar a todas las personas que han contribuido al desarrollo de nuestro currículo. Agradecemos a todos los profesores, instructores de recitación y tutores que han trabajado con nosotros durante los últimos quince años y han dedicado muchas horas extra a nuestra asignatura, especialmente a Bill Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein y Peter Szolovits. Nos gustaría reconocer especialmente las destacadas contribuciones docentes de Franklyn Turbak, ahora en Wellesley; su trabajo en la instrucción de pregrado estableció un estándar al que todos podemos aspirar. Estamos agradecidos a Jerry Saltzer y Jim Miller por ayudarnos a lidiar con los misterios de la concurrencia, y a Peter Szolovits y David McAllester por sus contribuciones a la exposición de la evaluación no determinista en [[#section-4][Capítulo 4]].
Muchas personas han dedicado un esfuerzo significativo a presentar este material en otras universidades. Algunas de las personas con las que hemos trabajado estrechamente son Jacob Katzenelson en el Technion, Hardy Mayer en la University of California en Irvine, Joe Stoy en Oxford, Elisha Sacks en Purdue, y Jan Komorowski en la Norwegian University of Science and Technology. Estamos excepcionalmente orgullosos de nuestros colegas que han recibido importantes premios de enseñanza por sus adaptaciones de esta asignatura en otras universidades, incluyendo a Kenneth Yip en Yale, Brian Harvey en la University of California en Berkeley, y Dan Huttenlocher en Cornell.
Al Moye' organizó para que enseñáramos este material a ingenieros en Hewlett-Packard, y para la producción de videograbaciones de estas conferencias. Nos gustaría agradecer a los talentosos instructores--en particular Jim Miller, Bill Siebert y Mike Eisenberg--que han diseñado cursos de educación continua incorporando estas cintas y las han enseñado en universidades e industria en todo el mundo.
Muchos educadores en otros países han dedicado un trabajo significativo a traducir la primera edición. Michel Briand, Pierre Chamard y Andre' Pic produjeron una edición francesa; Susanne Daniels-Herold produjo una edición alemana; y Fumio Motoyoshi produjo una edición japonesa. No sabemos quién produjo la edición china, pero consideramos un honor haber sido seleccionados como tema de una traducción "no autorizada".
Es difícil enumerar a todas las personas que han hecho contribuciones técnicas al desarrollo de los sistemas Scheme que usamos con fines instructivos. Además de Guy Steele, los principales magos han incluido a Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas y Stephen Adams. Otros que han dedicado un tiempo significativo son Richard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass, Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin y Ruth Shyu.
Más allá de la implementación de MIT, nos gustaría agradecer a las muchas personas que trabajaron en el estándar IEEE Scheme, incluyendo a William Clinger y Jonathan Rees, quienes editaron el R^4RS, y a Chris Haynes, David Bartley, Chris Hanson y Jim Miller, quienes prepararon el estándar IEEE.
Dan Friedman ha sido durante mucho tiempo un líder de la comunidad Scheme. El trabajo más amplio de la comunidad va más allá de los asuntos de diseño de lenguajes para abarcar innovaciones educativas significativas, como el currículo de secundaria basado en EdScheme por Schemer's Inc., y los maravillosos libros de Mike Eisenberg y de Brian Harvey y Matthew Wright.
Apreciamos el trabajo de aquellos que contribuyeron a hacer de este un libro real, especialmente Terry Ehling, Larry Cohen y Paul Bethge en MIT Press. Ella Mazel encontró la maravillosa imagen de portada. Para la segunda edición estamos particularmente agradecidos a Bernard y Ella Mazel por la ayuda con el diseño del libro, y a David Jones, mago de TeX extraordinario. También estamos en deuda con aquellos lectores que hicieron comentarios penetrantes sobre el nuevo borrador: Jacob Katzenelson, Hardy Mayer, Jim Miller, y especialmente Brian Harvey, quien hizo con este libro lo que Julie hizo con su libro 'Simply Scheme'.
Finalmente, nos gustaría reconocer el apoyo de las organizaciones que han alentado este trabajo a lo largo de los años, incluyendo el apoyo de Hewlett-Packard, posible gracias a Ira Goldstein y Joel Birnbaum, y el apoyo de DARPA, posible gracias a Bob Kahn.
