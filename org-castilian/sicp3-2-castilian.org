** 3.2 El modelo de entornos para la evaluación
:properties:
:custom_id: section-3.2
:end:

Cuando introdujimos los procedimientos compuestos en [[#section-1][Capítulo 1]], utilizamos el modelo de sustitución de evaluación (sección [[#section-1.1.5][1.1.5]]) para definir qué significa aplicar un procedimiento a argumentos:

- Para aplicar un procedimiento compuesto a argumentos, evalúa el cuerpo del procedimiento con cada parámetro formal reemplazado por el argumento correspondiente.

Una vez que admitimos la asignación en nuestro lenguaje de programación, tal definición ya no es adecuada. En particular, la sección [[#section-3.1.3][3.1.3]] argumentó que, en presencia de asignación, una variable ya no puede considerarse meramente un nombre para un valor. Más bien, una variable debe de alguna manera designar un "lugar" en el que se pueden almacenar valores. En nuestro nuevo modelo de evaluación, estos lugares se mantendrán en estructuras llamadas <<i125>> entornos.

Un entorno es una secuencia de <<i148>> marcos. Cada marco es una tabla (posiblemente vacía) de <<i37>> enlaces, que asocian nombres de variables con sus valores correspondientes. (Un solo marco puede contener como máximo un enlace para cualquier variable.) Cada marco también tiene un puntero a su <<i120>> entorno circundante, a menos que, para propósitos de discusión, el marco se considere <<i166>> global. El <<i418>> valor de una variable con respecto a un entorno es el valor dado por el enlace de la variable en el primer marco del entorno que contiene un enlace para esa variable. Si ningún marco en la secuencia especifica un enlace para la variable, entonces se dice que la variable está <<i409>> no enlazada en el entorno.

<<figure-3.1>> Una estructura de entorno simple.

#+begin_example
            +--------+
            |      I |
            | x: 3   |
            | y: 5   |
            +--------+
               ^  ^
               |  |
             C |  | D
 +---------+   |  |   +----------+
 |      II |   |  |   |      III |
 | z: 6    +---+  +---+ m: 1     |
 | x: 7    |          | y: 2     |
 +---------+          +----------+
#+end_example

[[figure-3.1][Figura 3.1]] muestra una estructura de entorno simple que consiste en tres marcos, etiquetados I, II y III. En el diagrama, A, B, C y D son punteros a entornos. C y D apuntan al mismo entorno. Las variables ~z~ y ~x~ están enlazadas en el marco II, mientras que ~y~ y ~x~ están enlazadas en el marco I. El valor de ~x~ en el entorno D es 3. El valor de ~x~ con respecto al entorno B también es 3. Esto se determina de la siguiente manera: Examinamos el primer marco en la secuencia (marco III) y no encontramos un enlace para ~x~, así que procedemos al entorno circundante D y encontramos el enlace en el marco I. Por otro lado, el valor de ~x~ en el entorno A es 7, porque el primer marco en la secuencia (marco II) contiene un enlace de ~x~ a 7. Con respecto al entorno A, se dice que el enlace de ~x~ a 7 en el marco II <<i352>> ensombrece el enlace de ~x~ a 3 en el marco I.

El entorno es crucial para el proceso de evaluación, porque determina el contexto en el que se debe evaluar una expresión. De hecho, se podría decir que las expresiones en un lenguaje de programación no tienen, en sí mismas, ningún significado. Más bien, una expresión adquiere un significado sólo con respecto a algún entorno en el que se evalúa. Incluso la interpretación de una expresión tan directa como ~(+ 1 1)~ depende de la comprensión de que uno está operando en un contexto en el que ~+~ es el símbolo para la adición. Por lo tanto, en nuestro modelo de evaluación siempre hablaremos de evaluar una expresión con respecto a algún entorno. Para describir las interacciones con el intérprete, supondremos que hay un entorno global, que consiste en un solo marco (sin entorno circundante) que incluye valores para los símbolos asociados con los procedimientos primitivos. Por ejemplo, la idea de que ~+~ es el símbolo para la adición se captura al decir que el símbolo ~+~ está enlazado en el entorno global al procedimiento primitivo de adición.

*** 3.2.1 Las reglas para la evaluación
:properties:
:custom_id: section-3.2.1
:end:

La especificación general de cómo el intérprete evalúa una combinación permanece igual que cuando la introdujimos por primera vez en la sección [[#section-1.1.3][1.1.3]]:

Para evaluar una combinación:

1. Evalúa las subexpresiones de la combinación.[fn:140]

2. Aplica el valor de la subexpresión del operador a los valores de las subexpresiones de los operandos.

El modelo de entornos de evaluación reemplaza el modelo de sustitución al especificar qué significa aplicar un procedimiento compuesto a argumentos.

En el modelo de entornos de evaluación, un procedimiento es siempre un par que consiste en algún código y un puntero a un entorno. Los procedimientos se crean de una sola manera: evaluando una expresión ~lambda~. Esto produce un procedimiento cuyo código se obtiene del texto de la expresión ~lambda~ y cuyo entorno es el entorno en el que se evaluó la expresión ~lambda~ para producir el procedimiento. Por ejemplo, considera la definición de procedimiento

#+begin_src scheme
(define (square x)
  (* x x))
#+end_src

evaluada en el entorno global. La sintaxis de definición de procedimiento es sólo azúcar sintáctico para una expresión ~lambda~ implícita subyacente. Habría sido equivalente haber usado

#+begin_src scheme
(define square
  (lambda (x) (* x x)))
#+end_src

que evalúa ~(lambda (x) (* x x))~ y enlaza ~square~ al valor resultante, todo en el entorno global.

[[figure-3.2][Figura 3.2]] muestra el resultado de evaluar esta expresión ~define~. El objeto de procedimiento es un par cuyo código especifica que el procedimiento tiene un parámetro formal, a saber ~x~, y un cuerpo de procedimiento ~(* x x)~. La parte del entorno del procedimiento es un puntero al entorno global, ya que ese es el entorno en el que se evaluó la expresión ~lambda~ para producir el procedimiento. Se ha agregado un nuevo enlace, que asocia el objeto de procedimiento con el símbolo ~square~, al marco global. En general, ~define~ crea definiciones agregando enlaces a los marcos.

<<figure-3.2>> Estructura de entorno producida al evaluar ~(define (square x) (* x x))~ en el entorno global.

#+begin_example
            +----------------------+
            | other variables      |
 global --->|                      |
 env        | square: --+          |
            +-----------|----------+
                        |       ^
 (define (square x)     |       |
   (* x x))             V       |
                    .---.---.   |
                    | O | O-+---+
                    `-|-^---'
                      |
                      V
                    parameters: x
                    body: (* x x)
#+end_example

Ahora que hemos visto cómo se crean los procedimientos, podemos describir cómo se aplican los procedimientos. El modelo de entornos especifica: Para aplicar un procedimiento a argumentos, crea un nuevo entorno que contenga un marco que enlace los parámetros a los valores de los argumentos. El entorno circundante de este marco es el entorno especificado por el procedimiento. Ahora, dentro de este nuevo entorno, evalúa el cuerpo del procedimiento.

Para mostrar cómo se sigue esta regla, [[figure-3.3][Figura 3.3]] ilustra la estructura de entorno creada al evaluar la expresión ~(square 5)~ en el entorno global, donde ~square~ es el procedimiento generado en [[figure-3.2][Figura 3.2]]. Aplicar el procedimiento resulta en la creación de un nuevo entorno, etiquetado E1 en la figura, que comienza con un marco en el que ~x~, el parámetro formal para el procedimiento, está enlazado al argumento 5. El puntero que conduce hacia arriba desde este marco muestra que el entorno circundante del marco es el entorno global. El entorno global se elige aquí, porque este es el entorno que se indica como parte del objeto de procedimiento ~square~. Dentro de E1, evaluamos el cuerpo del procedimiento, ~(* x x)~. Dado que el valor de ~x~ en E1 es 5, el resultado es ~(* 5 5)~, o 25.

<<figure-3.3>> Entorno creado al evaluar ~(square 5)~ en el entorno global.

#+begin_example
           +------------------------------------+
           | other variables                    |
 global -->|                                    |
 env       | square: --+                        |
           +-----------|---------------------+--+
                       |       ^             ^
 (square 5)            |       |             |
                       V       |             |
                   .---.---.   |         +---+--+
                   | O | O-+---+   E1 -->| x: 5 |
                   `-|-^---'             +------+
                     |
                     V
                   parameters: x
                   body: (* x x)
#+end_example

El modelo de entornos de aplicación de procedimientos puede resumirse mediante dos reglas:

1. Un objeto de procedimiento se aplica a un conjunto de argumentos construyendo un marco, enlazando los parámetros formales del procedimiento a los argumentos de la llamada, y luego evaluando el cuerpo del procedimiento en el contexto del nuevo entorno construido. El nuevo marco tiene como su entorno circundante la parte del entorno del objeto de procedimiento que se está aplicando.

2. Un procedimiento se crea evaluando una expresión ~lambda~ relativa a un entorno dado. El objeto de procedimiento resultante es un par que consiste en el texto de la expresión ~lambda~ y un puntero al entorno en el que se creó el procedimiento.

También especificamos que definir un símbolo usando ~define~ crea un enlace en el marco del entorno actual y asigna al símbolo el valor indicado.[fn:141] Finalmente, especificamos el comportamiento de ~set!~, la operación que nos obligó a introducir el modelo de entornos en primer lugar. Evaluar la expresión '(set! <VARIABLE> <VALUE>)' en algún entorno localiza el enlace de la variable en el entorno y cambia ese enlace para indicar el nuevo valor. Es decir, uno encuentra el primer marco en el entorno que contiene un enlace para la variable y modifica ese marco. Si la variable no está enlazada en el entorno, entonces ~set!~ señala un error.

Estas reglas de evaluación, aunque considerablemente más complejas que el modelo de sustitución, aún son razonablemente directas. Además, el modelo de evaluación, aunque abstracto, proporciona una descripción correcta de cómo el intérprete evalúa expresiones. En [[#section-4][Capítulo 4]] veremos cómo este modelo puede servir como un plano para implementar un intérprete funcional. Las siguientes secciones elaboran los detalles del modelo analizando algunos programas ilustrativos.

*** 3.2.2 Aplicación de procedimientos simples
:properties:
:custom_id: section-3.2.2
:end:

Cuando introdujimos el modelo de sustitución en la sección [[#section-1.1.5][1.1.5]] mostramos cómo la combinación ~(f 5)~ se evalúa a 136, dadas las siguientes definiciones de procedimiento:

#+begin_src scheme
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
#+end_src

Podemos analizar el mismo ejemplo usando el modelo de entornos. [[figure-3.4][Figura 3.4]] muestra los tres objetos de procedimiento creados al evaluar las definiciones de ~f~, ~square~ y ~sum-of-squares~ en el entorno global. Cada objeto de procedimiento consiste en algún código, junto con un puntero al entorno global.

<<figure-3.4>> Objetos de procedimiento en el marco global.

#+begin_example
           +--------------------------------------------+
           | sum-of-squares:                            |
 global -->| square:                                    |
 env       | f: --+                                     |
           +------|--------------+--------------+-------+
                  |     ^        |     ^        |     ^
                  |     |        |     |        |     |
                  V     |        V     |        V     |
              .---.---. |    .---.---. |    .---.---. |
              | O | O-+-+    | O | O-+-+    | O | O-+-+
              `-|-^---'      `-|-^---'      `-|-^---'
                |              |              |
                V              V              V
    parameters: a          parameters: x  parameters: x, y
    body: (sum-of-squares  body: (* x x)  body: (+ (square x)
            (+ a 1)                                (square y))
            (* a 2))
#+end_example

En [[figure-3.5][Figura 3.5]] vemos la estructura de entorno creada al evaluar la expresión ~(f 5)~. La llamada a ~f~ crea un nuevo entorno E1 que comienza con un marco en el que ~a~, el parámetro formal de ~f~, está enlazado al argumento 5. En E1, evaluamos el cuerpo de ~f~:

#+begin_src scheme
(sum-of-squares (+ a 1) (* a 2))
#+end_src

<<figure-3.5>> Entornos creados al evaluar ~(f 5)~ usando los procedimientos en [[figure-3.4][Figura 3.4]].

#+begin_example
           +-----------------------------------------------------+
 global -->|                                                     |
 env       +-----------------------------------------------------+
             ^              ^                ^               ^
 (f 5)       |              |                |               |
         +------+       +-------+        +------+        +-------+
   E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
         |      |       | y: 10 |        |      |        |       |
         +------+       +-------+        +------+        +-------+
    (sum-of-squares   (+ (square x)       (* x x)         (* x x)
      (+ a 1)            (square u))
      (+ a 2))
#+end_example

Para evaluar esta combinación, primero evaluamos las subexpresiones. La primera subexpresión, ~sum-of-squares~, tiene un valor que es un objeto de procedimiento. (Observa cómo se encuentra este valor: Primero buscamos en el primer marco de E1, que no contiene ningún enlace para ~sum-of-squares~. Luego procedemos al entorno circundante, es decir, el entorno global, y encontramos el enlace mostrado en [[figure-3.4][Figura 3.4]].) Las otras dos subexpresiones se evalúan aplicando las operaciones primitivas ~+~ y ~*~ para evaluar las dos combinaciones ~(+ a 1)~ y ~(* a 2)~ para obtener 6 y 10, respectivamente.

Ahora aplicamos el objeto de procedimiento ~sum-of-squares~ a los argumentos 6 y 10. Esto resulta en un nuevo entorno E2 en el que los parámetros formales ~x~ y ~y~ están enlazados a los argumentos. Dentro de E2 evaluamos la combinación ~(+ (square x) (square y))~. Esto nos lleva a evaluar ~(square x)~, donde ~square~ se encuentra en el marco global y ~x~ es 6. Una vez más, establecemos un nuevo entorno, E3, en el que ~x~ está enlazado a 6, y dentro de este evaluamos el cuerpo de ~square~, que es ~(* x x)~. También como parte de aplicar ~sum-of-squares~, debemos evaluar la subexpresión ~(square y)~, donde ~y~ es 10. Esta segunda llamada a ~square~ crea otro entorno, E4, en el que ~x~, el parámetro formal de ~square~, está enlazado a 10. Y dentro de E4 debemos evaluar ~(* x x)~.

El punto importante a observar es que cada llamada a ~square~ crea un nuevo entorno que contiene un enlace para ~x~. Podemos ver aquí cómo los diferentes marcos sirven para mantener separadas las diferentes variables locales todas llamadas ~x~. Observa que cada marco creado por ~square~ apunta al entorno global, ya que este es el entorno indicado por el objeto de procedimiento ~square~.

Después de que se evalúan las subexpresiones, se devuelven los resultados. Los valores generados por las dos llamadas a ~square~ son sumados por ~sum-of-squares~, y este resultado es devuelto por ~f~. Dado que nuestro enfoque aquí está en las estructuras de entorno, no nos detendremos en cómo estos valores devueltos se pasan de llamada a llamada; sin embargo, este es también un aspecto importante del proceso de evaluación, y volveremos a él en detalle en [[#section-5][Capítulo 5]].

**** Ejercicio 3.9
:properties:
:custom_id: exercise-3.9
:end:

En la sección [[#section-1.2.1][1.2.1]] utilizamos el modelo de sustitución para analizar dos procedimientos para calcular factoriales, una versión recursiva

#+begin_src scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
#+end_src

y una versión iterativa

#+begin_src scheme
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
#+end_src

Muestra las estructuras de entorno creadas al evaluar ~(factorial 6)~ usando cada versión del procedimiento ~factorial~.[fn:142]

*** 3.2.3 Los marcos como repositorio del estado local
:properties:
:custom_id: section-3.2.3
:end:

Podemos recurrir al modelo de entornos para ver cómo los procedimientos y la asignación se pueden usar para representar objetos con estado local. Como ejemplo, considera el "procesador de retiros" de la sección [[#section-3.1.1][3.1.1]] creado al llamar al procedimiento

#+begin_src scheme
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
#+end_src

Describamos la evaluación de

#+begin_src scheme
(define W1 (make-withdraw 100))
#+end_src

seguida por

#+begin_src scheme
(W1 50)
50
#+end_src

[[figure-3.6][Figura 3.6]] muestra el resultado de definir el procedimiento ~make-withdraw~ en el entorno global. Esto produce un objeto de procedimiento que contiene un puntero al entorno global. Hasta ahora, esto no es diferente de los ejemplos que ya hemos visto, excepto que el cuerpo del procedimiento es en sí mismo una expresión ~lambda~.

<<figure-3.6>> Resultado de definir ~make-withdraw~ en el entorno global.

#+begin_example
           +---------------------------+
 global -->| make-withdraw: --+        |
 env       +------------------|--------+
                              |      ^
                              V      |
                          .---.---.  |
                          | O | O-+--+
                          `-|-^---'
                            |
                            V
          parameters: balance
          body: (lambda (amount)
                  (if (>= balance amount)
                      (begin (set! balance
                                   (- balance amount))
                             balance)
                      "Insufficient funds"))
#+end_example

La parte interesante del cálculo sucede cuando aplicamos el procedimiento ~make-withdraw~ a un argumento:

#+begin_src scheme
(define W1 (make-withdraw 100))
#+end_src

Comenzamos, como de costumbre, configurando un entorno E1 en el que el parámetro formal ~balance~ está enlazado al argumento 100. Dentro de este entorno, evaluamos el cuerpo de ~make-withdraw~, es decir, la expresión ~lambda~. Esto construye un nuevo objeto de procedimiento, cuyo código es como se especifica por el ~lambda~ y cuyo entorno es E1, el entorno en el que se evaluó el ~lambda~ para producir el procedimiento. El objeto de procedimiento resultante es el valor devuelto por la llamada a ~make-withdraw~. Esto está enlazado a ~W1~ en el entorno global, ya que el propio ~define~ se está evaluando en el entorno global. [[figure-3.7][Figura 3.7]] muestra la estructura de entorno resultante.

<<figure-3.7>> Resultado de evaluar ~(define W1 (make-withdraw 100))~.

#+begin_example
           +-----------------------------------------------+
           | make-withdraw: -----------------------+       |
 global -->|                                       |       |
           | W1: --+                               |       |
           +-------|-------------------------------|-------+
                   |                ^              |     ^
                   |                |              V     |
                   |        +-------+------+   .---.---. |
                   |  E1 -->| balance: 100 |   | O | O-+-+
                   |        +--------------+   `-|-^---'
                   V                ^            |
               .---.---.            |            V
             +-+-O | O-+------------+    parameters: balance
             | `---^---'                 body: ...
             V
     parameters: amount
     body: (if (>= balance amount)
               (begin (set! balance (- balance amount))
                      balance)
               "Insufficient funds")
#+end_example

Ahora podemos analizar qué sucede cuando ~W1~ se aplica a un argumento:

#+begin_src scheme
(W1 50)
50
#+end_src

Comenzamos construyendo un marco en el que ~amount~, el parámetro formal de ~W1~, está enlazado al argumento 50. El punto crucial a observar es que este marco tiene como su entorno circundante no el entorno global, sino el entorno E1, porque este es el entorno que se especifica por el objeto de procedimiento ~W1~. Dentro de este nuevo entorno, evaluamos el cuerpo del procedimiento:

#+begin_src scheme
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
#+end_src

La estructura de entorno resultante se muestra en [[figure-3.8][Figura 3.8]]. La expresión que se está evaluando hace referencia tanto a ~amount~ como a ~balance~. ~amount~ se encontrará en el primer marco del entorno, mientras que ~balance~ se encontrará siguiendo el puntero del entorno circundante a E1.

<<figure-3.8>> Entornos creados al aplicar el objeto de procedimiento ~W1~.

#+begin_example
           +---------------------------------------------------+
           | make-withdraw: ...                                |
 global -->|                                                   |
 env       | W1: --+                                           |
           +-------|-------------------------------------------+
                   |               ^
                   |               |
                   |       +-------+------+ Here is the balance
                   | E1 -->| balance: 100 | that will be changed
                   |       +--------------+ by the set!.
                   V               ^   ^
               .---.---.           |   +----+
               | O | O-+-----------+        |
               `-|-^---'             +------+-----+
                 |                   | amount: 50 |
                 V                   +------------+
       parameters: amount   (if (>= balance amount)
       body: ...                (begin (set! balance
                                             (- balance amount))
                                       balance)
                                "Insufficient funds")
#+end_example

Cuando se ejecuta ~set!~, el enlace de ~balance~ en E1 se cambia. Al completarse la llamada a ~W1~, ~balance~ es 50, y el marco que contiene ~balance~ todavía está apuntado por el objeto de procedimiento ~W1~. El marco que enlaza ~amount~ (en el que ejecutamos el código que cambió ~balance~) ya no es relevante, ya que la llamada al procedimiento que lo construyó ha terminado, y no hay punteros a ese marco desde otras partes del entorno. La próxima vez que se llame a ~W1~, esto construirá un nuevo marco que enlace ~amount~ y cuyo entorno circundante sea E1. Vemos que E1 sirve como el "lugar" que contiene la variable de estado local para el objeto de procedimiento ~W1~. [[figure-3.9][Figura 3.9]] muestra la situación después de la llamada a ~W1~.

<<figure-3.9>> Entornos después de la llamada a ~W1~.

#+begin_example
            +------------------------------------+
            | make-withdraw: ...                 |
 global --->|                                    |
 env        | W1: --+                            |
            +-------|----------------------------+
                    |                   ^
                    |                   |
                    |            +------+------+
                    |     E1 --->| balance: 50 |
                    |            +-------------+
                    V                   ^
                .---.---.               |
                | O | O-+---------------+
                `-|-^---'
                  |
                  V
           parameters: amount
           body: ...
#+end_example

Observa qué sucede cuando creamos un segundo objeto "withdraw" haciendo otra llamada a ~make-withdraw~:

#+begin_src scheme
(define W2 (make-withdraw 100))
#+end_src

Esto produce la estructura de entorno de [[figure-3.10][Figura 3.10]], que muestra que ~W2~ es un objeto de procedimiento, es decir, un par con algún código y un entorno. El entorno E2 para ~W2~ fue creado por la llamada a ~make-withdraw~. Contiene un marco con su propio enlace local para ~balance~. Por otro lado, ~W1~ y ~W2~ tienen el mismo código: el código especificado por la expresión ~lambda~ en el cuerpo de ~make-withdraw~.[fn:143] Vemos aquí por qué ~W1~ y ~W2~ se comportan como objetos independientes. Las llamadas a ~W1~ hacen referencia a la variable de estado ~balance~ almacenada en E1, mientras que las llamadas a ~W2~ hacen referencia al ~balance~ almacenado en E2. Por lo tanto, los cambios en el estado local de un objeto no afectan al otro objeto.

<<figure-3.10>> Uso de ~(define W2 (make-withdraw 100))~ para crear un segundo objeto.

#+begin_example
          +-------------------------------------------------+
          | make-withdraw: ...                              |
 global ->| W2: ---------------------------+                |
 env      | W1: --+                        |                |
          +-------|------------------------|----------------+
                  |              ^         |              ^
                  |              |         |              |
                  |       +------+------+  |       +------+-------+
                  |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                  |       +-------------+  |       +--------------+
                  V              ^         V              ^
              .---.---.          |     .---.---.          |
              | O | O-+----------+     | O | O-+----------+
              `-|-^---'                `-|-^---'
                | +----------------------+
                V V
         parameters: amount
         body: ...
#+end_example

**** Ejercicio 3.10
:properties:
:custom_id: exercise-3.10
:end:

En el procedimiento ~make-withdraw~, la variable local ~balance~ se crea como un parámetro de ~make-withdraw~. También podríamos crear la variable de estado local explícitamente, usando ~let~, de la siguiente manera:

#+begin_src scheme
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
#+end_src

Recuerda de la sección [[#section-1.3.2][1.3.2]] que ~let~ es simplemente azúcar sintáctico para una llamada a procedimiento:

#+begin_src scheme
(let ((<VAR> <EXP>)) <BODY>)
#+end_src

se interpreta como una sintaxis alternativa para

#+begin_src scheme
((lambda (<VAR>) <BODY>) <EXP>)
#+end_src

Usa el modelo de entornos para analizar esta versión alternativa de ~make-withdraw~, dibujando figuras como las de arriba para ilustrar las interacciones

#+begin_src scheme
(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
#+end_src

Muestra que las dos versiones de ~make-withdraw~ crean objetos con el mismo comportamiento. ¿En qué se diferencian las estructuras de entorno para las dos versiones?

*** 3.2.4 Definiciones internas
:properties:
:custom_id: section-3.2.4
:end:

La sección [[#section-1.1.8][1.1.8]] introdujo la idea de que los procedimientos pueden tener definiciones internas, lo que lleva a una estructura de bloques como en el siguiente procedimiento para calcular raíces cuadradas:

#+begin_src scheme
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
#+end_src

Ahora podemos usar el modelo de entornos para ver por qué estas definiciones internas se comportan como se desea. [[figure-3.11][Figura 3.11]] muestra el punto en la evaluación de la expresión ~(sqrt 2)~ donde el procedimiento interno ~good-enough?~ ha sido llamado por primera vez con ~guess~ igual a 1.

<<figure-3.11>> Procedimiento ~sqrt~ con definiciones internas.

#+begin_example
           +--------------------------------------------------+
 global -->| sqrt: --+                                        |
 env       |         |                                        |
           +---------|----------------------------------------+
                     V       ^                   ^
                 .---.---.   |                   |
      +----------+-O | O-+---+        +----------+------------+
      |          `---^---'            | x: 2                  |
      V                         E1 -->| good-enough?: -+      |
 parameters: x                        | improve: ...   |      |
 body: (define good-enough? ...)      | sqrt-iter: ... |      |
       (define improve ...)           +----------------|------+
       (define sqrt-iter ...)          ^  ^            |     ^
       (sqrt-iter 1.0)                 |  |            V     |
                             +---------++ |        .---.---. |
                       E2 -->| guess: 1 | |        | O | O-+-+
                             +----------+ |        `-|-^---'
                       call to sqrt-iter  |          |
                                          |          V
                                +---------++    parameters: guess
                          E3 -->| guess: 1 |    body: (< (abs ...)
                                +----------+             ...)
                          call to good-enough?
#+end_example

Observa la estructura del entorno. ~sqrt~ es un símbolo en el entorno global que está enlazado a un objeto de procedimiento cuyo entorno asociado es el entorno global. Cuando se llamó a ~sqrt~, se formó un nuevo entorno E1, subordinado al entorno global, en el que el parámetro ~x~ está enlazado a 2. El cuerpo de ~sqrt~ fue entonces evaluado en E1. Dado que la primera expresión en el cuerpo de ~sqrt~ es

#+begin_src scheme
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
#+end_src

evaluar esta expresión definió el procedimiento ~good-enough?~ en el entorno E1. Para ser más precisos, el símbolo ~good-enough?~ fue agregado al primer marco de E1, enlazado a un objeto de procedimiento cuyo entorno asociado es E1. De manera similar, ~improve~ y ~sqrt-iter~ fueron definidos como procedimientos en E1. Por concisión, [[figure-3.11][Figura 3.11]] muestra sólo el objeto de procedimiento para ~good-enough?~.

Después de que se definieron los procedimientos locales, la expresión ~(sqrt-iter 1.0)~ fue evaluada, todavía en el entorno E1. Entonces el objeto de procedimiento enlazado a ~sqrt-iter~ en E1 fue llamado con 1 como argumento. Esto creó un entorno E2 en el que ~guess~, el parámetro de ~sqrt-iter~, está enlazado a 1. ~sqrt-iter~ a su vez llamó a ~good-enough?~ con el valor de ~guess~ (de E2) como argumento para ~good-enough?~. Esto estableció otro entorno, E3, en el que ~guess~ (el parámetro de ~good-enough?~) está enlazado a 1. Aunque ~sqrt-iter~ y ~good-enough?~ ambos tienen un parámetro llamado ~guess~, estas son dos variables locales distintas ubicadas en marcos diferentes. Además, E2 y E3 ambos tienen E1 como su entorno circundante, porque los procedimientos ~sqrt-iter~ y ~good-enough?~ ambos tienen E1 como su parte del entorno. Una consecuencia de esto es que el símbolo ~x~ que aparece en el cuerpo de ~good-enough?~ hará referencia al enlace de ~x~ que aparece en E1, es decir, el valor de ~x~ con el que se llamó el procedimiento original ~sqrt~.

El modelo de entornos explica así las dos propiedades clave que hacen que las definiciones de procedimientos locales sean una técnica útil para modularizar programas:

- Los nombres de los procedimientos locales no interfieren con nombres externos al procedimiento envolvente, porque los nombres de los procedimientos locales estarán enlazados en el marco que el procedimiento crea cuando se ejecuta, en lugar de estar enlazados en el entorno global.

- Los procedimientos locales pueden acceder a los argumentos del procedimiento envolvente, simplemente usando nombres de parámetros como variables libres. Esto es porque el cuerpo del procedimiento local se evalúa en un entorno que es subordinado al entorno de evaluación del procedimiento envolvente.

**** Ejercicio 3.11
:properties:
:custom_id: exercise-3.11
:end:

En la sección [[#section-3.2.3][3.2.3]] vimos cómo el modelo de entornos describía el comportamiento de procedimientos con estado local. Ahora hemos visto cómo funcionan las definiciones internas. Un procedimiento típico de paso de mensajes contiene ambos aspectos. Considera el procedimiento de cuenta bancaria de la sección [[#section-3.1.1][3.1.1]]:

#+begin_src scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request - MAKE-ACCOUNT"
                       m))))
  dispatch)
#+end_src

Muestra la estructura de entorno generada por la secuencia de interacciones

#+begin_src scheme
(define acc (make-account 50))

((acc 'deposit) 40)
90

((acc 'withdraw) 60)
30
#+end_src

¿Dónde se mantiene el estado local para ~acc~? Supón que definimos otra cuenta

#+begin_src scheme
(define acc2 (make-account 100))
#+end_src

¿Cómo se mantienen distintos los estados locales para las dos cuentas? ¿Qué partes de la estructura de entorno se comparten entre ~acc~ y ~acc2~?
