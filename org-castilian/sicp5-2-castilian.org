** 5.2 Un simulador de máquina de registros
:properties:
:custom_id: section-5.2
:end:

Para adquirir una buena comprensión del diseño de máquinas de registros, debemos probar las máquinas que diseñamos para ver si funcionan como se espera. Una forma de probar un diseño es simular manualmente la operación del controlador, como en el [[#exercise-5.5][Ejercicio 5.5]]. Pero esto es extremadamente tedioso para todas las máquinas excepto las más simples. En esta sección construimos un simulador para máquinas descritas en el lenguaje de máquina de registros. El simulador es un programa Scheme con cuatro procedimientos de interfaz. El primero usa una descripción de una máquina de registros para construir un modelo de la máquina (una estructura de datos cuyas partes corresponden a las partes de la máquina que se va a simular), y los otros tres nos permiten simular la máquina manipulando el modelo:

#+begin_src scheme
(make-machine <REGISTER-NAMES> <OPERATIONS> <CONTROLLER>)
#+end_src

construye y devuelve un modelo de la máquina con los registros, operaciones y controlador dados.

#+begin_src scheme
(set-register-contents! <MACHINE-MODEL> <REGISTER-NAME> <VALUE>)
#+end_src

almacena un valor en un registro simulado en la máquina dada.

#+begin_src scheme
(get-register-contents <MACHINE-MODEL> <REGISTER-NAME>)
#+end_src

devuelve el contenido de un registro simulado en la máquina dada.

#+begin_src scheme
(start <MACHINE-MODEL>)
#+end_src

simula la ejecución de la máquina dada, comenzando desde el principio de la secuencia del controlador y deteniéndose cuando alcanza el final de la secuencia.

Como ejemplo de cómo se usan estos procedimientos, podemos definir ~gcd-machine~ como un modelo de la máquina GCD de la sección [[#section-5.1.1][5.1.1]] de la siguiente manera:

#+begin_src scheme
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b))
     (assign b (reg t))
     (goto (label test-b))
     gcd-done)))
#+end_src

El primer argumento de ~make-machine~ es una lista de nombres de registros. El siguiente argumento es una tabla (una lista de listas de dos elementos) que empareja cada nombre de operación con un procedimiento Scheme que implementa la operación (es decir, produce el mismo valor de salida dado los mismos valores de entrada). El último argumento especifica el controlador como una lista de etiquetas e instrucciones de máquina, como en la sección [[#section-5.1][5.1]].

Para calcular MCD con esta máquina, establecemos los registros de entrada, iniciamos la máquina y examinamos el resultado cuando la simulación termina:

#+begin_src scheme
(set-register-contents! gcd-machine 'a 206)
done

(set-register-contents! gcd-machine 'b 40)
done

(start gcd-machine)
done

(get-register-contents gcd-machine 'a)
2
#+end_src

Esta computación se ejecutará mucho más lentamente que un procedimiento ~gcd~ escrito en Scheme, porque simularemos instrucciones de máquina de bajo nivel, como ~assign~, mediante operaciones mucho más complejas.

**** Ejercicio 5.7
:properties:
:custom_id: exercise-5.7
:end:

Usa el simulador para probar las máquinas que diseñaste en el [[#exercise-5.4][Ejercicio 5.4]].

*** 5.2.1 El modelo de máquina
:properties:
:custom_id: section-5.2.1
:end:

El modelo de máquina generado por ~make-machine~ se representa como un procedimiento con estado local usando las técnicas de paso de mensajes desarrolladas en el [[#section-3][Capítulo 3]]. Para construir este modelo, ~make-machine~ comienza llamando al procedimiento ~make-new-machine~ para construir las partes del modelo de máquina que son comunes a todas las máquinas de registros. Este modelo de máquina básico construido por ~make-new-machine~ es esencialmente un contenedor para algunos registros y una pila, junto con un mecanismo de ejecución que procesa las instrucciones del controlador una por una.

~make-machine~ luego extiende este modelo básico (enviándole mensajes) para incluir los registros, operaciones y controlador de la máquina particular que se está definiendo. Primero asigna un registro en la nueva máquina para cada uno de los nombres de registros suministrados e instala las operaciones designadas en la máquina. Luego usa un <<i22>> ensamblador (descrito más adelante en la sección [[#section-5.2.2][5.2.2]]) para transformar la lista del controlador en instrucciones para la nueva máquina e instala estas como la secuencia de instrucciones de la máquina. ~make-machine~ devuelve como su valor el modelo de máquina modificado.

#+begin_src scheme
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
#+end_src

*Registros*

Representaremos un registro como un procedimiento con estado local, como en el [[#section-3][Capítulo 3]]. El procedimiento ~make-register~ crea un registro que contiene un valor que puede ser accedido o cambiado:

#+begin_src scheme
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request - REGISTER" message))))
    dispatch))
#+end_src

Los siguientes procedimientos se usan para acceder a los registros:

#+begin_src scheme
(define (get-contents register)
  (register 'get))

(define (set-contents! register value)
  ((register 'set) value))
#+end_src

*La pila*

También podemos representar una pila como un procedimiento con estado local. El procedimiento ~make-stack~ crea una pila cuyo estado local consiste en una lista de los elementos en la pila. Una pila acepta solicitudes para hacer ~push~ de un elemento en la pila, hacer ~pop~ del elemento superior de la pila y devolverlo, y para ~initialize~ la pila a vacía.

#+begin_src scheme
(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack - POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request - STACK"
                         message))))
    dispatch))
#+end_src

Los siguientes procedimientos se usan para acceder a las pilas:

#+begin_src scheme
(define (pop stack)
  (stack 'pop))

(define (push stack value)
  ((stack 'push) value))
#+end_src

*La máquina básica*

El procedimiento ~make-new-machine~, mostrado en la [[figure-5.13][Figura 5.13]], construye un objeto cuyo estado local consiste en una pila, una secuencia de instrucciones inicialmente vacía, una lista de operaciones que inicialmente contiene una operación para inicializar la pila, y una <<i331>> tabla de registros que inicialmente contiene dos registros, llamados ~flag~ y ~pc~ (por "program counter", o "contador de programa"). El procedimiento interno ~allocate-register~ añade nuevas entradas a la tabla de registros, y el procedimiento interno ~lookup-register~ busca registros en la tabla.

El registro ~flag~ se usa para controlar la ramificación en la máquina simulada. Las instrucciones ~test~ establecen el contenido de ~flag~ al resultado de la prueba (verdadero o falso). Las instrucciones ~branch~ deciden si ramificar o no examinando el contenido de ~flag~.

El registro ~pc~ determina la secuenciación de instrucciones mientras se ejecuta la máquina. Esta secuenciación se implementa mediante el procedimiento interno ~execute~. En el modelo de simulación, cada instrucción de máquina es una estructura de datos que incluye un procedimiento sin argumentos, llamado el <<i185>> procedimiento de ejecución de instrucción, tal que llamar a este procedimiento simula la ejecución de la instrucción. A medida que se ejecuta la simulación, ~pc~ apunta al lugar en la secuencia de instrucciones que comienza con la siguiente instrucción a ejecutar. ~execute~ obtiene esa instrucción, la ejecuta llamando al procedimiento de ejecución de instrucción, y repite este ciclo hasta que no hay más instrucciones que ejecutar (es decir, hasta que ~pc~ apunta al final de la secuencia de instrucciones).

<<figure-5.13>> El procedimiento ~make-new-machine~, que implementa el modelo de máquina básico.

#+begin_src scheme
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
              (cons (list name (make-register name))
                    register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request - MACHINE" message))))
      dispatch)))
#+end_src

Como parte de su operación, cada procedimiento de ejecución de instrucción modifica ~pc~ para indicar la siguiente instrucción a ejecutar. Las instrucciones ~branch~ y ~goto~ cambian ~pc~ para apuntar al nuevo destino. Todas las demás instrucciones simplemente avanzan ~pc~, haciéndolo apuntar a la siguiente instrucción en la secuencia. Observa que cada llamada a ~execute~ llama a ~execute~ de nuevo, pero esto no produce un bucle infinito porque ejecutar el procedimiento de ejecución de instrucción cambia el contenido de ~pc~.

~make-new-machine~ devuelve un procedimiento ~dispatch~ que implementa el acceso por paso de mensajes al estado interno. Nota que iniciar la máquina se logra estableciendo ~pc~ al principio de la secuencia de instrucciones y llamando a ~execute~.

Por conveniencia, proporcionamos una interfaz procedimental alternativa para la operación ~start~ de una máquina, así como procedimientos para establecer y examinar el contenido de los registros, como se especifica al principio de la sección [[#section-5.2][5.2]]:

#+begin_src scheme
(define (start machine)
  (machine 'start))

(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))

(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
#+end_src

Estos procedimientos (y muchos procedimientos en las secciones [[#section-5.2.2][5.2.2]] y [[#section-5.2.3][5.2.3]]) usan lo siguiente para buscar el registro con un nombre dado en una máquina dada:

#+begin_src scheme
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
#+end_src

*** 5.2.2 El ensamblador
:properties:
:custom_id: section-5.2.2
:end:

El ensamblador transforma la secuencia de expresiones del controlador para una máquina en una lista correspondiente de instrucciones de máquina, cada una con su procedimiento de ejecución. En general, el ensamblador es muy parecido a los evaluadores que estudiamos en el [[#section-4][Capítulo 4]]--hay un lenguaje de entrada (en este caso, el lenguaje de máquina de registros) y debemos realizar una acción apropiada para cada tipo de expresión en el lenguaje.

La técnica de producir un procedimiento de ejecución para cada instrucción es justo lo que usamos en la sección [[#section-4.1.7][4.1.7]] para acelerar el evaluador separando el análisis de la ejecución en tiempo de ejecución. Como vimos en el [[#section-4][Capítulo 4]], mucho análisis útil de expresiones Scheme podría realizarse sin conocer los valores reales de las variables. Aquí, de manera análoga, mucho análisis útil de expresiones del lenguaje de máquina de registros puede realizarse sin conocer el contenido real de los registros de la máquina. Por ejemplo, podemos reemplazar referencias a registros por punteros a los objetos de registro, y podemos reemplazar referencias a etiquetas por punteros al lugar en la secuencia de instrucciones que la etiqueta designa.

Antes de que pueda generar los procedimientos de ejecución de instrucción, el ensamblador debe saber a qué se refieren todas las etiquetas, por lo que comienza escaneando el texto del controlador para separar las etiquetas de las instrucciones. Mientras escanea el texto, construye tanto una lista de instrucciones como una tabla que asocia cada etiqueta con un puntero en esa lista. Luego el ensamblador aumenta la lista de instrucciones insertando el procedimiento de ejecución para cada instrucción.

El procedimiento ~assemble~ es la entrada principal al ensamblador. Toma el texto del controlador y el modelo de máquina como argumentos y devuelve la secuencia de instrucciones que se almacenará en el modelo. ~assemble~ llama a ~extract-labels~ para construir la lista de instrucciones inicial y la tabla de etiquetas a partir del texto del controlador suministrado. El segundo argumento de ~extract-labels~ es un procedimiento que se llamará para procesar estos resultados: Este procedimiento usa ~update-insts!~ para generar los procedimientos de ejecución de instrucción e insertarlos en la lista de instrucciones, y devuelve la lista modificada.

#+begin_src scheme
(define (assemble controller-text machine)
  (extract-labels controller-text
                  (lambda (insts labels)
                    (update-insts! insts labels machine)
                    insts)))
#+end_src

~extract-labels~ toma como argumentos una lista ~text~ (la secuencia de expresiones de instrucciones del controlador) y un procedimiento ~receive~. ~receive~ será llamado con dos valores: (1) una lista ~insts~ de estructuras de datos de instrucciones, cada una conteniendo una instrucción de ~text~; y (2) una tabla llamada ~labels~, que asocia cada etiqueta de ~text~ con la posición en la lista ~insts~ que la etiqueta designa.

#+begin_src scheme
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
                      (lambda (insts labels)
                        (let ((next-inst (car text)))
                          (if (symbol? next-inst)
                              (receive insts
                                  (cons (make-label-entry next-inst
                                                          insts)
                                        labels))
                              (receive (cons (make-instruction next-inst)
                                             insts)
                                  labels)))))))
#+end_src

~extract-labels~ funciona escaneando secuencialmente los elementos del ~text~ y acumulando los ~insts~ y las ~labels~. Si un elemento es un símbolo (y por tanto una etiqueta) se añade una entrada apropiada a la tabla ~labels~. De lo contrario, el elemento se acumula en la lista ~insts~.[fn:289]

~update-insts!~ modifica la lista de instrucciones, que inicialmente contiene solo el texto de las instrucciones, para incluir los procedimientos de ejecución correspondientes:

#+begin_src scheme
(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc!
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
#+end_src

La estructura de datos de instrucción de máquina simplemente empareja el texto de la instrucción con el procedimiento de ejecución correspondiente. El procedimiento de ejecución aún no está disponible cuando ~extract-labels~ construye la instrucción, y se inserta más tarde por ~update-insts!~.

#+begin_src scheme
(define (make-instruction text)
  (cons text '()))

(define (instruction-text inst)
  (car inst))

(define (instruction-execution-proc inst)
  (cdr inst))

(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
#+end_src

El texto de la instrucción no es usado por nuestro simulador, pero es útil mantenerlo para depuración (ver [[#exercise-5.16][Ejercicio 5.16]]).

Los elementos de la tabla de etiquetas son pares:

#+begin_src scheme
(define (make-label-entry label-name insts)
  (cons label-name insts))
#+end_src

Las entradas se buscarán en la tabla con

#+begin_src scheme
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label - ASSEMBLE" label-name))))
#+end_src

**** Ejercicio 5.8
:properties:
:custom_id: exercise-5.8
:end:

El siguiente código de máquina de registros es ambiguo, porque la etiqueta ~here~ está definida más de una vez:

#+begin_src scheme
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
#+end_src

Con el simulador tal como está escrito, ¿cuál será el contenido del registro ~a~ cuando el control alcance ~there~? Modifica el procedimiento ~extract-labels~ para que el ensamblador señale un error si el mismo nombre de etiqueta se usa para indicar dos ubicaciones diferentes.

*** 5.2.3 Generación de procedimientos de ejecución para instrucciones
:properties:
:custom_id: section-5.2.3
:end:

El ensamblador llama a ~make-execution-procedure~ para generar el procedimiento de ejecución para una instrucción. Al igual que el procedimiento ~analyze~ en el evaluador de la sección [[#section-4.1.7][4.1.7]], este despacha según el tipo de instrucción para generar el procedimiento de ejecución apropiado.

#+begin_src scheme
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type - ASSEMBLE"
                     inst))))
#+end_src

Para cada tipo de instrucción en el lenguaje de máquina de registros, hay un generador que construye un procedimiento de ejecución apropiado. Los detalles de estos procedimientos determinan tanto la sintaxis como el significado de las instrucciones individuales en el lenguaje de máquina de registros. Usamos abstracción de datos para aislar la sintaxis detallada de las expresiones de máquina de registros del mecanismo de ejecución general, como hicimos para los evaluadores en la sección [[#section-4.1.2][4.1.2]], usando procedimientos de sintaxis para extraer y clasificar las partes de una instrucción.

*Instrucciones ~Assign~*

El procedimiento ~make-assign~ maneja las instrucciones ~assign~:

#+begin_src scheme
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda () ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))
#+end_src

~make-assign~ extrae el nombre del registro destino (el segundo elemento de la instrucción) y la expresión de valor (el resto de la lista que forma la instrucción) de la instrucción ~assign~ usando los selectores

#+begin_src scheme
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))

(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
#+end_src

El nombre del registro se busca con ~get-register~ para producir el objeto de registro destino. La expresión de valor se pasa a ~make-operation-exp~ si el valor es el resultado de una operación, y a ~make-primitive-exp~ en caso contrario. Estos procedimientos (mostrados abajo) analizan la expresión de valor y producen un procedimiento de ejecución para el valor. Este es un procedimiento sin argumentos, llamado ~value-proc~, que será evaluado durante la simulación para producir el valor real que se asignará al registro. Nota que el trabajo de buscar el nombre del registro y analizar la expresión de valor se realiza solo una vez, en tiempo de ensamblado, no cada vez que se simula la instrucción. Este ahorro de trabajo es la razón por la que usamos procedimientos de ejecución, y corresponde directamente al ahorro de trabajo que obtuvimos al separar el análisis del programa de la ejecución en el evaluador de la sección [[#section-4.1.7][4.1.7]].

El resultado devuelto por ~make-assign~ es el procedimiento de ejecución para la instrucción ~assign~. Cuando se llama a este procedimiento (por el procedimiento ~execute~ del modelo de máquina), establece el contenido del registro destino al resultado obtenido al ejecutar ~value-proc~. Luego avanza el ~pc~ a la siguiente instrucción ejecutando el procedimiento

#+begin_src scheme
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
#+end_src

~advance-pc~ es la terminación normal para todas las instrucciones excepto ~branch~ y ~goto~.

*Instrucciones 'Test', 'branch' y 'goto'*

~make-test~ maneja las instrucciones ~test~ de manera similar. Extrae la expresión que especifica la condición a probar y genera un procedimiento de ejecución para ella. En tiempo de simulación, se llama al procedimiento para la condición, el resultado se asigna al registro ~flag~, y el ~pc~ se avanza:

#+begin_src scheme
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction - ASSEMBLE" inst))))

(define (test-condition test-instruction)
  (cdr test-instruction))
#+end_src

El procedimiento de ejecución para una instrucción ~branch~ verifica el contenido del registro ~flag~ y o bien establece el contenido del ~pc~ al destino de la ramificación (si se toma la ramificación) o simplemente avanza el ~pc~ (si no se toma la ramificación). Nota que el destino indicado en una instrucción ~branch~ debe ser una etiqueta, y el procedimiento ~make-branch~ lo garantiza. Nota también que la etiqueta se busca en tiempo de ensamblado, no cada vez que se simula la instrucción ~branch~.

#+begin_src scheme
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction - ASSEMBLE" inst))))

(define (branch-dest branch-instruction)
  (cadr branch-instruction))
#+end_src

Una instrucción ~goto~ es similar a una ramificación, excepto que el destino puede especificarse como una etiqueta o como un registro, y no hay condición que verificar--el ~pc~ siempre se establece al nuevo destino.

#+begin_src scheme
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction - ASSEMBLE"
                       inst)))))

(define (goto-dest goto-instruction)
  (cadr goto-instruction))
#+end_src

*Otras instrucciones*

Las instrucciones de pila ~save~ y ~restore~ simplemente usan la pila con el registro designado y avanzan el ~pc~:

#+begin_src scheme
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
#+end_src

El tipo de instrucción final, manejado por ~make-perform~, genera un procedimiento de ejecución para la acción a realizar. En tiempo de simulación, el procedimiento de acción se ejecuta y el ~pc~ se avanza.

#+begin_src scheme
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction - ASSEMBLE" inst))))

(define (perform-action inst) (cdr inst))
#+end_src

*Procedimientos de ejecución para subexpresiones*

El valor de una expresión ~reg~, ~label~ o ~const~ puede necesitarse para la asignación a un registro (~make-assign~) o para entrada a una operación (~make-operation-exp~, abajo). El siguiente procedimiento genera procedimientos de ejecución para producir valores para estas expresiones durante la simulación:

#+begin_src scheme
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type - ASSEMBLE" exp))))
#+end_src

La sintaxis de las expresiones ~reg~, ~label~ y ~const~ está determinada por

#+begin_src scheme
(define (register-exp? exp) (tagged-list? exp 'reg))

(define (register-exp-reg exp) (cadr exp))

(define (constant-exp? exp) (tagged-list? exp 'const))

(define (constant-exp-value exp) (cadr exp))

(define (label-exp? exp) (tagged-list? exp 'label))

(define (label-exp-label exp) (cadr exp))
#+end_src

Las instrucciones ~assign~, ~perform~ y ~test~ pueden incluir la aplicación de una operación de máquina (especificada por una expresión ~op~) a algunos operandos (especificados por expresiones ~reg~ y ~const~). El siguiente procedimiento produce un procedimiento de ejecución para una "expresión de operación"--una lista que contiene la operación y las expresiones de operandos de la instrucción:

#+begin_src scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
#+end_src

La sintaxis de las expresiones de operación está determinada por

#+begin_src scheme
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
#+end_src

Observa que el tratamiento de las expresiones de operación es muy parecido al tratamiento de las aplicaciones de procedimientos por el procedimiento ~analyze-application~ en el evaluador de la sección [[#section-4.1.7][4.1.7]] en que generamos un procedimiento de ejecución para cada operando. En tiempo de simulación, llamamos a los procedimientos de operandos y aplicamos el procedimiento Scheme que simula la operación a los valores resultantes. El procedimiento de simulación se encuentra buscando el nombre de la operación en la tabla de operaciones para la máquina:

#+begin_src scheme
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation - ASSEMBLE" symbol))))
#+end_src

**** Ejercicio 5.9
:properties:
:custom_id: exercise-5.9
:end:

El tratamiento de las operaciones de máquina anterior les permite operar sobre etiquetas así como sobre constantes y el contenido de los registros. Modifica los procedimientos de procesamiento de expresiones para garantizar la condición de que las operaciones solo pueden usarse con registros y constantes.

**** Ejercicio 5.10
:properties:
:custom_id: exercise-5.10
:end:

Diseña una nueva sintaxis para las instrucciones de máquina de registros y modifica el simulador para usar tu nueva sintaxis. ¿Puedes implementar tu nueva sintaxis sin cambiar ninguna parte del simulador excepto los procedimientos de sintaxis en esta sección?

**** Ejercicio 5.11
:properties:
:custom_id: exercise-5.11
:end:

Cuando introdujimos ~save~ y ~restore~ en la sección [[#section-5.1.4][5.1.4]], no especificamos qué pasaría si intentaras restaurar un registro que no fue el último guardado, como en la secuencia

#+begin_src scheme
(save y)
(save x)
(restore y)
#+end_src

Hay varias posibilidades razonables para el significado de ~restore~:

a. ~(restore y)~ coloca en ~y~ el último valor guardado en la pila, sin importar de qué registro vino ese valor. Esta es la forma en que se comporta nuestro simulador. Muestra cómo aprovechar este comportamiento para eliminar una instrucción de la máquina Fibonacci de la sección [[#section-5.1.4][5.1.4]] ([[figure-5.12][Figura 5.12]]).

b. ~(restore y)~ coloca en ~y~ el último valor guardado en la pila, pero solo si ese valor fue guardado desde ~y~; de lo contrario, señala un error. Modifica el simulador para comportarse de esta manera. Tendrás que cambiar ~save~ para poner el nombre del registro en la pila junto con el valor.

c. ~(restore y)~ coloca en ~y~ el último valor guardado desde ~y~ sin importar qué otros registros fueron guardados después de ~y~ y no restaurados. Modifica el simulador para comportarse de esta manera. Tendrás que asociar una pila separada con cada registro. Debes hacer que la operación ~initialize-stack~ inicialice todas las pilas de registros.

**** Ejercicio 5.12
:properties:
:custom_id: exercise-5.12
:end:

El simulador puede usarse para ayudar a determinar las rutas de datos requeridas para implementar una máquina con un controlador dado. Extiende el ensamblador para almacenar la siguiente información en el modelo de máquina:

- una lista de todas las instrucciones, con duplicados eliminados, ordenadas por tipo de instrucción (~assign~, ~goto~, etc.);

- una lista (sin duplicados) de los registros usados para contener puntos de entrada (estos son los registros referenciados por instrucciones ~goto~);

- una lista (sin duplicados) de los registros que son guardados (~save~) o restaurados (~restore~);

- para cada registro, una lista (sin duplicados) de las fuentes desde las cuales se asigna (por ejemplo, las fuentes para el registro ~val~ en la máquina factorial de la [[figure-5.11][Figura 5.11]] son ~(const 1)~ y ~((op *) (reg n) (reg val))~).

Extiende la interfaz de paso de mensajes a la máquina para proporcionar acceso a esta nueva información. Para probar tu analizador, define la máquina Fibonacci de la [[figure-5.12][Figura 5.12]] y examina las listas que construiste.

**** Ejercicio 5.13
:properties:
:custom_id: exercise-5.13
:end:

Modifica el simulador para que use la secuencia del controlador para determinar qué registros tiene la máquina en lugar de requerir una lista de registros como argumento de ~make-machine~. En lugar de preasignar los registros en ~make-machine~, puedes asignarlos uno a la vez cuando se vean por primera vez durante el ensamblado de las instrucciones.

*** 5.2.4 Monitoreo del rendimiento de la máquina
:properties:
:custom_id: section-5.2.4
:end:

La simulación es útil no solo para verificar la corrección de un diseño de máquina propuesto sino también para medir el rendimiento de la máquina. Por ejemplo, podemos instalar en nuestro programa de simulación un "medidor" que mida el número de operaciones de pila usadas en un cómputo. Para hacer esto, modificamos nuestra pila simulada para llevar un registro del número de veces que los registros se guardan en la pila y la profundidad máxima alcanzada por la pila, y añadimos un mensaje a la interfaz de la pila que imprime las estadísticas, como se muestra abajo. También añadimos una operación al modelo de máquina básico para imprimir las estadísticas de la pila, inicializando ~the-ops~ en ~make-new-machine~ a

#+begin_src scheme
(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
#+end_src

Aquí está la nueva versión de ~make-stack~:

#+begin_src scheme
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack - POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Unknown request - STACK" message))))
    dispatch))
#+end_src

El [[#exercise-5.15][Ejercicio 5.15]] hasta el [[#exercise-5.19][Ejercicio 5.19]] describen otras características útiles de monitoreo y depuración que pueden añadirse al simulador de máquina de registros.

**** Ejercicio 5.14
:properties:
:custom_id: exercise-5.14
:end:

Mide el número de operaciones push y la profundidad máxima de la pila requerida para calcular n! para varios valores pequeños de n usando la máquina factorial mostrada en la [[figure-5.11][Figura 5.11]]. A partir de tus datos determina fórmulas en términos de n para el número total de operaciones push y la profundidad máxima de la pila usada al calcular n! para cualquier n > 1. Nota que cada una de estas es una función lineal de n y por lo tanto está determinada por dos constantes. Para que se impriman las estadísticas, tendrás que aumentar la máquina factorial con instrucciones para inicializar la pila e imprimir las estadísticas. Puede que también quieras modificar la máquina para que lea repetidamente un valor para n, calcule el factorial e imprima el resultado (como hicimos para la máquina GCD en la [[figure-5.4][Figura 5.4]]), para que no tengas que invocar repetidamente ~get-register-contents~, ~set-register-contents!~ y ~start~.

**** Ejercicio 5.15
:properties:
:custom_id: exercise-5.15
:end:

Añade <<i184>> conteo de instrucciones a la simulación de máquina de registros. Es decir, haz que el modelo de máquina lleve un registro del número de instrucciones ejecutadas. Extiende la interfaz del modelo de máquina para aceptar un nuevo mensaje que imprima el valor del conteo de instrucciones y reinicie el conteo a cero.

**** Ejercicio 5.16
:properties:
:custom_id: exercise-5.16
:end:

Aumenta el simulador para proporcionar <<i187>> rastreo de instrucciones. Es decir, antes de que se ejecute cada instrucción, el simulador debe imprimir el texto de la instrucción. Haz que el modelo de máquina acepte mensajes ~trace-on~ y ~trace-off~ para activar y desactivar el rastreo.

**** Ejercicio 5.17
:properties:
:custom_id: exercise-5.17
:end:

Extiende el rastreo de instrucciones del [[#exercise-5.16][Ejercicio 5.16]] para que antes de imprimir una instrucción, el simulador imprima cualquier etiqueta que preceda inmediatamente a esa instrucción en la secuencia del controlador. Ten cuidado de hacer esto de una manera que no interfiera con el conteo de instrucciones ([[#exercise-5.15][Ejercicio 5.15]]). Tendrás que hacer que el simulador retenga la información de etiqueta necesaria.

**** Ejercicio 5.18
:properties:
:custom_id: exercise-5.18
:end:

Modifica el procedimiento ~make-register~ de la sección [[#section-5.2.1][5.2.1]] para que los registros puedan ser rastreados. Los registros deben aceptar mensajes que activen y desactiven el rastreo. Cuando se rastrea un registro, asignar un valor al registro debe imprimir el nombre del registro, el contenido antiguo del registro y el nuevo contenido que se está asignando. Extiende la interfaz al modelo de máquina para permitirte activar y desactivar el rastreo para registros de máquina designados.

**** Ejercicio 5.19
:properties:
:custom_id: exercise-5.19
:end:

Alyssa P. Hacker quiere una característica de <<i43>> punto de interrupción en el simulador para ayudarla a depurar sus diseños de máquina. Has sido contratado para instalar esta característica para ella. Ella quiere poder especificar un lugar en la secuencia del controlador donde el simulador se detendrá y le permitirá examinar el estado de la máquina. Debes implementar un procedimiento

#+begin_src scheme
(set-breakpoint <MACHINE> <LABEL> <N>)
#+end_src

que establezca un punto de interrupción justo antes de la enésima instrucción después de la etiqueta dada. Por ejemplo,

#+begin_src scheme
(set-breakpoint gcd-machine 'test-b 4)
#+end_src

instala un punto de interrupción en ~gcd-machine~ justo antes de la asignación al registro ~a~. Cuando el simulador alcanza el punto de interrupción debe imprimir la etiqueta y el desplazamiento del punto de interrupción y detener la ejecución de instrucciones. Alyssa puede entonces usar ~get-register-contents~ y ~set-register-contents!~ para manipular el estado de la máquina simulada. Ella debe entonces poder continuar la ejecución diciendo

#+begin_src scheme
(proceed-machine <MACHINE>)
#+end_src

También debe poder eliminar un punto de interrupción específico mediante

#+begin_src scheme
(cancel-breakpoint <MACHINE> <LABEL> <N>)
#+end_src

o eliminar todos los puntos de interrupción mediante

#+begin_src scheme
(cancel-all-breakpoints <MACHINE>)
#+end_src

