** 5.3 Asignación de Almacenamiento y Recolección de Basura
:properties:
:custom_id: section-5.3
:end:

En la sección [[#section-5.4][5.4]], mostraremos cómo implementar un evaluador de Scheme como una máquina de registros. Para simplificar la discusión, asumiremos que nuestras máquinas de registros pueden estar equipadas con una <<i215>> memoria estructurada como lista, en la cual las operaciones básicas para manipular datos estructurados como listas son primitivas. Postular la existencia de tal memoria es una abstracción útil cuando uno se enfoca en los mecanismos de control en un intérprete de Scheme, pero esto no refleja una visión realista de las operaciones de datos primitivas reales de las computadoras contemporáneas. Para obtener una imagen más completa de cómo opera un sistema Lisp, debemos investigar cómo la estructura de lista puede ser representada de una manera que sea compatible con las memorias de computadoras convencionales.

Hay dos consideraciones en la implementación de la estructura de lista. La primera es puramente una cuestión de representación: cómo representar la estructura "caja y puntero" de los pares de Lisp, usando solamente las capacidades de almacenamiento y direccionamiento de las memorias de computadoras típicas. La segunda cuestión concierne la gestión de la memoria a medida que avanza un cálculo. La operación de un sistema Lisp depende crucialmente de la capacidad de crear continuamente nuevos objetos de datos. Estos incluyen objetos que son creados explícitamente por los procedimientos de Lisp que están siendo interpretados, así como estructuras creadas por el intérprete mismo, tales como ambientes y listas de argumentos. Aunque la creación constante de nuevos objetos de datos no plantearía ningún problema en una computadora con una cantidad infinita de memoria rápidamente direccionable, las memorias de computadoras están disponibles solo en tamaños finitos (qué lástima). Los sistemas Lisp proporcionan así una <<i26>> facilidad de asignación automática de almacenamiento para soportar la ilusión de una memoria infinita. Cuando un objeto de datos ya no se necesita, la memoria asignada a él se recicla automáticamente y se usa para construir nuevos objetos de datos. Existen varias técnicas para proporcionar tal asignación automática de almacenamiento. El método que discutiremos en esta sección se llama <<i157>> recolección de basura.

*** 5.3.1 Memoria como Vectores
:properties:
:custom_id: section-5.3.1
:end:

Una memoria de computadora convencional puede pensarse como un arreglo de casilleros, cada uno de los cuales puede contener una pieza de información. Cada casillero tiene un nombre único, llamado su <<i12>> dirección o <<i218>> ubicación. Los sistemas de memoria típicos proporcionan dos operaciones primitivas: una que obtiene los datos almacenados en una ubicación especificada y una que asigna nuevos datos a una ubicación especificada. Las direcciones de memoria pueden incrementarse para soportar el acceso secuencial a algún conjunto de los casilleros. Más generalmente, muchas operaciones de datos importantes requieren que las direcciones de memoria sean tratadas como datos, que pueden ser almacenados en ubicaciones de memoria y manipulados en registros de máquina. La representación de la estructura de lista es una aplicación de tal <<i13>> aritmética de direcciones.

Para modelar la memoria de computadora, usamos un nuevo tipo de estructura de datos llamada <<i422>> vector. Abstractamente, un vector es un objeto de datos compuesto cuyos elementos individuales pueden ser accedidos por medio de un índice entero en una cantidad de tiempo que es independiente del índice.[fn:290] Para describir las operaciones de memoria, usamos dos procedimientos primitivos de Scheme para manipular vectores:

- ~(vector-ref <VECTOR> <N>)~ devuelve el elemento n-ésimo del vector.

- ~(vector-set! <VECTOR> <N> <VALUE>)~ establece el elemento n-ésimo del vector al valor designado.

Por ejemplo, si ~v~ es un vector, entonces ~(vector-ref v 5)~ obtiene la quinta entrada en el vector ~v~ y ~(vector-set!  v 5 7)~ cambia el valor de la quinta entrada del vector ~v~ a 7.[fn:291] Para la memoria de computadora, este acceso puede ser implementado mediante el uso de aritmética de direcciones para combinar una <<i34>> dirección base que especifica la ubicación inicial de un vector en memoria con un <<i181>> índice que especifica el desplazamiento de un elemento particular del vector.

*Representación de datos de Lisp*

Podemos usar vectores para implementar las estructuras de pares básicas requeridas para una memoria estructurada como lista. Imaginemos que la memoria de computadora está dividida en dos vectores: ~the-cars~ y ~the-cdrs~. Representaremos la estructura de lista de la siguiente manera: Un puntero a un par es un índice en los dos vectores. El ~car~ del par es la entrada en ~the-cars~ con el índice designado, y el ~cdr~ del par es la entrada en ~the-cdrs~ con el índice designado. También necesitamos una representación para objetos distintos de pares (tales como números y símbolos) y una manera de distinguir un tipo de datos de otro. Hay muchos métodos para lograr esto, pero todos se reducen a usar <<i408>> punteros tipados, es decir, a extender la noción de "puntero" para incluir información sobre el tipo de datos.[fn:292] El tipo de datos permite al sistema distinguir un puntero a un par (que consiste del tipo de datos "par" y un índice en los vectores de memoria) de punteros a otros tipos de datos (que consisten de algún otro tipo de datos y lo que sea que se esté usando para representar datos de ese tipo). Dos objetos de datos se consideran iguales (~eq?~) si sus punteros son idénticos.[fn:293] La [[figure-5.14][Figura 5.14]] ilustra el uso de este método para representar la lista ~((1 2) 3 4)~, cuyo diagrama de caja y puntero también se muestra. Usamos prefijos de letras para denotar la información del tipo de datos. Así, un puntero al par con índice 5 se denota ~p5~, la lista vacía se denota por el puntero ~e0~, y un puntero al número 4 se denota ~n4~. En el diagrama de caja y puntero, hemos indicado en la parte inferior izquierda de cada par el índice del vector que especifica dónde se almacenan el ~car~ y el ~cdr~ del par. Las ubicaciones en blanco en ~the-cars~ y ~the-cdrs~ pueden contener partes de otras estructuras de lista (que no son de interés aquí).

<<figure-5.14>> Representaciones de caja y puntero y de vector de memoria de la lista ~((1 2) 3 4)~.

#+begin_example
                +---+---+               +---+---+    +---+---+
 ((1 2) 3 4) -->| * | *-+-------------->| * | *-+--->| * | / |
                +-|-+---+               +-|-+---+    +-|-+---+
               1  |                    2  |         4  |
                  V                       V            V
                +---+---+    +---+---+  +---+        +---+
                | * | *-+--->| * | / |  | 3 |        | 4 |
                +-|-+---+    +-|-+---+  +---+        +---+
               5  |         7  |
                  V            V
                +---+        +---+
                | 1 |        | 2 |
                +---+        +---+

    Index   0    1    2    3    4    5    6    7    8    ...
          +----+----+----+----+----+----+----+----+----+----
 the-cars |    | p5 | n3 |    | n4 | n1 |    | n2 |    | ...
          +----+----+----+----+----+----+----+----+----+----
 the-cdrs |    | p2 | p4 |    | e0 | p7 |    | e0 |    | ...
          +----+----+----+----+----+----+----+----+----+----
#+end_example

Un puntero a un número, tal como ~n4~, podría consistir de un tipo que indica datos numéricos junto con la representación real del número 4.[fn:294] Para tratar con números que son demasiado grandes para ser representados en la cantidad fija de espacio asignada para un solo puntero, podríamos usar un tipo de datos <<i36>> bignum distinto, para el cual el puntero designa una lista en la cual se almacenan las partes del número.[fn:295]

Un símbolo podría ser representado como un puntero tipado que designa una secuencia de los caracteres que forman la representación impresa del símbolo. Esta secuencia es construida por el lector de Lisp cuando la cadena de caracteres se encuentra inicialmente en la entrada. Dado que queremos que dos instancias de un símbolo sean reconocidas como el "mismo" símbolo por ~eq?~ y queremos que ~eq?~ sea una prueba simple de igualdad de punteros, debemos asegurar que si el lector ve la misma cadena de caracteres dos veces, usará el mismo puntero (a la misma secuencia de caracteres) para representar ambas ocurrencias. Para lograr esto, el lector mantiene una tabla, tradicionalmente llamada el <<i265>> obarray, de todos los símbolos que ha encontrado alguna vez. Cuando el lector encuentra una cadena de caracteres y está a punto de construir un símbolo, verifica el obarray para ver si alguna vez antes ha visto la misma cadena de caracteres. Si no lo ha hecho, usa los caracteres para construir un nuevo símbolo (un puntero tipado a una nueva secuencia de caracteres) y entra este puntero en el obarray. Si el lector ha visto la cadena antes, devuelve el puntero de símbolo almacenado en el obarray. Este proceso de reemplazar cadenas de caracteres por punteros únicos se llama <<i193>> internamiento de símbolos.

*Implementación de las operaciones primitivas de lista*

Dado el esquema de representación anterior, podemos reemplazar cada operación "primitiva" de lista de una máquina de registros con una o más operaciones primitivas de vector. Usaremos dos registros, ~the-cars~ y ~the-cdrs~, para identificar los vectores de memoria, y asumiremos que ~vector-ref~ y ~vector-set!~ están disponibles como operaciones primitivas. También asumimos que las operaciones numéricas sobre punteros (tales como incrementar un puntero, usar un puntero de par para indexar un vector, o sumar dos números) usan solo la porción de índice del puntero tipado.

Por ejemplo, podemos hacer que una máquina de registros soporte las instrucciones

#+begin_src scheme
(assign <REG_1> (op car) (reg <REG_2>))

(assign <REG_1> (op cdr) (reg <REG_2>))
#+end_src

si implementamos estas, respectivamente, como

#+begin_src scheme
(assign <REG_1> (op vector-ref) (reg the-cars) (reg <REG_2>))

(assign <REG_1> (op vector-ref) (reg the-cdrs) (reg <REG_2>))
#+end_src

Las instrucciones

#+begin_src scheme
(perform (op set-car!) (reg <REG_1>) (reg <REG_2>))

(perform (op set-cdr!) (reg <REG_1>) (reg <REG_2>))
#+end_src

se implementan como

#+begin_src scheme
(perform
 (op vector-set!) (reg the-cars) (reg <REG_1>) (reg <REG_2>))

(perform
 (op vector-set!) (reg the-cdrs) (reg <REG_1>) (reg <REG_2>))
#+end_src

~cons~ se realiza asignando un índice no usado y almacenando los argumentos de ~cons~ en ~the-cars~ y ~the-cdrs~ en esa posición del vector indexado. Presumimos que hay un registro especial, ~free~, que siempre contiene un puntero de par que contiene el siguiente índice disponible, y que podemos incrementar la parte del índice de ese puntero para encontrar la siguiente ubicación libre.[fn:296] Por ejemplo, la instrucción

#+begin_src scheme
(assign <REG_1> (op cons) (reg <REG_2>) (reg <REG_3>))
#+end_src

se implementa como la siguiente secuencia de operaciones de vector:[fn:297]

#+begin_src scheme
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg <REG_2>))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg <REG_3>))
(assign <REG_1> (reg free))
(assign free (op +) (reg free) (const 1))
#+end_src

La operación ~eq?~

#+begin_src scheme
(op eq?) (reg <REG_1>) (reg <REG_2>)
#+end_src

simplemente prueba la igualdad de todos los campos en los registros, y los predicados tales como ~pair?~, ~null?~, ~symbol?~, y ~number?~ solo necesitan verificar el campo de tipo.

*Implementación de pilas*

Aunque nuestras máquinas de registros usan pilas, no necesitamos hacer nada especial aquí, ya que las pilas pueden ser modeladas en términos de listas. La pila puede ser una lista de los valores guardados, apuntada por un registro especial ~the-stack~. Así, '(save <REG>)' puede ser implementado como

#+begin_src scheme
(assign the-stack (op cons) (reg <REG>) (reg the-stack))
#+end_src

De manera similar, '(restore <REG>)' puede ser implementado como

#+begin_src scheme
(assign <REG> (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
#+end_src

y ~(perform (op initialize-stack))~ puede ser implementado como

#+begin_src scheme
(assign the-stack (const ()))
#+end_src

Estas operaciones pueden ser expandidas más en términos de las operaciones de vector dadas arriba. Sin embargo, en las arquitecturas de computadoras convencionales, usualmente es ventajoso asignar la pila como un vector separado. Entonces empujar y sacar de la pila puede ser logrado incrementando o decrementando un índice en ese vector.

**** Ejercicio 5.20
:properties:
:custom_id: exercise-5.20
:end:

Dibuja la representación de caja y puntero y la representación de vector de memoria (como en la [[figure-5.14][Figura 5.14]]) de la estructura de lista producida por

#+begin_src scheme
(define x (cons 1 2))
(define y (list x x))
#+end_src

con el puntero ~free~ inicialmente ~p1~. ¿Cuál es el valor final de ~free~? ¿Qué punteros representan los valores de ~x~ y ~y~?

**** Ejercicio 5.21
:properties:
:custom_id: exercise-5.21
:end:

Implementa máquinas de registros para los siguientes procedimientos. Asume que las operaciones de memoria estructurada como lista están disponibles como primitivas de máquina.

a. ~count-leaves~ recursivo:

#+begin_src scheme
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
#+end_src

b. ~count-leaves~ recursivo con contador explícito:

#+begin_src scheme
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
#+end_src

**** Ejercicio 5.22
:properties:
:custom_id: exercise-5.22
:end:

El [[#exercise-3.12][Ejercicio 3.12]] de la sección [[#section-3.3.1][3.3.1]] presentó un procedimiento ~append~ que añade dos listas para formar una nueva lista y un procedimiento ~append!~ que empalma dos listas juntas. Diseña una máquina de registros para implementar cada uno de estos procedimientos. Asume que las operaciones de memoria estructurada como lista están disponibles como operaciones primitivas.
*** 5.3.2 Manteniendo la Ilusión de Memoria Infinita
:properties:
:custom_id: section-5.3.2
:end:

El método de representación esbozado en la sección [[#section-5.3.1][5.3.1]] resuelve el problema de implementar la estructura de lista, siempre que tengamos una cantidad infinita de memoria. Con una computadora real, eventualmente nos quedaremos sin espacio libre en el cual construir nuevos pares.[fn:298] Sin embargo, la mayoría de los pares generados en un cálculo típico se usan solo para contener resultados intermedios. Después de que estos resultados son accedidos, los pares ya no se necesitan--son <<i156>> basura. Por ejemplo, el cálculo

#+begin_src scheme
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
#+end_src

construye dos listas: la enumeración y el resultado de filtrar la enumeración. Cuando la acumulación está completa, estas listas ya no se necesitan, y la memoria asignada puede ser reclamada. Si podemos arreglar recolectar toda la basura periódicamente, y si esto resulta reciclar memoria aproximadamente a la misma tasa a la que construimos nuevos pares, habremos preservado la ilusión de que hay una cantidad infinita de memoria.

Para reciclar pares, debemos tener una manera de determinar qué pares asignados no se necesitan (en el sentido de que sus contenidos ya no pueden influir en el futuro del cálculo). El método que examinaremos para lograr esto se conoce como <<i158>> recolección de basura. La recolección de basura se basa en la observación de que, en cualquier momento en una interpretación de Lisp, los únicos objetos que pueden afectar el futuro del cálculo son aquellos que pueden ser alcanzados por alguna sucesión de operaciones ~car~ y ~cdr~ comenzando desde los punteros que están actualmente en los registros de la máquina.[fn:299] Cualquier celda de memoria que no sea así accesible puede ser reciclada.

Hay muchas maneras de realizar la recolección de basura. El método que examinaremos aquí se llama <<i366>> detener y copiar. La idea básica es dividir la memoria en dos mitades: "memoria de trabajo" y "memoria libre". Cuando ~cons~ construye pares, los asigna en la memoria de trabajo. Cuando la memoria de trabajo está llena, realizamos la recolección de basura localizando todos los pares útiles en la memoria de trabajo y copiándolos en ubicaciones consecutivas en la memoria libre. (Los pares útiles se localizan trazando todos los punteros ~car~ y ~cdr~, comenzando con los registros de la máquina.) Dado que no copiamos la basura, presumiblemente habrá memoria libre adicional que podemos usar para asignar nuevos pares. Además, nada en la memoria de trabajo se necesita, ya que todos los pares útiles en ella han sido copiados. Así, si intercambiamos los roles de la memoria de trabajo y la memoria libre, podemos continuar procesando; nuevos pares serán asignados en la nueva memoria de trabajo (que era la antigua memoria libre). Cuando esta esté llena, podemos copiar los pares útiles en la nueva memoria libre (que era la antigua memoria de trabajo).[fn:300]

*Implementación de un recolector de basura de detener y copiar*

Ahora usamos nuestro lenguaje de máquina de registros para describir el algoritmo de detener y copiar con más detalle. Asumiremos que hay un registro llamado ~root~ que contiene un puntero a una estructura que eventualmente apunta a todos los datos accesibles. Esto puede arreglarse almacenando los contenidos de todos los registros de la máquina en una lista preasignada apuntada por ~root~ justo antes de comenzar la recolección de basura.[fn:301] También asumimos que, además de la memoria de trabajo actual, hay memoria libre disponible en la cual podemos copiar los datos útiles. La memoria de trabajo actual consiste de vectores cuyas direcciones base están en registros llamados ~the-cars~ y ~the-cdrs~, y la memoria libre está en registros llamados ~new-cars~ y ~new-cdrs~.

La recolección de basura se desencadena cuando agotamos las celdas libres en la memoria de trabajo actual, es decir, cuando una operación ~cons~ intenta incrementar el puntero ~free~ más allá del final del vector de memoria. Cuando el proceso de recolección de basura está completo, el puntero ~root~ apuntará a la nueva memoria, todos los objetos accesibles desde ~root~ habrán sido movidos a la nueva memoria, y el puntero ~free~ indicará el siguiente lugar en la nueva memoria donde un nuevo par puede ser asignado. Además, los roles de la memoria de trabajo y la nueva memoria habrán sido intercambiados--nuevos pares serán construidos en la nueva memoria, comenzando en el lugar indicado por ~free~, y la memoria de trabajo (previa) estará disponible como la nueva memoria para la siguiente recolección de basura. La [[figure-5.15][Figura 5.15]] muestra el arreglo de la memoria justo antes y justo después de la recolección de basura.

<<figure-5.15>> Reconfiguración de la memoria por el proceso de recolección de basura.

#+begin_example
              Just before garbage collection

          +------------------------------------+
 the-cars |                                    | working
          | mixture of useful data and garbage | memory
 the-cdrs |                                    |
          +------------------------------------+
                                             ^
                                             | free

          +------------------------------------+
 new-cars |                                    | free
          |            free memory             | memory
 new-cdrs |                                    |
          +------------------------------------+

              Just after garbage collection

          +------------------------------------+
 new-cars |                                    | new
          |          discarded memory          | free
 new-cdrs |                                    | memory
          +------------------------------------+

          +------------------+-----------------+
 the-cars |                  |                 | new
          |   useful data    |    free area    | working
 the-cdrs |                  |                 | memory
          +------------------+-----------------+
                               ^
                               | free
#+end_example

El estado del proceso de recolección de basura es controlado manteniendo dos punteros: ~free~ y ~scan~. Estos se inicializan para apuntar al comienzo de la nueva memoria. El algoritmo comienza reubicando el par apuntado por ~root~ al comienzo de la nueva memoria. El par es copiado, el puntero ~root~ se ajusta para apuntar a la nueva ubicación, y el puntero ~free~ se incrementa. Además, la antigua ubicación del par se marca para mostrar que sus contenidos han sido movidos. Este marcado se hace de la siguiente manera: En la posición ~car~, colocamos una etiqueta especial que señala que este es un objeto ya movido. (Tal objeto se llama tradicionalmente un <<i44>> corazón roto.)[fn:302] En la posición ~cdr~ colocamos una <<i143>> dirección de reenvío que apunta a la ubicación a la cual el objeto ha sido movido.

Después de reubicar la raíz, el recolector de basura entra en su ciclo básico. En cada paso del algoritmo, el puntero ~scan~ (inicialmente apuntando a la raíz reubicada) apunta a un par que ha sido movido a la nueva memoria pero cuyos punteros ~car~ y ~cdr~ todavía se refieren a objetos en la antigua memoria. Estos objetos son cada uno reubicados, y el puntero ~scan~ se incrementa. Para reubicar un objeto (por ejemplo, el objeto indicado por el puntero ~car~ del par que estamos escaneando) verificamos si el objeto ya ha sido movido (como se indica por la presencia de una etiqueta de corazón roto en la posición ~car~ del objeto). Si el objeto aún no ha sido movido, lo copiamos al lugar indicado por ~free~, actualizamos ~free~, establecemos un corazón roto en la antigua ubicación del objeto, y actualizamos el puntero al objeto (en este ejemplo, el puntero ~car~ del par que estamos escaneando) para apuntar a la nueva ubicación. Si el objeto ya ha sido movido, su dirección de reenvío (encontrada en la posición ~cdr~ del corazón roto) se sustituye por el puntero en el par siendo escaneado. Eventualmente, todos los objetos accesibles habrán sido movidos y escaneados, momento en el cual el puntero ~scan~ alcanzará al puntero ~free~ y el proceso terminará.

Podemos especificar el algoritmo de detener y copiar como una secuencia de instrucciones para una máquina de registros. El paso básico de reubicar un objeto se logra mediante una subrutina llamada ~relocate-old-result-in-new~. Esta subrutina obtiene su argumento, un puntero al objeto a ser reubicado, de un registro llamado ~old~. Reubica el objeto designado (incrementando ~free~ en el proceso), pone un puntero al objeto reubicado en un registro llamado ~new~, y retorna ramificándose al punto de entrada almacenado en el registro ~relocate-continue~. Para comenzar la recolección de basura, invocamos esta subrutina para reubicar el puntero ~root~, después de inicializar ~free~ y ~scan~. Cuando la reubicación de ~root~ ha sido lograda, instalamos el nuevo puntero como el nuevo ~root~ y entramos al bucle principal del recolector de basura.

#+begin_src scheme
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
#+end_src

En el bucle principal del recolector de basura debemos determinar si hay más objetos por escanear. Hacemos esto probando si el puntero ~scan~ es coincidente con el puntero ~free~. Si los punteros son iguales, entonces todos los objetos accesibles han sido reubicados, y ramificamos a ~gc-flip~, que limpia las cosas para que podamos continuar el cálculo interrumpido. Si todavía hay pares por escanear, llamamos a la subrutina de reubicación para reubicar el ~car~ del siguiente par (colocando el puntero ~car~ en ~old~). El registro ~relocate-continue~ se configura de modo que la subrutina retornará para actualizar el puntero ~car~.

#+begin_src scheme
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
#+end_src

En ~update-car~, modificamos el puntero ~car~ del par siendo escaneado, luego procedemos a reubicar el ~cdr~ del par. Retornamos a ~update-cdr~ cuando esa reubicación ha sido lograda. Después de reubicar y actualizar el ~cdr~, hemos terminado de escanear ese par, así que continuamos con el bucle principal.

#+begin_src scheme
update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
#+end_src

La subrutina ~relocate-old-result-in-new~ reubica objetos de la siguiente manera: Si el objeto a ser reubicado (apuntado por ~old~) no es un par, entonces retornamos el mismo puntero al objeto sin cambios (en ~new~). (Por ejemplo, podemos estar escaneando un par cuyo ~car~ es el número 4. Si representamos el ~car~ por ~n4~, como se describe en la sección [[#section-5.3.1][5.3.1]], entonces queremos que el puntero ~car~ "reubicado" siga siendo ~n4~.) De lo contrario, debemos realizar la reubicación. Si la posición ~car~ del par a ser reubicado contiene una etiqueta de corazón roto, entonces el par de hecho ya ha sido movido, así que recuperamos la dirección de reenvío (de la posición ~cdr~ del corazón roto) y retornamos esto en ~new~. Si el puntero en ~old~ apunta a un par aún no movido, entonces movemos el par a la primera celda libre en la nueva memoria (apuntada por ~free~) y establecemos el corazón roto almacenando una etiqueta de corazón roto y dirección de reenvío en la antigua ubicación. ~relocate-old-result-in-new~ usa un registro ~oldcr~ para contener el ~car~ o el ~cdr~ del objeto apuntado por ~old~.[fn:303]

#+begin_src scheme
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) ; nueva ubicación para el par
  ;; Actualizar puntero ~free~.
  (assign free (op +) (reg free) (const 1))
  ;; Copiar el ~car~ y el ~cdr~ a la nueva memoria.
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  ;; Construir el corazón roto.
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
#+end_src

Al final del proceso de recolección de basura, intercambiamos el rol de las memorias antigua y nueva intercambiando punteros: intercambiando ~the-cars~ con ~new-cars~, y ~the-cdrs~ con ~new-cdrs~. Estaremos entonces listos para realizar otra recolección de basura la próxima vez que se agote la memoria.

#+begin_src scheme
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
#+end_src
