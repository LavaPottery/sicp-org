* Referencias

1. Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom.  1992.  The Supercomputer Toolkit: A general framework for special-purpose computing.  'International Journal of High-Speed Electronics' 3(3):337-361.

2. Allen, John.  1978.  'Anatomy of Lisp'.  New York: McGraw-Hill.

3. ANSI X3.226-1994.  'American National Standard for Information Systems--Programming Language--Common Lisp'.

4. Appel, Andrew W. 1987.  Garbage collection can be faster than stack allocation.  'Information Processing Letters' 25(4):275-279.

5. Backus, John.  1978.  Can programming be liberated from the von Neumann style?  'Communications of the ACM' 21(8):613-641.

6. Baker, Henry G., Jr.  1978.  List processing in real time on a serial computer.  'Communications of the ACM' 21(4):280-293.

7. Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982.  The Scheme-81 architecture--System and chip.  In 'Proceedings of the MIT Conference on Advanced Research in VLSI', edited by Paul Penfield, Jr.  Dedham, MA: Artech House.

8. Borning, Alan.  1977.  ThingLab--An object-oriented system for building simulations using constraints.  In 'Proceedings of the 5th International Joint Conference on Artificial Intelligence'.

9. Borodin, Alan, and Ian Munro.  1975.  'The Computational Complexity of Algebraic and Numeric Problems'.  New York: American Elsevier.

10. Chaitin, Gregory J. 1975.  Randomness and mathematical proof.  'Scientific American' 232(5):47-52.

11. Church, Alonzo.  1941.  'The Calculi of Lambda-Conversion'.  Princeton, N.J.: Princeton University Press.

12. Clark, Keith L. 1978.  Negation as failure.  In 'Logic and Data Bases'.  New York: Plenum Press, pp.  293-322.

13. Clinger, William.  1982.  Nondeterministic call by need is neither lazy nor by name.  In 'Proceedings of the ACM Symposium on Lisp and Functional Programming', pp.  226-234.

14. Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In 'Proceedings of the 1991 ACM Conference on Principles of Programming Languages', pp. 155-162.

15. Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syste`me de communication homme-machine en franc,ais.  Technical report, Groupe Intelligence Artificielle, Universite' d'Aix Marseille, Luminy.

16. Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990.  'Introduction to Algorithms'.  Cambridge, MA: MIT Press.

17. Darlington, John, Peter Henderson, and David Turner.  1982.  'Functional Programming and Its Applications'.  New York: Cambridge University Press.

18. Dijkstra, Edsger W. 1968a.  The structure of the "THE" multiprogramming system. 'Communications of the ACM' 11(5):341-346.

19. Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In 'Programming Languages', edited by F. Genuys.  New York: Academic Press, pp.  43-112.

20. Dinesman, Howard P. 1968.  'Superior Mathematical Puzzles'.  New York: Simon and Schuster.

21. deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.  AMORD: Explicit control of reasoning.  In 'Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages', pp.  116-125.

22. Doyle, Jon.  1979.  A truth maintenance system.  'Artificial Intelligence' 12:231-272.

23. Feigenbaum, Edward, and Howard Shrobe.  1993.  The Japanese National Fifth Generation Project: Introduction, survey, and evaluation.  In 'Future Generation Computer Systems', vol.  9, pp.  105-117.

24. Feeley, Marc.  1986.  Deux approches a` l'implantation du language Scheme. Masters thesis, Universite' de Montre'al.

25. Feeley, Marc and Guy Lapalme.  1987.  Using closures for code generation. 'Journal of Computer Languages' 12(1):47-66.

26. Feller, William.  1957.  'An Introduction to Probability Theory and Its Applications', volume 1.  New York: John Wiley & Sons.

27. Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for virtual memory computer systems.  'Communications of the ACM' 12(11):611-612.

28. Floyd, Robert.  1967.  Nondeterministic algorithms.  'JACM', 14(4):636-644.

29. Forbus, Kenneth D., and Johan deKleer.  1993.  'Building Problem Solvers'. Cambridge, MA: MIT Press.

30. Friedman, Daniel P., and David S. Wise.  1976.  CONS should not evaluate its arguments.  In 'Automata, Languages, and Programming: Third International Colloquium', edited by S. Michaelson and R. Milner, pp.  257-284.

31. Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes.  1992. 'Essentials of Programming Languages'.  Cambridge, MA: MIT Press/McGraw-Hill.

32. Gabriel, Richard P. 1988.  The Why of /Y/. 'Lisp Pointers' 2(2):15-25.

33. Goldberg, Adele, and David Robson.  1983.  'Smalltalk-80: The Language and Its Implementation'.  Reading, MA: Addison-Wesley.

34. Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  'Edinburgh LCF'. Lecture Notes in Computer Science, volume 78.  New York: Springer-Verlag.

35. Gray, Jim, and Andreas Reuter.  1993.  'Transaction Processing: Concepts and Models'.  San Mateo, CA: Morgan-Kaufman.

36. Green, Cordell.  1969.  Application of theorem proving to problem solving.  In 'Proceedings of the International Joint Conference on Artificial Intelligence', pp.  219-240.

37. Green, Cordell, and Bertram Raphael.  1968.  The use of theorem-proving techniques in question-answering systems.  In 'Proceedings of the ACM National Conference', pp.  169-181.

38. Griss, Martin L. 1981.  Portable Standard Lisp, a brief overview.  Utah Symbolic Computation Group Operating Note 58, University of Utah.

39. Guttag, John V. 1977.  Abstract data types and the development of data structures.  'Communications of the ACM' 20(6):397-404.

40. Hamming, Richard W. 1980.  'Coding and Information Theory'.  Englewood Cliffs, N.J.: Prentice-Hall.

41. Hanson, Christopher P. 1990.  Efficient stack allocation for tail-recursive languages.  In 'Proceedings of ACM Conference on Lisp and Functional Programming', pp.  106-118.

42. Hanson, Christopher P. 1991.  A syntactic closures macro facility.  'Lisp Pointers', 4(3).

43. Hardy, Godfrey H. 1921.  Srinivasa Ramanujan.  'Proceedings of the London Mathematical Society' XIX(2).

44. Hardy, Godfrey H., and E. M. Wright.  1960.  'An Introduction to the Theory of Numbers'.  4th edition.  New York: Oxford University Press.

45. Havender, J. 1968.  Avoiding deadlocks in multi-tasking systems.  'IBM Systems Journal' 7(2):74-84.

46. Hearn, Anthony C. 1969.  Standard Lisp.  Technical report AIM-90, Artificial Intelligence Project, Stanford University.

47. Henderson, Peter.  1980.  'Functional Programming: Application and Implementation'.  Englewood Cliffs, N.J.: Prentice-Hall.

48. Henderson.  Peter.  1982.  Functional Geometry.  In 'Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming', pp.  179-187.

49. Hewitt, Carl E. 1969.  PLANNER: A language for proving theorems in robots.  In 'Proceedings of the International Joint Conference on Artificial Intelligence', pp.  295-301.

50. Hewitt, Carl E. 1977.  Viewing control structures as patterns of passing messages.  'Journal of Artificial Intelligence' 8(3):323-364.

51. Hoare, C. A. R. 1972.  Proof of correctness of data representations.  'Acta Informatica' 1(1).

52. Hodges, Andrew.  1983.  'Alan Turing: The Enigma'.  New York: Simon and Schuster.

53. Hofstadter, Douglas R. 1979.  'Go"del, Escher, Bach: An Eternal Golden Braid'. New York: Basic Books.

54. Hughes, R. J. M. 1990.  Why functional programming matters.  In 'Research Topics in Functional Programming', edited by David Turner.  Reading, MA: Addison-Wesley, pp.  17-42.

55. IEEE Std 1178-1990.  1990.  'IEEE Standard for the Scheme Programming Language'.

56. Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS: A way of compiling procedure statements, with some comments on procedure declarations.  Unpublished manuscript.  (Also, private communication from Wallace Feurzeig.)

57. Kaldewaij, Anne.  1990.  'Programming: The Derivation of Algorithms'.  New York: Prentice-Hall.

58. Kohlbecker, Eugene Edmund, Jr.  1986.  Syntactic extensions in the programming language Lisp.  Ph.D. thesis, Indiana University.

59. Konopasek, Milos, and Sundaresan Jayaraman.  1984.  'The TK!Solver Book: A Guide to Problem-Solving in Science, Engineering, Business, and Education'.  Berkeley, CA: Osborne/McGraw-Hill.

60. Knuth, Donald E. 1973.  'Fundamental Algorithms'.  Volume 1 of 'The Art of Computer Programming'.  2nd edition.  Reading, MA: Addison-Wesley.

61. Knuth, Donald E. 1981.  'Seminumerical Algorithms'.  Volume 2 of 'The Art of Computer Programming'.  2nd edition.  Reading, MA: Addison-Wesley.

62. Kowalski, Robert.  1973.  Predicate logic as a programming language.  Technical report 70, Department of Computational Logic, School of Artificial Intelligence, University of Edinburgh.

63. Kowalski, Robert.  1979.  'Logic for Problem Solving'.  New York: North-Holland.

64. Lamport, Leslie.  1978.  Time, clocks, and the ordering of events in a distributed system.  'Communications of the ACM' 21(7):558-565.

65. Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek. 1981.  Report on the programming language Euclid.  Technical report, Computer Systems Research Group, University of Toronto.

66. Landin, Peter.  1965.  A correspondence between Algol 60 and Church's lambda notation: Part I. 'Communications of the ACM' 8(2):89-101.

67. Lieberman, Henry, and Carl E. Hewitt.  1983.  A real-time garbage collector based on the lifetimes of objects.  'Communications of the ACM' 26(6):419-429.

68. Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification techniques for data abstractions.  'IEEE Transactions on Software Engineering' 1(1):7-19.

69. McAllester, David Allen.  1978.  A three-valued truth-maintenance system.  Memo 473, MIT Artificial Intelligence Laboratory.

70. McAllester, David Allen.  1980.  An outlook on truth maintenance.  Memo 551, MIT Artificial Intelligence Laboratory.

71. McCarthy, John.  1960.  Recursive functions of symbolic expressions and their computation by machine.  'Communications of the ACM' 3(4):184-195.

72. McCarthy, John.  1967.  A basis for a mathematical theory of computation.  In 'Computer Programing and Formal Systems', edited by P. Braffort and D. Hirschberg.  North-Holland.

73. McCarthy, John.  1978.  The history of Lisp.  In 'Proceedings of the ACM SIGPLAN Conference on the History of Programming Languages'.

74. McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I. Levin. 1965.  'Lisp 1.5 Programmer's Manual'.  2nd edition.  Cambridge, MA: MIT Press.

75. McDermott, Drew, and Gerald Jay Sussman.  1972.  Conniver reference manual. Memo 259, MIT Artificial Intelligence Laboratory.

76. Miller, Gary L. 1976.  Riemann's Hypothesis and tests for primality.  'Journal of Computer and System Sciences' 13(3):300-317.

77. Miller, James S., and Guillermo J. Rozas.  1994.  Garbage collection is fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence Laboratory.

78. Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical report, MIT Laboratory for Computer Science.

79. Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.  Technical report, MIT Artificial Intelligence Laboratory.

80. Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience with an applicative string processing language.  In 'Proceedings of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of Programming Languages'.

81. Phillips, Hubert.  1934.  'The Sphinx Problem Book'.  London: Faber and Faber.

82. Pitman, Kent.  1983.  The revised MacLisp Manual (Saturday evening edition). Technical report 295, MIT Laboratory for Computer Science.

83. Rabin, Michael O. 1980.  Probabilistic algorithm for testing primality. 'Journal of Number Theory' 12:128-138.

84. Raymond, Eric.  1993.  'The New Hacker's Dictionary'.  2nd edition.  Cambridge, MA: MIT Press.

85. Raynal, Michel.  1986.  'Algorithms for Mutual Exclusion'.  Cambridge, MA: MIT Press.

86. Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp or, lambda: The ultimate software tool.  In 'Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming', pp.  114-122.

87. Rees, Jonathan, and William Clinger (eds).  1991.  The revised^4 report on the algorithmic language Scheme.  'Lisp Pointers', 4(3).

88. Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for obtaining digital signatures and public-key cryptosystems.  Technical memo LCS/TM82, MIT Laboratory for Computer Science.

89. Robinson, J. A. 1965.  A machine-oriented logic based on the resolution principle.  'Journal of the ACM' 12(1):23.

90. Robinson, J. A. 1983.  Logic programming--Past, present, and future.  'New Generation Computing' 1:107-124.

91. Spafford, Eugene H. 1989.  The Internet Worm: Crisis and aftermath. 'Communications of the ACM' 32(6):678-688.

92. Steele, Guy Lewis, Jr.  1977.  Debunking the "expensive procedure call" myth. In 'Proceedings of the National Conference of the ACM', pp.  153-62.

93. Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In 'Proceedings of the ACM Symposium on Lisp and Functional Programming', pp.  98-107.

94. Steele, Guy Lewis, Jr.  1990.  'Common Lisp: The Language'.  2nd edition. Digital Press.

95. Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An interpreter for the extended lambda calculus.  Memo 349, MIT Artificial Intelligence Laboratory.

96. Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  'The Hacker's Dictionary'.  New York: Harper & Row.

97. Stoy, Joseph E. 1977.  'Denotational Semantics'.  Cambridge, MA: MIT Press.

98. Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic techniques in computer-aided circuit analysis.  'IEEE Transactions on Circuits and Systems' CAS-22(11):857-865.

99. Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints--A language for expressing almost-hierachical descriptions.  'AI Journal' 14:1-39.

100. Sussman, Gerald Jay, and Jack Wisdom.  1992.  Chaotic evolution of the solar system.  'Science' 257:256-262.

101. Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.  Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence Laboratory.

102. Sutherland, Ivan E. 1963.  SKETCHPAD: A man-machine graphical communication system.  Technical report 296, MIT Lincoln Laboratory.

103. Teitelman, Warren.  1974.  Interlisp reference manual.  Technical report, Xerox Palo Alto Research Center.

104. Thatcher, James W., Eric G. Wagner, and Jesse B. Wright.  1978.  Data type specification: Parameterization and the power of specification techniques.  In 'Conference Record of the Tenth Annual ACM Symposium on Theory of Computing', pp.  119-132.

105. Turner, David.  1981.  The future of applicative languages.  In 'Proceedings of the 3rd European Conference on Informatics', Lecture Notes in Computer Science, volume 123.  New York: Springer-Verlag, pp.  334-348.

106. Wand, Mitchell.  1980.  Continuation-based program transformation strategies. 'Journal of the ACM' 27(1):164-180.

107. Waters, Richard C. 1979.  A method for analyzing loop programs.  'IEEE Transactions on Software Engineering' 5(3):237-247.

108. Winograd, Terry.  1971.  Procedures as a representation for data in a computer program for understanding natural language.  Technical report AI TR-17, MIT Artificial Intelligence Laboratory.

109. Winston, Patrick.  1992.  'Artificial Intelligence'.  3rd edition.  Reading, MA: Addison-Wesley.

110. Zabih, Ramin, David McAllester, and David Chapman.  1987.  Non-deterministic Lisp with dependency-directed backtracking.  'AAAI-87', pp.  59-64.

111. Zippel, Richard.  1979.  Probabilistic algorithms for sparse polynomials.  Ph.D. dissertation, Department of Electrical Engineering and Computer Science, MIT.

112. Zippel, Richard.  1993.  'Effective Polynomial Computation'.  Boston, MA: Kluwer Academic Publishers.

* Índice

- [[i1][modelos abstractos]]
- [[i2][sintaxis abstracta]]
- [[i3][barreras de abstracción]]
- [[i4][barreras de abstracción <1>]]
- [[i5][acumulador]]
- [[i6][acumulador <1>]]
- [[i7][adquirido]]
- [[i8][acción]]
- [[i9][aditivo]]
- [[i10][aditivamente]]
- [[i11][aditivamente <1>]]
- [[i12][dirección]]
- [[i13][aritmética de direcciones]]
- [[i14][agenda]]
- [[i15][especificación algebraica]]
- [[i16][aliasing]]
- [[i17][and-gate]]
- [[i18][applicative-order]]
- [[i19][evaluación en orden aplicativo]]
- [[i20][árbitro]]
- [[i21][argumentos]]
- [[i22][ensamblador]]
- [[i23][aserciones]]
- [[i24][operador de asignación]]
- [[i25][atómicamente]]
- [[i26][asignación automática de almacenamiento]]
- [[i27][amortiguación promedio]]
- [[i28][árboles B]]
- [[i29][backbone]]
- [[i30][backquote]]
- [[i31][retrocede]]
- [[i32][balanceado]]
- [[i33][sincronización de barrera]]
- [[i34][dirección base]]
- [[i35][hipótesis de Bertrand]]
- [[i36][bignum]]
- [[i37][enlaces]]
- [[i38][enlaza]]
- [[i39][coeficientes binomiales]]
- [[i40][estructura de bloques]]
- [[i41][variable ligada]]
- [[i42][notación de caja y puntero]]
- [[i43][punto de interrupción]]
- [[i44][corazón roto]]
- [[i45][errores]]
- [[i46][coherencia de caché]]
- [[i47][call-by-name]]
- [[i48][call-by-name <1>]]
- [[i49][thunks call-by-name]]
- [[i50][call-by-need]]
- [[i51][call-by-need <1>]]
- [[i52][thunks call-by-need]]
- [[i53][capturando]]
- [[i54][números de Carmichael]]
- [[i55][análisis de casos]]
- [[i56][celda]]
- [[i57][retroceso cronológico]]
- [[i58][numerales de Church]]
- [[i59][tesis de Church-Turing]]
- [[i60][cláusulas]]
- [[i61][suposición de mundo cerrado]]
- [[i62][clausura]]
- [[i63][propiedad de clausura]]
- [[i64][generador de código]]
- [[i65][coercionar]]
- [[i66][coerción]]
- [[i67][combinaciones]]
- [[i68][comentarios]]
- [[i69][compactación]]
- [[i70][compilación]]
- [[i71][entorno en tiempo de compilación]]
- [[i72][composición]]
- [[i73][datos compuestos]]
- [[i74][objeto de datos compuesto]]
- [[i75][procedimiento compuesto]]
- [[i76][computabilidad]]
- [[i77][proceso computacional]]
- [[i78][concurrentemente]]
- [[i79][congruente módulo]]
- [[i80][conectores]]
- [[i81][expresión consecuente]]
- [[i82][redes de restricciones]]
- [[i83][constructores]]
- [[i84][procedimientos de continuación]]
- [[i85][fracción continua]]
- [[i86][estructura de control]]
- [[i87][controlador]]
- [[i88][interfaces convencionales]]
- [[i89][interfaces convencionales <1>]]
- [[i90][tiempo actual]]
- [[i91][datos]]
- [[i92][datos <1>]]
- [[i93][abstracción de datos]]
- [[i94][abstracción de datos <1>]]
- [[i95][rutas de datos]]
- [[i96][dirigido por datos]]
- [[i97][programación dirigida por datos]]
- [[i98][programación dirigida por datos <1>]]
- [[i99][deadlock]]
- [[i100][recuperación de deadlock]]
- [[i101][depurar]]
- [[i102][deep binding]]
- [[i103][operaciones diferidas]]
- [[i104][argumento diferido]]
- [[i105][evaluación diferida]]
- [[i106][evaluación diferida <1>]]
- [[i107][objeto diferido]]
- [[i108][denso]]
- [[i109][retroceso dirigido por dependencias]]
- [[i110][búsqueda en profundidad]]
- [[i111][deque]]
- [[i112][expresiones derivadas]]
- [[i113][señales digitales]]
- [[i114][despacho por tipo]]
- [[i115][número de desplazamiento]]
- [[i116][notación de cola punteada]]
- [[i117][bucle controlador]]
- [[i118][lista vacía]]
- [[i119][encapsulado]]
- [[i120][entorno envolvente]]
- [[i121][puntos de entrada]]
- [[i122][enumerador]]
- [[i123][entorno]]
- [[i124][modelo de entorno]]
- [[i125][entornos]]
- [[i126][algoritmo de Euclides]]
- [[i127][anillo euclidiano]]
- [[i128][evaluando]]
- [[i129][evaluador]]
- [[i130][simulación dirigida por eventos]]
- [[i131][recursión de cola evlis]]
- [[i132][procedimiento de ejecución]]
- [[i133][evaluador de control explícito]]
- [[i134][expresión]]
- [[i135][continuación de fallo]]
- [[i136][FIFO]]
- [[i137][filtro]]
- [[i138][filtro <1>]]
- [[i139][first-class]]
- [[i140][punto fijo]]
- [[i141][longitud fija]]
- [[i142][forzando]]
- [[i143][dirección de reenvío]]
- [[i144][marco]]
- [[i145][mapa de coordenadas de marco]]
- [[i146][número de marco]]
- [[i147][pila con marcos]]
- [[i148][marcos]]
- [[i149][libre]]
- [[i150][lista libre]]
- [[i151][frente]]
- [[i152][full-adder]]
- [[i153][cajas de función]]
- [[i154][programación funcional]]
- [[i155][lenguajes de programación funcional]]
- [[i156][basura]]
- [[i157][recolección de basura]]
- [[i158][recolección de basura <1>]]
- [[i159][recolector de basura]]
- [[i160][recolectado por el recolector de basura]]
- [[i161][operaciones genéricas]]
- [[i162][procedimientos genéricos]]
- [[i163][procedimientos genéricos <1>]]
- [[i164][glitches]]
- [[i165][global]]
- [[i166][global <1>]]
- [[i167][entorno global]]
- [[i168][proporción áurea]]
- [[i169][gramática]]
- [[i170][half-adder]]
- [[i171][método de intervalo medio]]
- [[i172][teorema de la parada]]
- [[i173][lista con cabecera]]
- [[i174][principio de ocultación]]
- [[i175][jerárquico]]
- [[i176][jerarquía de tipos]]
- [[i177][procedimientos de orden superior]]
- [[i178][regla de Horner]]
- [[i179][programación imperativa]]
- [[i180][indeterminadas]]
- [[i181][índice]]
- [[i182][indexación]]
- [[i183][instanciado con]]
- [[i184][conteo de instrucciones]]
- [[i185][procedimiento de ejecución de instrucciones]]
- [[i186][secuencia de instrucciones]]
- [[i187][trazado de instrucciones]]
- [[i188][instrucciones]]
- [[i189][instrucciones <1>]]
- [[i190][factor entero]]
- [[i191][enteros]]
- [[i192][integrador]]
- [[i193][interning]]
- [[i194][intérprete]]
- [[i195][intérprete <1>]]
- [[i196][cantidad invariante]]
- [[i197][inversor]]
- [[i198][mejora iterativa]]
- [[i199][proceso iterativo]]
- [[i200][fracción continua finita de k términos]]
- [[i201][clave]]
- [[i202][etiquetas]]
- [[i203][evaluación perezosa]]
- [[i204][dirección léxica]]
- [[i205][direccionamiento léxico]]
- [[i206][alcance léxico]]
- [[i207][proceso iterativo lineal]]
- [[i208][proceso recursivo lineal]]
- [[i209][descriptor de enlace]]
- [[i210][lista]]
- [[i211][lista <1>]]
- [[i212][lista <2>]]
- [[i213][estructura de lista]]
- [[i214][estructurado como lista]]
- [[i215][memoria estructurada como lista]]
- [[i216][evolución local]]
- [[i217][variables de estado local]]
- [[i218][ubicación]]
- [[i219][programación lógica]]
- [[i220][and lógico]]
- [[i221][deducciones lógicas]]
- [[i222][or lógico]]
- [[i223][lenguaje de máquina]]
- [[i224][macro]]
- [[i225][map]]
- [[i226][mark-sweep]]
- [[i227][medios de abstracción]]
- [[i228][medios de combinación]]
- [[i229][memoización]]
- [[i230][Memoización]]
- [[i231][memoizar]]
- [[i232][merge]]
- [[i233][paso de mensajes]]
- [[i234][paso de mensajes <1>]]
- [[i235][paso de mensajes]]
- [[i236][metacircular]]
- [[i237][abstracción metalingüística]]
- [[i238][test de Miller-Rabin]]
- [[i239][modular]]
- [[i240][módulo]]
- [[i241][módulo <1>]]
- [[i242][modus ponens]]
- [[i243][momentos en el tiempo]]
- [[i244][integración de Monte Carlo]]
- [[i245][simulación de Monte Carlo]]
- [[i246][objetos de datos mutables]]
- [[i247][mutadores]]
- [[i248][mutex]]
- [[i249][exclusión mutua]]
- [[i250][función suavizada n veces]]
- [[i251][lenguaje nativo]]
- [[i252][necesitado]]
- [[i253][redes]]
- [[i254][método de Newton]]
- [[i255][nil]]
- [[i256][no computable]]
- [[i257][no estricto]]
- [[i258][no determinista]]
- [[i259][punto de elección no determinista]]
- [[i260][computación no determinista]]
- [[i261][computación no determinista <1>]]
- [[i262][normal-order]]
- [[i263][evaluación en orden normal]]
- [[i264][evaluación en orden normal <1>]]
- [[i265][obarray]]
- [[i266][programa objeto]]
- [[i267][objetos]]
- [[i268][open-code]]
- [[i269][operandos]]
- [[i270][operador]]
- [[i271][operador <1>]]
- [[i272][or-gate]]
- [[i273][orden de crecimiento]]
- [[i274][ordinario]]
- [[i275][prompt de salida]]
- [[i276][paquete]]
- [[i277][painter]]
- [[i278][par]]
- [[i279][par <1>]]
- [[i280][analizar]]
- [[i281][triángulo de Pascal]]
- [[i282][patrón]]
- [[i283][comparador de patrones]]
- [[i284][coincidencia de patrones]]
- [[i285][variable de patrón]]
- [[i286][pipelining]]
- [[i287][puntero]]
- [[i288][poly]]
- [[i289][series de potencias]]
- [[i290][predicado]]
- [[i291][predicado <1>]]
- [[i292][prefijo]]
- [[i293][código prefijo]]
- [[i294][notación de prefijo]]
- [[i295][pretty-printing]]
- [[i296][restricciones primitivas]]
- [[i297][expresiones primitivas]]
- [[i298][algoritmos probabilísticos]]
- [[i299][abstracción procedimental]]
- [[i300][epistemología procedimental]]
- [[i301][procedimiento]]
- [[i302][definiciones de procedimiento]]
- [[i303][procedimientos]]
- [[i304][proceso]]
- [[i305][programa]]
- [[i306][lenguajes de programación]]
- [[i307][prompt]]
- [[i308][pseudo-aleatorio]]
- [[i309][pseudodivisión]]
- [[i310][pseudoresto]]
- [[i311][quasiquote]]
- [[i312][consultas]]
- [[i313][lenguaje de consultas]]
- [[i314][cola]]
- [[i315][quote]]
- [[i316][números de Ramanujan]]
- [[i317][funciones racionales]]
- [[i318][circuito RC]]
- [[i319][bucle leer-evaluar-imprimir]]
- [[i320][caracteres de macro del lector]]
- [[i321][números reales]]
- [[i322][final]]
- [[i323][ecuaciones de recursión]]
- [[i324][teoría de la recursión]]
- [[i325][recursivo]]
- [[i326][recursivo <1>]]
- [[i327][proceso recursivo]]
- [[i328][árboles rojo-negro]]
- [[i329][referencialmente transparente]]
- [[i330][máquina de registros]]
- [[i331][tabla de registros]]
- [[i332][registros]]
- [[i333][liberado]]
- [[i334][resto de]]
- [[i335][principio de resolución]]
- [[i336][sumador de acarreo en cadena]]
- [[i337][robusto]]
- [[i338][algoritmo RSA]]
- [[i339][reglas]]
- [[i340][reglas <1>]]
- [[i341][satisfacer]]
- [[i342][alcance]]
- [[i343][selectores]]
- [[i344][semáforo]]
- [[i345][código separador]]
- [[i346][secuencia]]
- [[i347][acelerador de secuencia]]
- [[i348][secuencias]]
- [[i349][serializador]]
- [[i350][serializadores]]
- [[i351][circuito RLC en serie]]
- [[i352][sombrear]]
- [[i353][compartido]]
- [[i354][errores de efectos secundarios]]
- [[i355][criba de Eratóstenes]]
- [[i356][suavizado]]
- [[i357][lenguaje fuente]]
- [[i358][programa fuente]]
- [[i359][disperso]]
- [[i360][formas especiales]]
- [[i361][pila]]
- [[i362][pila <1>]]
- [[i363][variables de estado]]
- [[i364][variables de estado <1>]]
- [[i365][sentencias]]
- [[i366][stop-and-copy]]
- [[i367][diseño estratificado]]
- [[i368][procesamiento de flujos]]
- [[i369][flujos]]
- [[i370][flujos <1>]]
- [[i371][flujos <2>]]
- [[i372][estricto]]
- [[i373][subrutina]]
- [[i374][sustitución]]
- [[i375][modelo de sustitución]]
- [[i376][subtipo]]
- [[i377][continuación de éxito]]
- [[i378][suma de una serie]]
- [[i379][sumador]]
- [[i380][supertipo]]
- [[i381][expresiones simbólicas]]
- [[i382][azúcar sintáctico]]
- [[i383][sintaxis]]
- [[i384][búsqueda sistemática]]
- [[i385][sistemas]]
- [[i386][tableau]]
- [[i387][tabulación]]
- [[i388][tabulación <1>]]
- [[i389][arquitecturas etiquetadas]]
- [[i390][tail-recursive]]
- [[i391][tail-recursive <1>]]
- [[i392][objetivo]]
- [[i394][thunk]]
- [[i395][thunks]]
- [[i396][tiempo]]
- [[i397][segmentos de tiempo]]
- [[i398][torre]]
- [[i399][acumulación de árbol]]
- [[i400][recursión de árbol]]
- [[i401][árboles]]
- [[i402][mantenimiento de verdad]]
- [[i403][máquina de Turing]]
- [[i404][campo de tipo]]
- [[i405][etiqueta de tipo]]
- [[i406][etiquetas de tipo]]
- [[i407][inferencia de tipos]]
- [[i408][punteros tipados]]
- [[i409][no ligado]]
- [[i410][unificación]]
- [[i411][unificación <1>]]
- [[i412][unificación <2>]]
- [[i413][algoritmo de unificación]]
- [[i414][polinomios univariados]]
- [[i415][máquina universal]]
- [[i416][extensión compatible hacia arriba]]
- [[i417][valor]]
- [[i418][valor de una variable]]
- [[i419][valores]]
- [[i420][variable]]
- [[i421][longitud variable]]
- [[i422][vector]]
- [[i423][ancho]]
- [[i424][cables]]
- [[i425][pensamiento optimista]]
- [[i426][cruces por cero]]
