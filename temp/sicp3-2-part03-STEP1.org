*** 3.2.3 Los marcos como repositorio del estado local
:properties:
:custom_id: section-3.2.3
:end:

Podemos recurrir al modelo de entornos para ver cómo los procedimientos y la asignación se pueden usar para representar objetos con estado local. Como ejemplo, considera el "procesador de retiros" de la sección [[#section-3.1.1][3.1.1]] creado al llamar al procedimiento

#+begin_src scheme
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
#+end_src

Describamos la evaluación de

#+begin_src scheme
(define W1 (make-withdraw 100))
#+end_src

seguida por

#+begin_src scheme
(W1 50)
50
#+end_src

[[figure-3.6][Figura 3.6]] muestra el resultado de definir el procedimiento ~make-withdraw~ en el entorno global. Esto produce un objeto de procedimiento que contiene un puntero al entorno global. Hasta ahora, esto no es diferente de los ejemplos que ya hemos visto, excepto que el cuerpo del procedimiento es en sí mismo una expresión ~lambda~.

<<figure-3.6>> Resultado de definir ~make-withdraw~ en el entorno global.

#+begin_example
           +---------------------------+
 global -->| make-withdraw: --+        |
 env       +------------------|--------+
                              |      ^
                              V      |
                          .---.---.  |
                          | O | O-+--+
                          `-|-^---'
                            |
                            V
          parameters: balance
          body: (lambda (amount)
                  (if (>= balance amount)
                      (begin (set! balance
                                   (- balance amount))
                             balance)
                      "Insufficient funds"))
#+end_example

La parte interesante del cálculo sucede cuando aplicamos el procedimiento ~make-withdraw~ a un argumento:

#+begin_src scheme
(define W1 (make-withdraw 100))
#+end_src

Comenzamos, como de costumbre, configurando un entorno E1 en el que el parámetro formal ~balance~ está enlazado al argumento 100. Dentro de este entorno, evaluamos el cuerpo de ~make-withdraw~, es decir, la expresión ~lambda~. Esto construye un nuevo objeto de procedimiento, cuyo código es como se especifica por el ~lambda~ y cuyo entorno es E1, el entorno en el que se evaluó el ~lambda~ para producir el procedimiento. El objeto de procedimiento resultante es el valor devuelto por la llamada a ~make-withdraw~. Esto está enlazado a ~W1~ en el entorno global, ya que el propio ~define~ se está evaluando en el entorno global. [[figure-3.7][Figura 3.7]] muestra la estructura de entorno resultante.

<<figure-3.7>> Resultado de evaluar ~(define W1 (make-withdraw 100))~.

#+begin_example
           +-----------------------------------------------+
           | make-withdraw: -----------------------+       |
 global -->|                                       |       |
           | W1: --+                               |       |
           +-------|-------------------------------|-------+
                   |                ^              |     ^
                   |                |              V     |
                   |        +-------+------+   .---.---. |
                   |  E1 -->| balance: 100 |   | O | O-+-+
                   |        +--------------+   `-|-^---'
                   V                ^            |
               .---.---.            |            V
             +-+-O | O-+------------+    parameters: balance
             | `---^---'                 body: ...
             V
     parameters: amount
     body: (if (>= balance amount)
               (begin (set! balance (- balance amount))
                      balance)
               "Insufficient funds")
#+end_example

Ahora podemos analizar qué sucede cuando ~W1~ se aplica a un argumento:

#+begin_src scheme
(W1 50)
50
#+end_src

Comenzamos construyendo un marco en el que ~amount~, el parámetro formal de ~W1~, está enlazado al argumento 50. El punto crucial a observar es que este marco tiene como su entorno circundante no el entorno global, sino el entorno E1, porque este es el entorno que se especifica por el objeto de procedimiento ~W1~. Dentro de este nuevo entorno, evaluamos el cuerpo del procedimiento:

#+begin_src scheme
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
#+end_src

La estructura de entorno resultante se muestra en [[figure-3.8][Figura 3.8]]. La expresión que se está evaluando hace referencia tanto a ~amount~ como a ~balance~. ~amount~ se encontrará en el primer marco del entorno, mientras que ~balance~ se encontrará siguiendo el puntero del entorno circundante a E1.

<<figure-3.8>> Entornos creados al aplicar el objeto de procedimiento ~W1~.

#+begin_example
           +---------------------------------------------------+
           | make-withdraw: ...                                |
 global -->|                                                   |
 env       | W1: --+                                           |
           +-------|-------------------------------------------+
                   |               ^
                   |               |
                   |       +-------+------+ Here is the balance
                   | E1 -->| balance: 100 | that will be changed
                   |       +--------------+ by the set!.
                   V               ^   ^
               .---.---.           |   +----+
               | O | O-+-----------+        |
               `-|-^---'             +------+-----+
                 |                   | amount: 50 |
                 V                   +------------+
       parameters: amount   (if (>= balance amount)
       body: ...                (begin (set! balance
                                             (- balance amount))
                                       balance)
                                "Insufficient funds")
#+end_example

Cuando se ejecuta ~set!~, el enlace de ~balance~ en E1 se cambia. Al completarse la llamada a ~W1~, ~balance~ es 50, y el marco que contiene ~balance~ todavía está apuntado por el objeto de procedimiento ~W1~. El marco que enlaza ~amount~ (en el que ejecutamos el código que cambió ~balance~) ya no es relevante, ya que la llamada al procedimiento que lo construyó ha terminado, y no hay punteros a ese marco desde otras partes del entorno. La próxima vez que se llame a ~W1~, esto construirá un nuevo marco que enlace ~amount~ y cuyo entorno circundante sea E1. Vemos que E1 sirve como el "lugar" que contiene la variable de estado local para el objeto de procedimiento ~W1~. [[figure-3.9][Figura 3.9]] muestra la situación después de la llamada a ~W1~.

<<figure-3.9>> Entornos después de la llamada a ~W1~.

#+begin_example
            +------------------------------------+
            | make-withdraw: ...                 |
 global --->|                                    |
 env        | W1: --+                            |
            +-------|----------------------------+
                    |                   ^
                    |                   |
                    |            +------+------+
                    |     E1 --->| balance: 50 |
                    |            +-------------+
                    V                   ^
                .---.---.               |
                | O | O-+---------------+
                `-|-^---'
                  |
                  V
           parameters: amount
           body: ...
#+end_example

Observa qué sucede cuando creamos un segundo objeto "withdraw" haciendo otra llamada a ~make-withdraw~:

#+begin_src scheme
(define W2 (make-withdraw 100))
#+end_src

Esto produce la estructura de entorno de [[figure-3.10][Figura 3.10]], que muestra que ~W2~ es un objeto de procedimiento, es decir, un par con algún código y un entorno. El entorno E2 para ~W2~ fue creado por la llamada a ~make-withdraw~. Contiene un marco con su propio enlace local para ~balance~. Por otro lado, ~W1~ y ~W2~ tienen el mismo código: el código especificado por la expresión ~lambda~ en el cuerpo de ~make-withdraw~.[fn:143] Vemos aquí por qué ~W1~ y ~W2~ se comportan como objetos independientes. Las llamadas a ~W1~ hacen referencia a la variable de estado ~balance~ almacenada en E1, mientras que las llamadas a ~W2~ hacen referencia al ~balance~ almacenado en E2. Por lo tanto, los cambios en el estado local de un objeto no afectan al otro objeto.

<<figure-3.10>> Uso de ~(define W2 (make-withdraw 100))~ para crear un segundo objeto.

#+begin_example
          +-------------------------------------------------+
          | make-withdraw: ...                              |
 global ->| W2: ---------------------------+                |
 env      | W1: --+                        |                |
          +-------|------------------------|----------------+
                  |              ^         |              ^
                  |              |         |              |
                  |       +------+------+  |       +------+-------+
                  |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                  |       +-------------+  |       +--------------+
                  V              ^         V              ^
              .---.---.          |     .---.---.          |
              | O | O-+----------+     | O | O-+----------+
              `-|-^---'                `-|-^---'
                | +----------------------+
                V V
         parameters: amount
         body: ...
#+end_example

**** Ejercicio 3.10
:properties:
:custom_id: exercise-3.10
:end:

En el procedimiento ~make-withdraw~, la variable local ~balance~ se crea como un parámetro de ~make-withdraw~. También podríamos crear la variable de estado local explícitamente, usando ~let~, de la siguiente manera:

#+begin_src scheme
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
#+end_src

Recuerda de la sección [[#section-1.3.2][1.3.2]] que ~let~ es simplemente azúcar sintáctico para una llamada a procedimiento:

#+begin_src scheme
(let ((<VAR> <EXP>)) <BODY>)
#+end_src

se interpreta como una sintaxis alternativa para

#+begin_src scheme
((lambda (<VAR>) <BODY>) <EXP>)
#+end_src

Usa el modelo de entornos para analizar esta versión alternativa de ~make-withdraw~, dibujando figuras como las de arriba para ilustrar las interacciones

#+begin_src scheme
(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
#+end_src

Muestra que las dos versiones de ~make-withdraw~ crean objetos con el mismo comportamiento. ¿En qué se diferencian las estructuras de entorno para las dos versiones?

