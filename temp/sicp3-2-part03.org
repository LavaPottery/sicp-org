*** 3.2.3 Frames as the Repository of Local State
:properties:
:custom_id: section-3.2.3
:end:

We can turn to the environment model to see how procedures and assignment can be used to represent objects with local state.  As an example, consider the "withdrawal processor" from section [[#section-3.1.1][3.1.1]] created by calling the procedure

#+begin_src scheme
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
#+end_src

Let us describe the evaluation of

#+begin_src scheme
(define W1 (make-withdraw 100))
#+end_src

followed by

#+begin_src scheme
(W1 50)
50
#+end_src

[[figure-3.6][Figure 3.6]] shows the result of defining the ~make-withdraw~ procedure in the global environment.  This produces a procedure object that contains a pointer to the global environment.  So far, this is no different from the examples we have already seen, except that the body of the procedure is itself a ~lambda~ expression.

<<figure-3.6>> Result of defining ~make-withdraw~ in the global environment.

#+begin_example
           +---------------------------+
 global -->| make-withdraw: --+        |
 env       +------------------|--------+
                              |      ^
                              V      |
                          .---.---.  |
                          | O | O-+--+
                          `-|-^---'
                            |
                            V
          parameters: balance
          body: (lambda (amount)
                  (if (>= balance amount)
                      (begin (set! balance
                                   (- balance amount))
                             balance)
                      "Insufficient funds"))
#+end_example

The interesting part of the computation happens when we apply the procedure ~make-withdraw~ to an argument:

#+begin_src scheme
(define W1 (make-withdraw 100))
#+end_src

We begin, as usual, by setting up an environment E1 in which the formal parameter ~balance~ is bound to the argument 100.  Within this environment, we evaluate the body of ~make-withdraw~, namely the ~lambda~ expression.  This constructs a new procedure object, whose code is as specified by the ~lambda~ and whose environment is E1, the environment in which the ~lambda~ was evaluated to produce the procedure.  The resulting procedure object is the value returned by the call to ~make-withdraw~.  This is bound to ~W1~ in the global environment, since the ~define~ itself is being evaluated in the global environment.  [[figure-3.7][Figure 3.7]] shows the resulting environment structure.

<<figure-3.7>> Result of evaluating ~(define W1 (make-withdraw 100))~.

#+begin_example
           +-----------------------------------------------+
           | make-withdraw: -----------------------+       |
 global -->|                                       |       |
           | W1: --+                               |       |
           +-------|-------------------------------|-------+
                   |                ^              |     ^
                   |                |              V     |
                   |        +-------+------+   .---.---. |
                   |  E1 -->| balance: 100 |   | O | O-+-+
                   |        +--------------+   `-|-^---'
                   V                ^            |
               .---.---.            |            V
             +-+-O | O-+------------+    parameters: balance
             | `---^---'                 body: ...
             V
     parameters: amount
     body: (if (>= balance amount)
               (begin (set! balance (- balance amount))
                      balance)
               "Insufficient funds")
#+end_example

Now we can analyze what happens when ~W1~ is applied to an argument:

#+begin_src scheme
(W1 50)
50
#+end_src

We begin by constructing a frame in which ~amount~, the formal parameter of ~W1~, is bound to the argument 50.  The crucial point to observe is that this frame has as its enclosing environment not the global environment, but rather the environment E1, because this is the environment that is specified by the ~W1~ procedure object.  Within this new environment, we evaluate the body of the procedure:

#+begin_src scheme
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
#+end_src

The resulting environment structure is shown in [[figure-3.8][Figure 3.8]].  The expression being evaluated references both ~amount~ and ~balance~.  ~amount~ will be found in the first frame in the environment, while ~balance~ will be found by following the enclosing-environment pointer to E1.

<<figure-3.8>> Environments created by applying the procedure object ~W1~.

#+begin_example
           +---------------------------------------------------+
           | make-withdraw: ...                                |
 global -->|                                                   |
 env       | W1: --+                                           |
           +-------|-------------------------------------------+
                   |               ^
                   |               |
                   |       +-------+------+ Here is the balance
                   | E1 -->| balance: 100 | that will be changed
                   |       +--------------+ by the set!.
                   V               ^   ^
               .---.---.           |   +----+
               | O | O-+-----------+        |
               `-|-^---'             +------+-----+
                 |                   | amount: 50 |
                 V                   +------------+
       parameters: amount   (if (>= balance amount)
       body: ...                (begin (set! balance
                                             (- balance amount))
                                       balance)
                                "Insufficient funds")
#+end_example

When the ~set!~ is executed, the binding of ~balance~ in E1 is changed.  At the completion of the call to ~W1~, ~balance~ is 50, and the frame that contains ~balance~ is still pointed to by the procedure object ~W1~.  The frame that binds ~amount~ (in which we executed the code that changed ~balance~) is no longer relevant, since the procedure call that constructed it has terminated, and there are no pointers to that frame from other parts of the environment.  The next time ~W1~ is called, this will build a new frame that binds ~amount~ and whose enclosing environment is E1.  We see that E1 serves as the "place" that holds the local state variable for the procedure object ~W1~.  [[figure-3.9][Figure 3.9]] shows the situation after the call to ~W1~.

<<figure-3.9>> Environments after the call to ~W1~.

#+begin_example
            +------------------------------------+
            | make-withdraw: ...                 |
 global --->|                                    |
 env        | W1: --+                            |
            +-------|----------------------------+
                    |                   ^
                    |                   |
                    |            +------+------+
                    |     E1 --->| balance: 50 |
                    |            +-------------+
                    V                   ^
                .---.---.               |
                | O | O-+---------------+
                `-|-^---'
                  |
                  V
           parameters: amount
           body: ...
#+end_example

Observe what happens when we create a second "withdraw" object by making another call to ~make-withdraw~:

#+begin_src scheme
(define W2 (make-withdraw 100))
#+end_src

This produces the environment structure of [[figure-3.10][Figure 3.10]], which shows that ~W2~ is a procedure object, that is, a pair with some code and an environment.  The environment E2 for ~W2~ was created by the call to ~make-withdraw~.  It contains a frame with its own local binding for ~balance~.  On the other hand, ~W1~ and ~W2~ have the same code: the code specified by the ~lambda~ expression in the body of ~make-withdraw~.[fn:143] We see here why ~W1~ and ~W2~ behave as independent objects.  Calls to ~W1~ reference the state variable ~balance~ stored in E1, whereas calls to ~W2~ reference the ~balance~ stored in E2.  Thus, changes to the local state of one object do not affect the other object.

<<figure-3.10>> Using ~(define W2 (make-withdraw 100))~ to create a second object.

#+begin_example
          +-------------------------------------------------+
          | make-withdraw: ...                              |
 global ->| W2: ---------------------------+                |
 env      | W1: --+                        |                |
          +-------|------------------------|----------------+
                  |              ^         |              ^
                  |              |         |              |
                  |       +------+------+  |       +------+-------+
                  |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                  |       +-------------+  |       +--------------+
                  V              ^         V              ^
              .---.---.          |     .---.---.          |
              | O | O-+----------+     | O | O-+----------+
              `-|-^---'                `-|-^---'
                | +----------------------+
                V V
         parameters: amount
         body: ...
#+end_example

**** Exercise 3.10
:properties:
:custom_id: exercise-3.10
:end:

In the ~make-withdraw~ procedure, the local variable ~balance~ is created as a parameter of ~make-withdraw~.  We could also create the local state variable explicitly, using ~let~, as follows:

#+begin_src scheme
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
#+end_src

Recall from section [[#section-1.3.2][1.3.2]] that ~let~ is simply syntactic sugar for a procedure call:

#+begin_src scheme
(let ((<VAR> <EXP>)) <BODY>)
#+end_src

is interpreted as an alternate syntax for

#+begin_src scheme
((lambda (<VAR>) <BODY>) <EXP>)
#+end_src

Use the environment model to analyze this alternate version of ~make-withdraw~, drawing figures like the ones above to illustrate the interactions

#+begin_src scheme
(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
#+end_src

Show that the two versions of ~make-withdraw~ create objects with the same behavior.  How do the environment structures differ for the two versions?

