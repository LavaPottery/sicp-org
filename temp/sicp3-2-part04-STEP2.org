*** 3.2.4 Definiciones internas
:properties:
:custom_id: section-3.2.4
:end:

La sección [[#section-1.1.8][1.1.8]] introdujo la idea de que los procedimientos pueden tener definiciones internas, lo que lleva a una estructura de bloques como en el siguiente procedimiento para calcular raíces cuadradas:

#+begin_src scheme
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
#+end_src

Ahora podemos usar el modelo de entornos para ver por qué estas definiciones internas se comportan como se desea. [[figure-3.11][Figura 3.11]] muestra el punto en la evaluación de la expresión ~(sqrt 2)~ donde el procedimiento interno ~good-enough?~ ha sido llamado por primera vez con ~guess~ igual a 1.

<<figure-3.11>> Procedimiento ~sqrt~ con definiciones internas.

#+begin_example
           +--------------------------------------------------+
 global -->| sqrt: --+                                        |
 env       |         |                                        |
           +---------|----------------------------------------+
                     V       ^                   ^
                 .---.---.   |                   |
      +----------+-O | O-+---+        +----------+------------+
      |          `---^---'            | x: 2                  |
      V                         E1 -->| good-enough?: -+      |
 parameters: x                        | improve: ...   |      |
 body: (define good-enough? ...)      | sqrt-iter: ... |      |
       (define improve ...)           +----------------|------+
       (define sqrt-iter ...)          ^  ^            |     ^
       (sqrt-iter 1.0)                 |  |            V     |
                             +---------++ |        .---.---. |
                       E2 -->| guess: 1 | |        | O | O-+-+
                             +----------+ |        `-|-^---'
                       call to sqrt-iter  |          |
                                          |          V
                                +---------++    parameters: guess
                          E3 -->| guess: 1 |    body: (< (abs ...)
                                +----------+             ...)
                          call to good-enough?
#+end_example

Observa la estructura del entorno. ~sqrt~ es un símbolo en el entorno global que está enlazado a un objeto de procedimiento cuyo entorno asociado es el entorno global. Cuando se llamó a ~sqrt~, se formó un nuevo entorno E1, subordinado al entorno global, en el que el parámetro ~x~ está enlazado a 2. El cuerpo de ~sqrt~ fue entonces evaluado en E1. Dado que la primera expresión en el cuerpo de ~sqrt~ es

#+begin_src scheme
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
#+end_src

evaluar esta expresión definió el procedimiento ~good-enough?~ en el entorno E1. Para ser más precisos, el símbolo ~good-enough?~ fue agregado al primer marco de E1, enlazado a un objeto de procedimiento cuyo entorno asociado es E1. De manera similar, ~improve~ y ~sqrt-iter~ fueron definidos como procedimientos en E1. Por concisión, [[figure-3.11][Figura 3.11]] muestra sólo el objeto de procedimiento para ~good-enough?~.

Después de que se definieron los procedimientos locales, la expresión ~(sqrt-iter 1.0)~ fue evaluada, todavía en el entorno E1. Entonces el objeto de procedimiento enlazado a ~sqrt-iter~ en E1 fue llamado con 1 como argumento. Esto creó un entorno E2 en el que ~guess~, el parámetro de ~sqrt-iter~, está enlazado a 1. ~sqrt-iter~ a su vez llamó a ~good-enough?~ con el valor de ~guess~ (de E2) como argumento para ~good-enough?~. Esto estableció otro entorno, E3, en el que ~guess~ (el parámetro de ~good-enough?~) está enlazado a 1. Aunque ~sqrt-iter~ y ~good-enough?~ ambos tienen un parámetro llamado ~guess~, estas son dos variables locales distintas ubicadas en marcos diferentes. Además, E2 y E3 ambos tienen E1 como su entorno circundante, porque los procedimientos ~sqrt-iter~ y ~good-enough?~ ambos tienen E1 como su parte del entorno. Una consecuencia de esto es que el símbolo ~x~ que aparece en el cuerpo de ~good-enough?~ hará referencia al enlace de ~x~ que aparece en E1, es decir, el valor de ~x~ con el que se llamó el procedimiento original ~sqrt~.

El modelo de entornos explica así las dos propiedades clave que hacen que las definiciones de procedimientos locales sean una técnica útil para modularizar programas:

- Los nombres de los procedimientos locales no interfieren con nombres externos al procedimiento envolvente, porque los nombres de los procedimientos locales estarán enlazados en el marco que el procedimiento crea cuando se ejecuta, en lugar de estar enlazados en el entorno global.

- Los procedimientos locales pueden acceder a los argumentos del procedimiento envolvente, simplemente usando nombres de parámetros como variables libres. Esto es porque el cuerpo del procedimiento local se evalúa en un entorno que es subordinado al entorno de evaluación del procedimiento envolvente.

**** Ejercicio 3.11
:properties:
:custom_id: exercise-3.11
:end:

En la sección [[#section-3.2.3][3.2.3]] vimos cómo el modelo de entornos describía el comportamiento de procedimientos con estado local. Ahora hemos visto cómo funcionan las definiciones internas. Un procedimiento típico de paso de mensajes contiene ambos aspectos. Considera el procedimiento de cuenta bancaria de la sección [[#section-3.1.1][3.1.1]]:

#+begin_src scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request - MAKE-ACCOUNT"
                       m))))
  dispatch)
#+end_src

Muestra la estructura de entorno generada por la secuencia de interacciones

#+begin_src scheme
(define acc (make-account 50))

((acc 'deposit) 40)
90

((acc 'withdraw) 60)
30
#+end_src

¿Dónde se mantiene el estado local para ~acc~? Supón que definimos otra cuenta

#+begin_src scheme
(define acc2 (make-account 100))
#+end_src

¿Cómo se mantienen distintos los estados locales para las dos cuentas? ¿Qué partes de la estructura de entorno se comparten entre ~acc~ y ~acc2~?
