*** 3.2.4 Internal Definitions
:properties:
:custom_id: section-3.2.4
:end:

Section [[#section-1.1.8][1.1.8]] introduced the idea that procedures can have internal definitions, thus leading to a block structure as in the following procedure to compute square roots:

#+begin_src scheme
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
#+end_src

Now we can use the environment model to see why these internal definitions behave as desired.  [[figure-3.11][Figure 3.11]] shows the point in the evaluation of the expression ~(sqrt 2)~ where the internal procedure ~good-enough?~ has been called for the first time with ~guess~ equal to 1.

<<figure-3.11>> ~sqrt~ procedure with internal definitions.

#+begin_example
           +--------------------------------------------------+
 global -->| sqrt: --+                                        |
 env       |         |                                        |
           +---------|----------------------------------------+
                     V       ^                   ^
                 .---.---.   |                   |
      +----------+-O | O-+---+        +----------+------------+
      |          `---^---'            | x: 2                  |
      V                         E1 -->| good-enough?: -+      |
 parameters: x                        | improve: ...   |      |
 body: (define good-enough? ...)      | sqrt-iter: ... |      |
       (define improve ...)           +----------------|------+
       (define sqrt-iter ...)          ^  ^            |     ^
       (sqrt-iter 1.0)                 |  |            V     |
                             +---------++ |        .---.---. |
                       E2 -->| guess: 1 | |        | O | O-+-+
                             +----------+ |        `-|-^---'
                       call to sqrt-iter  |          |
                                          |          V
                                +---------++    parameters: guess
                          E3 -->| guess: 1 |    body: (< (abs ...)
                                +----------+             ...)
                          call to good-enough?
#+end_example

Observe the structure of the environment.  ~sqrt~ is a symbol in the global environment that is bound to a procedure object whose associated environment is the global environment.  When ~sqrt~ was called, a new environment E1 was formed, subordinate to the global environment, in which the parameter ~x~ is bound to 2.  The body of ~sqrt~ was then evaluated in E1.  Since the first expression in the body of ~sqrt~ is

#+begin_src scheme
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
#+end_src

evaluating this expression defined the procedure ~good-enough?~ in the environment E1.  To be more precise, the symbol ~good-enough?~ was added to the first frame of E1, bound to a procedure object whose associated environment is E1.  Similarly, ~improve~ and ~sqrt-iter~ were defined as procedures in E1.  For conciseness, [[figure-3.11][Figure 3.11]] shows only the procedure object for ~good-enough?~.

After the local procedures were defined, the expression ~(sqrt-iter 1.0)~ was evaluated, still in environment E1.  So the procedure object bound to ~sqrt-iter~ in E1 was called with 1 as an argument.  This created an environment E2 in which ~guess~, the parameter of ~sqrt-iter~, is bound to 1.  ~sqrt-iter~ in turn called ~good-enough?~ with the value of ~guess~ (from E2) as the argument for ~good-enough?~.  This set up another environment, E3, in which ~guess~ (the parameter of ~good-enough?~) is bound to 1.  Although ~sqrt-iter~ and ~good-enough?~ both have a parameter named ~guess~, these are two distinct local variables located in different frames.  Also, E2 and E3 both have E1 as their enclosing environment, because the ~sqrt-iter~ and ~good-enough?~ procedures both have E1 as their environment part.  One consequence of this is that the symbol ~x~ that appears in the body of ~good-enough?~ will reference the binding of ~x~ that appears in E1, namely the value of ~x~ with which the original ~sqrt~ procedure was called.

The environment model thus explains the two key properties that make local procedure definitions a useful technique for modularizing programs:

- The names of the local procedures do not interfere with names external to the enclosing procedure, because the local procedure names will be bound in the frame that the procedure creates when it is run, rather than being bound in the global environment.

- The local procedures can access the arguments of the enclosing procedure, simply by using parameter names as free variables.  This is because the body of the local procedure is evaluated in an environment that is subordinate to the evaluation environment for the enclosing procedure.

**** Exercise 3.11
:properties:
:custom_id: exercise-3.11
:end:

In section [[#section-3.2.3][3.2.3]] we saw how the environment model described the behavior of procedures with local state.  Now we have seen how internal definitions work.  A typical message-passing procedure contains both of these aspects.  Consider the bank account procedure of section [[#section-3.1.1][3.1.1]]:

#+begin_src scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request - MAKE-ACCOUNT"
                       m))))
  dispatch)
#+end_src

Show the environment structure generated by the sequence of interactions

#+begin_src scheme
(define acc (make-account 50))

((acc 'deposit) 40)
90

((acc 'withdraw) 60)
30
#+end_src

Where is the local state for ~acc~ kept?  Suppose we define another account

#+begin_src scheme
(define acc2 (make-account 100))
#+end_src

How are the local states for the two accounts kept distinct?  Which parts of the environment structure are shared between ~acc~ and ~acc2~?
