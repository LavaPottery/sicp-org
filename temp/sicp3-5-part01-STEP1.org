** 3.5 Flujos
:properties:
:custom_id: section-3.5
:end:

Hemos adquirido una buena comprensión de la asignación como herramienta de modelado, así como una apreciación de los problemas complejos que la asignación plantea. Ha llegado el momento de preguntarnos si podríamos haber abordado las cosas de otra manera, para evitar algunos de estos problemas. En esta sección, exploramos un enfoque alternativo para modelar el estado, basado en estructuras de datos llamadas <<i370>> flujos. Como veremos, los flujos pueden mitigar parte de la complejidad del modelado del estado.

Demos un paso atrás y revisemos de dónde proviene esta complejidad. En un intento de modelar fenómenos del mundo real, tomamos algunas decisiones aparentemente razonables: Modelamos objetos del mundo real con estado local mediante objetos computacionales con variables locales. Identificamos la variación temporal en el mundo real con la variación temporal en el ordenador. Implementamos la variación temporal de los estados de los objetos modelo en el ordenador con asignaciones a las variables locales de los objetos modelo.

¿Existe otro enfoque? ¿Podemos evitar identificar el tiempo en el ordenador con el tiempo en el mundo modelado? ¿Debemos hacer que el modelo cambie con el tiempo para modelar fenómenos en un mundo cambiante? Pensemos en el problema en términos de funciones matemáticas. Podemos describir el comportamiento variable en el tiempo de una cantidad x como una función del tiempo x(t). Si nos concentramos en x instante por instante, pensamos en ella como una cantidad cambiante. Sin embargo, si nos concentramos en toda la historia temporal de valores, no enfatizamos el cambio; la función en sí misma no cambia.[fn:180]

Si el tiempo se mide en pasos discretos, entonces podemos modelar una función temporal como una secuencia (posiblemente infinita). En esta sección, veremos cómo modelar el cambio en términos de secuencias que representan las historias temporales de los sistemas que se están modelando. Para lograr esto, introducimos nuevas estructuras de datos llamadas <<i371>> flujos. Desde un punto de vista abstracto, un flujo es simplemente una secuencia. Sin embargo, descubriremos que la implementación directa de flujos como listas (como en la sección [[#section-2.2.1][2.2.1]]) no revela completamente el poder del procesamiento de flujos. Como alternativa, introducimos la técnica de <<i106>> evaluación diferida, que nos permite representar secuencias muy grandes (incluso infinitas) como flujos.

El procesamiento de flujos nos permite modelar sistemas que tienen estado sin usar nunca asignación o datos mutables. Esto tiene implicaciones importantes, tanto teóricas como prácticas, porque podemos construir modelos que evitan los inconvenientes inherentes a la introducción de la asignación. Por otro lado, el marco de flujos plantea dificultades propias, y la cuestión de qué técnica de modelado conduce a sistemas más modulares y fáciles de mantener permanece abierta.

*** 3.5.1 Los flujos son listas diferidas
:properties:
:custom_id: section-3.5.1
:end:

Como vimos en la sección [[#section-2.2.3][2.2.3]], las secuencias pueden servir como interfaces estándar para combinar módulos de programa. Formulamos abstracciones poderosas para manipular secuencias, como ~map~, ~filter~ y ~accumulate~, que capturan una amplia variedad de operaciones de manera sucinta y elegante.

Desafortunadamente, si representamos secuencias como listas, esta elegancia se compra al precio de una severa ineficiencia con respecto tanto al tiempo como al espacio requeridos por nuestros cálculos. Cuando representamos manipulaciones sobre secuencias como transformaciones de listas, nuestros programas deben construir y copiar estructuras de datos (que pueden ser enormes) en cada paso de un proceso.

Para ver por qué esto es cierto, comparemos dos programas para calcular la suma de todos los números primos en un intervalo. El primer programa está escrito en estilo iterativo estándar:[fn:181]

#+begin_src scheme
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
#+end_src

El segundo programa realiza el mismo cálculo usando las operaciones de secuencia de la sección [[#section-2.2.3][2.2.3]]:

#+begin_src scheme
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
#+end_src

Al realizar el cálculo, el primer programa solo necesita almacenar la suma que se está acumulando. En contraste, el filtro en el segundo programa no puede hacer ninguna prueba hasta que ~enumerate-interval~ haya construido una lista completa de los números en el intervalo. El filtro genera otra lista, que a su vez se pasa a ~accumulate~ antes de colapsarse para formar una suma. Un almacenamiento intermedio tan grande no es necesario para el primer programa, que podemos pensar como enumerando el intervalo de manera incremental, añadiendo cada primo a la suma a medida que se genera.

La ineficiencia en el uso de listas se hace dolorosamente evidente si usamos el paradigma de secuencias para calcular el segundo primo en el intervalo de 10.000 a 1.000.000 evaluando la expresión

#+begin_src scheme
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
#+end_src

Esta expresión encuentra el segundo primo, pero la sobrecarga computacional es escandalosa. Construimos una lista de casi un millón de enteros, filtramos esta lista probando la primalidad de cada elemento, y luego ignoramos casi todo el resultado. En un estilo de programación más tradicional, intercalaríamos la enumeración y el filtrado, y nos detendríamos cuando alcanzáramos el segundo primo.

Los flujos son una idea inteligente que permite usar manipulaciones de secuencias sin incurrir en los costos de manipular secuencias como listas. Con los flujos podemos lograr lo mejor de ambos mundos: Podemos formular programas elegantemente como manipulaciones de secuencias, mientras alcanzamos la eficiencia del cálculo incremental. La idea básica es disponer construir un flujo solo parcialmente, y pasar la construcción parcial al programa que consume el flujo. Si el consumidor intenta acceder a una parte del flujo que aún no se ha construido, el flujo construirá automáticamente lo suficiente de sí mismo para producir la parte requerida, preservando así la ilusión de que todo el flujo existe. En otras palabras, aunque escribiremos programas como si estuviéramos procesando secuencias completas, diseñamos nuestra implementación de flujos para intercalar automática y transparentemente la construcción del flujo con su uso.

En la superficie, los flujos son solo listas con nombres diferentes para los procedimientos que los manipulan. Hay un constructor, ~cons-stream~, y dos selectores, ~stream-car~ y ~stream-cdr~, que satisfacen las restricciones

#+begin_example
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
#+end_example

Hay un objeto distinguible, ~the-empty-stream~, que no puede ser el resultado de ninguna operación ~cons-stream~, y que puede identificarse con el predicado ~stream-null?~.[fn:182] Así podemos hacer y usar flujos, de la misma manera que podemos hacer y usar listas, para representar datos agregados dispuestos en una secuencia. En particular, podemos construir análogos de flujo de las operaciones de lista del [[#section-2][Capítulo 2]], tales como ~list-ref~, ~map~ y ~for-each~:[fn:183]

#+begin_src scheme
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
#+end_src

~stream-for-each~ es útil para visualizar flujos:

#+begin_src scheme
(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))
#+end_src

Para hacer que la implementación de flujos intercale automática y transparentemente la construcción de un flujo con su uso, dispondremos que el ~cdr~ de un flujo se evalúe cuando se accede a él mediante el procedimiento ~stream-cdr~ en lugar de cuando se construye el flujo mediante ~cons-stream~. Esta elección de implementación recuerda nuestra discusión de números racionales en la sección [[#section-2.1.2][2.1.2]], donde vimos que podemos elegir implementar números racionales de manera que la reducción del numerador y denominador a términos mínimos se realice ya sea en el momento de la construcción o en el momento de la selección. Las dos implementaciones de números racionales producen la misma abstracción de datos, pero la elección tiene un efecto en la eficiencia. Hay una relación similar entre flujos y listas ordinarias. Como abstracción de datos, los flujos son lo mismo que las listas. La diferencia está en el momento en que se evalúan los elementos. Con listas ordinarias, tanto el ~car~ como el ~cdr~ se evalúan en el momento de la construcción. Con flujos, el ~cdr~ se evalúa en el momento de la selección.

Nuestra implementación de flujos se basará en una forma especial llamada ~delay~. Evaluar '(delay <EXP>)' no evalúa la expresión <EXP>, sino que devuelve un llamado <<i107>> objeto diferido, que podemos pensar como una "promesa" de evaluar <EXP> en algún momento futuro. Como compañero de ~delay~, hay un procedimiento llamado ~force~ que toma un objeto diferido como argumento y realiza la evaluación; en efecto, forzando a ~delay~ a cumplir su promesa. Veremos más adelante cómo se pueden implementar ~delay~ y ~force~, pero primero usemos estos para construir flujos.

~cons-stream~ es una forma especial definida de manera que

#+begin_src scheme
(cons-stream <A> <B>)
#+end_src

es equivalente a

#+begin_src scheme
(cons <A> (delay <B>))
#+end_src

Lo que esto significa es que construiremos flujos usando pares. Sin embargo, en lugar de colocar el valor del resto del flujo en el ~cdr~ del par, pondremos allí una promesa de calcular el resto si alguna vez se solicita. ~stream-car~ y ~stream-cdr~ ahora pueden definirse como procedimientos:

#+begin_src scheme
(define (stream-car stream) (car stream))

(define (stream-cdr stream) (force (cdr stream)))
#+end_src

~stream-car~ selecciona el ~car~ del par; ~stream-cdr~ selecciona el ~cdr~ del par y evalúa la expresión diferida encontrada allí para obtener el resto del flujo.[fn:184]

*La implementación de flujos en acción*

Para ver cómo se comporta esta implementación, analicemos el cálculo de primos "escandaloso" que vimos anteriormente, reformulado en términos de flujos:

#+begin_src scheme
(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
#+end_src

Veremos que efectivamente funciona eficientemente.

Comenzamos llamando a ~stream-enumerate-interval~ con los argumentos 10.000 y 1.000.000. ~stream-enumerate-interval~ es el análogo de flujo de ~enumerate-interval~ (sección [[#section-2.2.3][2.2.3]]):

#+begin_src scheme
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
#+end_src

y por lo tanto el resultado devuelto por ~stream-enumerate-interval~, formado por ~cons-stream~, es[fn:185]

#+begin_src scheme
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
#+end_src

Es decir, ~stream-enumerate-interval~ devuelve un flujo representado como un par cuyo ~car~ es 10.000 y cuyo ~cdr~ es una promesa de enumerar más del intervalo si se solicita. Este flujo ahora se filtra para primos, usando el análogo de flujo del procedimiento ~filter~ (sección [[#section-2.2.3][2.2.3]]):

#+begin_src scheme
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
#+end_src

~stream-filter~ prueba el ~stream-car~ del flujo (el ~car~ del par, que es 10.000). Dado que este no es primo, ~stream-filter~ examina el ~stream-cdr~ de su flujo de entrada. La llamada a ~stream-cdr~ fuerza la evaluación del ~stream-enumerate-interval~ diferido, que ahora devuelve

#+begin_src scheme
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
#+end_src

~stream-filter~ ahora observa el ~stream-car~ de este flujo, 10.001, ve que esto tampoco es primo, fuerza otro ~stream-cdr~, y así sucesivamente, hasta que ~stream-enumerate-interval~ produce el primo 10.007, momento en el cual ~stream-filter~, de acuerdo con su definición, devuelve

#+begin_src scheme
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
#+end_src

que en este caso es

#+begin_src scheme
(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 10009
                                            1000000))))))
#+end_src

Este resultado ahora se pasa a ~stream-cdr~ en nuestra expresión original. Esto fuerza el ~stream-filter~ diferido, que a su vez sigue forzando el ~stream-enumerate-interval~ diferido hasta que encuentra el siguiente primo, que es 10.009. Finalmente, el resultado pasado a ~stream-car~ en nuestra expresión original es

#+begin_src scheme
(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 10011
                                            1000000))))))
#+end_src

~stream-car~ devuelve 10.009, y el cálculo está completo. Solo se probaron tantos enteros para primalidad como fueron necesarios para encontrar el segundo primo, y el intervalo se enumeró solo hasta donde fue necesario para alimentar el filtro de primos.

En general, podemos pensar en la evaluación diferida como programación "conducida por la demanda", mediante la cual cada etapa en el proceso de flujo se activa solo lo suficiente para satisfacer la siguiente etapa. Lo que hemos hecho es desacoplar el orden real de eventos en el cálculo de la estructura aparente de nuestros procedimientos. Escribimos procedimientos como si los flujos existieran "todos a la vez" cuando, en realidad, el cálculo se realiza de manera incremental, como en los estilos de programación tradicionales.

*Implementando ~delay~ y ~force~*

Aunque ~delay~ y ~force~ pueden parecer operaciones misteriosas, su implementación es realmente bastante directa. ~delay~ debe empaquetar una expresión para que pueda evaluarse más tarde bajo demanda, y podemos lograr esto simplemente tratando la expresión como el cuerpo de un procedimiento. ~delay~ puede ser una forma especial tal que

#+begin_src scheme
(delay <EXP>)
#+end_src

es azúcar sintáctico para

#+begin_src scheme
(lambda () <EXP>)
#+end_src

~force~ simplemente llama al procedimiento (sin argumentos) producido por ~delay~, así que podemos implementar ~force~ como un procedimiento:

#+begin_src scheme
(define (force delayed-object)
  (delayed-object))
#+end_src

Esta implementación es suficiente para que ~delay~ y ~force~ funcionen como se anuncia, pero hay una optimización importante que podemos incluir. En muchas aplicaciones, terminamos forzando el mismo objeto diferido muchas veces. Esto puede llevar a una ineficiencia seria en programas recursivos que involucran flujos. (Ver [[#exercise-3.57][Ejercicio 3.57]].) La solución es construir objetos diferidos de manera que la primera vez que se fuerzan, almacenen el valor que se calcula. Los forzados subsiguientes simplemente devolverán el valor almacenado sin repetir el cálculo. En otras palabras, implementamos ~delay~ como un procedimiento memoizado de propósito especial similar al descrito en [[#exercise-3.27][Ejercicio 3.27]]. Una forma de lograr esto es usar el siguiente procedimiento, que toma como argumento un procedimiento (sin argumentos) y devuelve una versión memoizada del procedimiento. La primera vez que se ejecuta el procedimiento memoizado, guarda el resultado calculado. En evaluaciones posteriores, simplemente devuelve el resultado.

#+begin_src scheme
(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
#+end_src

~delay~ se define entonces de manera que ~(delay <EXP>)~ es equivalente a

#+begin_src scheme
(memo-proc (lambda () <EXP>))
#+end_src

y ~force~ se define como antes.[fn:186]

**** Ejercicio 3.50
:properties:
:custom_id: exercise-3.50
:end:

Completa la siguiente definición, que generaliza ~stream-map~ para permitir procedimientos que toman múltiples argumentos, análogo a ~map~ en la sección [[#section-2.2.3][2.2.3]], nota al pie [fn:12].

#+begin_src scheme
(define (stream-map proc . argstreams)
  (if (<??> (car argstreams))
      the-empty-stream
      (<??>
       (apply proc (map <??> argstreams))
       (apply stream-map
              (cons proc (map <??> argstreams))))))
#+end_src

**** Ejercicio 3.51
:properties:
:custom_id: exercise-3.51
:end:

Para observar más de cerca la evaluación diferida, usaremos el siguiente procedimiento, que simplemente devuelve su argumento después de imprimirlo:

#+begin_src scheme
(define (show x)
  (display-line x)
  x)
#+end_src

¿Qué imprime el intérprete en respuesta a evaluar cada expresión en la siguiente secuencia?[fn:187]

#+begin_src scheme
(define x (stream-map show (stream-enumerate-interval 0 10)))

(stream-ref x 5)

(stream-ref x 7)
#+end_src

**** Ejercicio 3.52
:properties:
:custom_id: exercise-3.52
:end:

Considera la secuencia de expresiones

#+begin_src scheme
(define sum 0)

(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))

(stream-ref y 7)

(display-stream z)
#+end_src

¿Cuál es el valor de ~sum~ después de evaluar cada una de las expresiones anteriores? ¿Cuál es la respuesta impresa al evaluar las expresiones ~stream-ref~ y ~display-stream~? ¿Diferirían estas respuestas si hubiéramos implementado '(delay <EXP>)' simplemente como '(lambda () <EXP>)' sin usar la optimización proporcionada por ~memo-proc~? Explica

