*** 3.5.4 Flujos y evaluación diferida
:properties:
:custom_id: section-3.5.4
:end:

El procedimiento ~integral~ al final de la sección anterior muestra cómo podemos usar flujos para modelar sistemas de procesamiento de señales que contienen bucles de realimentación. El bucle de realimentación para el sumador mostrado en la [[figure-3.32][Figura 3.32]] se modela por el hecho de que el flujo interno ~int~ de ~integral~ se define en términos de sí mismo:

#+begin_src scheme
(define int
  (cons-stream initial-value
               (add-streams (scale-stream integrand dt)
                            int)))
#+end_src

La capacidad del intérprete para lidiar con tal definición implícita depende del ~delay~ que está incorporado en ~cons-stream~. Sin este ~delay~, el intérprete no podría construir ~int~ antes de evaluar ambos argumentos de ~cons-stream~, lo que requeriría que ~int~ ya estuviera definido. En general, ~delay~ es crucial para usar flujos para modelar sistemas de procesamiento de señales que contienen bucles. Sin ~delay~, nuestros modelos tendrían que formularse de manera que las entradas a cualquier componente de procesamiento de señales se evaluaran completamente antes de que se pudiera producir la salida. Esto prohibiría los bucles.

Desafortunadamente, los modelos de flujo de sistemas con bucles pueden requerir usos de ~delay~ más allá del ~delay~ "oculto" proporcionado por ~cons-stream~. Por ejemplo, la [[figure-3.34][Figura 3.34]] muestra un sistema de procesamiento de señales para resolver la ecuación diferencial dy/dt = f(y) donde f es una función dada. La figura muestra un componente de mapeo, que aplica f a su señal de entrada, vinculado en un bucle de realimentación a un integrador de una manera muy similar a la de los circuitos de ordenador analógico que realmente se usan para resolver tales ecuaciones.

<<figure-3.34>> Un "circuito de ordenador analógico" que resuelve la ecuación dy/dt = f(y).

#+begin_example
                             y_0
                              |
                              V
     +----------+  dy   +----------+     y
 +-->|  map: f  +------>| integral +--*----->
 |   +----------+       +----------+  |
 |                                    |
 +------------------------------------+
#+end_example

Suponiendo que nos dan un valor inicial y_0 para y, podríamos intentar modelar este sistema usando el procedimiento

#+begin_src scheme
(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
#+end_src

Este procedimiento no funciona, porque en la primera línea de ~solve~ la llamada a ~integral~ requiere que la entrada ~dy~ esté definida, lo cual no sucede hasta la segunda línea de ~solve~.

Por otro lado, la intención de nuestra definición tiene sentido, porque podemos, en principio, comenzar a generar el flujo ~y~ sin conocer ~dy~. De hecho, ~integral~ y muchas otras operaciones de flujo tienen propiedades similares a las de ~cons-stream~, en que podemos generar parte de la respuesta dada solo información parcial sobre los argumentos. Para ~integral~, el primer elemento del flujo de salida es el ~initial-value~ especificado. Por lo tanto, podemos generar el primer elemento del flujo de salida sin evaluar el integrando ~dy~. Una vez que conocemos el primer elemento de ~y~, el ~stream-map~ en la segunda línea de ~solve~ puede comenzar a trabajar para generar el primer elemento de ~dy~, que producirá el siguiente elemento de ~y~, y así sucesivamente.

Para aprovechar esta idea, redefiniremos ~integral~ para esperar que el flujo integrando sea un <<i104>> argumento diferido. ~integral~ forzará (~force~) la evaluación del integrando solo cuando sea necesario para generar más que el primer elemento del flujo de salida:

#+begin_src scheme
(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (let ((integrand (force delayed-integrand)))
                   (add-streams (scale-stream integrand dt)
                                int))))
  int)
#+end_src

Ahora podemos implementar nuestro procedimiento ~solve~ retrasando la evaluación de ~dy~ en la definición de ~y~:[fn:199]

#+begin_src scheme
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
#+end_src

En general, cada llamador de ~integral~ ahora debe diferir (~delay~) el argumento integrando. Podemos demostrar que el procedimiento ~solve~ funciona aproximando e ≈ 2.718 calculando el valor en y = 1 de la solución a la ecuación diferencial dy/dt = y con condición inicial y(0) = 1:

#+begin_src scheme
(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
2.716924
#+end_src

**** Ejercicio 3.77
:properties:
:custom_id: exercise-3.77
:end:

El procedimiento ~integral~ usado anteriormente era análogo a la definición "implícita" del flujo infinito de enteros en la sección [[#section-3.5.2][3.5.2]]. Alternativamente, podemos dar una definición de ~integral~ que sea más parecida a ~integers-starting-from~ (también en la sección [[#section-3.5.2][3.5.2]]):

#+begin_src scheme
(define (integral integrand initial-value dt)
  (cons-stream initial-value
               (if (stream-null? integrand)
                   the-empty-stream
                   (integral (stream-cdr integrand)
                             (+ (* dt (stream-car integrand))
                                initial-value)
                             dt))))
#+end_src

Cuando se usa en sistemas con bucles, este procedimiento tiene el mismo problema que nuestra versión original de ~integral~. Modifica el procedimiento para que espere el ~integrand~ como un argumento diferido y por lo tanto pueda usarse en el procedimiento ~solve~ mostrado anteriormente.

<<figure-3.35>> Diagrama de flujo de señal para la solución de una ecuación diferencial lineal de segundo orden.

#+begin_example
                dy_0                y_0
                 |                   |
                 V                   V
    ddy     +----------+    dy  +----------+    y
 +--------->| integral +-----*--+ integral +--*--->
 |          +----------+     |  +----------+  |
 |                           |                |
 |            +----------+   |                |
 |     __/|<--+ scale: a |<--+                |
 |   _/   |   +----------+                    |
 +--<_add |                                   |
      \__ |   +----------+                    |
         \|<--+ scale: b |<-------------------+
              +----------+
#+end_example

**** Ejercicio 3.78
:properties:
:custom_id: exercise-3.78
:end:

Considera el problema de diseñar un sistema de procesamiento de señales para estudiar la ecuación diferencial lineal homogénea de segundo orden

#+begin_example
 d^2 y        d y
 -----  -  a -----  -  by  =  0
 d t^2        d t
#+end_example

El flujo de salida, que modela y, es generado por una red que contiene un bucle. Esto es porque el valor de d^2y/dt^2 depende de los valores de y y dy/dt y ambos se determinan integrando d^2y/dt^2. El diagrama que nos gustaría codificar se muestra en la [[figure-3.35][Figura 3.35]]. Escribe un procedimiento ~solve-2nd~ que tome como argumentos las constantes a, b y dt y los valores iniciales y_0 y dy_0 para y y dy/dt y genere el flujo de valores sucesivos de y.

**** Ejercicio 3.79
:properties:
:custom_id: exercise-3.79
:end:

Generaliza el procedimiento ~solve-2nd~ del [[#exercise-3.78][Ejercicio 3.78]] para que pueda usarse para resolver ecuaciones diferenciales generales de segundo orden d^2 y/dt^2 = f(dy/dt, y).

**** Ejercicio 3.80
:properties:
:custom_id: exercise-3.80
:end:

Un <<i351>> circuito RLC en serie consiste en un resistor, un capacitor y un inductor conectados en serie, como se muestra en la [[figure-3.36][Figura 3.36]]. Si R, L y C son la resistencia, inductancia y capacitancia, entonces las relaciones entre voltaje (v) y corriente (i) para los tres componentes se describen mediante las ecuaciones

#+begin_example
 v_R = i_R R

          d_(i L)
 v_L = L ---------
            d t

          d v_C
 i_C = C -------
           d t
#+end_example

y las conexiones del circuito dictan las relaciones

#+begin_example
 i_R = i_L = -i_C

 v_C = v_L + v_R
#+end_example

Combinar estas ecuaciones muestra que el estado del circuito (resumido por v_C, el voltaje a través del capacitor, e i_L, la corriente en el inductor) se describe mediante el par de ecuaciones diferenciales

#+begin_example
 d v_C        i_L
 -----  =  -  ---
  d t          C

 d i_L      1           R
 -----  =  --- v_C  -  --- i_L
  d t       L           L
#+end_example

El diagrama de flujo de señal que representa este sistema de ecuaciones diferenciales se muestra en la [[figure-3.37][Figura 3.37]].

<<figure-3.36>> Un circuito RLC en serie.

#+begin_example
               + v_R -
         i_R
      +--->----'\/\/\,--------+
      |                       |  i_L
     \|/          R          \|/
   +  |  i_C                  |_   +
     -+-                      __)
 v_C -+- C                   (_)   v_L
      |                       __)
   -  |                       |    -
      +-----------------------+
#+end_example

<<figure-3.37>> Un diagrama de flujo de señal para la solución de un circuito RLC en serie.

#+begin_example
                  +-------------+
 +----------------+  scale: l/L |<--+
 |                +-------------+   |
 |                                  |
 |                +-------------+   |  v_C
 |       dv_C +-->|   integral  +---*------>
 |            |   +-------------+
 |            |        ^
 |            |        | v_(C_0)
 |            |
 |            |   +-------------+
 |            +---+ scale: -l/C |<--+
 |                +-------------+   |
 |  |\__                            |
 +->|   \_  di_L  +-------------+   |  i_L
    | add_>------>|   integral  +---*------>
 +->| __/         +-------------+   |
 |  |/                 ^            |
 |                     | i_(L_0)    |
 |                                  |
 |                +-------------+   |
 +----------------+ scale: -R/L |<--+
                  +-------------+
#+end_example

Escribe un procedimiento ~RLC~ que tome como argumentos los parámetros R, L y C del circuito y el incremento de tiempo dt. De manera similar a la del procedimiento ~RC~ del [[#exercise-3.73][Ejercicio 3.73]], ~RLC~ debe producir un procedimiento que tome los valores iniciales de las variables de estado, v_(C_0) e i_(L_0), y produzca un par (usando ~cons~) de los flujos de estados v_C e i_L. Usando ~RLC~, genera el par de flujos que modela el comportamiento de un circuito RLC en serie con R = 1 ohmio, C = 0.2 faradios, L = 1 henrio, dt = 0.1 segundos, y valores iniciales i_(L_0) = 0 amperios y v_(C_0) = 10 voltios.

*Evaluación en orden normal*

Los ejemplos en esta sección ilustran cómo el uso explícito de ~delay~ y ~force~ proporciona gran flexibilidad de programación, pero los mismos ejemplos también muestran cómo esto puede hacer nuestros programas más complejos. Nuestro nuevo procedimiento ~integral~, por ejemplo, nos da el poder de modelar sistemas con bucles, pero ahora debemos recordar que ~integral~ debe llamarse con un integrando diferido, y cada procedimiento que use ~integral~ debe ser consciente de esto. En efecto, hemos creado dos clases de procedimientos: procedimientos ordinarios y procedimientos que toman argumentos diferidos. En general, crear clases separadas de procedimientos nos obliga a crear clases separadas de procedimientos de orden superior también.[fn:200]

Una forma de evitar la necesidad de dos clases diferentes de procedimientos es hacer que todos los procedimientos tomen argumentos diferidos. Podríamos adoptar un modelo de evaluación en el que todos los argumentos a los procedimientos se retrasen automáticamente y los argumentos se fuercen solo cuando realmente se necesiten (por ejemplo, cuando sean requeridos por una operación primitiva). Esto transformaría nuestro lenguaje para usar evaluación en orden normal, que describimos por primera vez cuando introdujimos el modelo de sustitución para evaluación en la sección [[#section-1.1.5][1.1.5]]. La conversión a evaluación en orden normal proporciona una forma uniforme y elegante de simplificar el uso de la evaluación diferida, y esta sería una estrategia natural a adoptar si solo nos preocupáramos por el procesamiento de flujos. En la sección [[#section-4.2][4.2]], después de que hayamos estudiado el evaluador, veremos cómo transformar nuestro lenguaje precisamente de esta manera. Desafortunadamente, incluir retrasos en las llamadas a procedimientos causa estragos con nuestra capacidad para diseñar programas que dependen del orden de los eventos, como programas que usan asignación, mutan datos o realizan entrada o salida. Incluso el único ~delay~ en ~cons-stream~ puede causar gran confusión, como se ilustra en [[#exercise-3.51][Ejercicio 3.51]] y [[#exercise-3.52][Ejercicio 3.52]]. Hasta donde se sabe, la mutabilidad y la evaluación diferida no se mezclan bien en los lenguajes de programación, e idear formas de lidiar con ambas a la vez es un área activa de investigación.

