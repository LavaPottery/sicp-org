** 4.2 Variaciones sobre Scheme -- Evaluación perezosa
:properties:
:custom_id: section-4.2
:end:

Ahora que tenemos un evaluador expresado como un programa Lisp, podemos experimentar con opciones alternativas en el diseño de lenguajes simplemente modificando el evaluador. De hecho, a menudo se inventan nuevos lenguajes escribiendo primero un evaluador que incorpora el nuevo lenguaje dentro de un lenguaje de alto nivel existente. Por ejemplo, si deseamos discutir algún aspecto de una modificación propuesta a Lisp con otro miembro de la comunidad Lisp, podemos proporcionar un evaluador que incorpore el cambio. El destinatario puede entonces experimentar con el nuevo evaluador y enviar comentarios como modificaciones adicionales. No solo la base de implementación de alto nivel facilita probar y depurar el evaluador; además, la incorporación permite al diseñador snarf[fn:235] características del lenguaje subyacente, tal como nuestro evaluador Lisp incorporado usa primitivas y estructura de control del Lisp subyacente. Solo más tarde (si acaso) necesita el diseñador tomarse la molestia de construir una implementación completa en un lenguaje de bajo nivel o en hardware. En esta sección y la siguiente exploramos algunas variaciones sobre Scheme que proporcionan un poder expresivo adicional significativo.

*** 4.2.1 Orden normal y orden aplicativo
:properties:
:custom_id: section-4.2.1
:end:

En la sección [[#section-1.1][1.1]], donde comenzamos nuestra discusión de modelos de evaluación, notamos que Scheme es un <<i18>> lenguaje de orden aplicativo, es decir, que todos los argumentos de los procedimientos Scheme se evalúan cuando se aplica el procedimiento. En contraste, los <<i262>> lenguajes de orden normal retrasan la evaluación de los argumentos del procedimiento hasta que se necesitan los valores reales de los argumentos. Retrasar la evaluación de los argumentos del procedimiento hasta el último momento posible (por ejemplo, hasta que son requeridos por una operación primitiva) se llama <<i203>> evaluación perezosa.[fn:236] Considera el procedimiento

#+begin_src scheme
(define (try a b)
  (if (= a 0) 1 b))
#+end_src

Evaluar ~(try 0 (/ 1 0))~ genera un error en Scheme. Con evaluación perezosa, no habría error. Evaluar la expresión devolvería 1, porque el argumento ~(/ 1 0)~ nunca sería evaluado.

Un ejemplo que explota la evaluación perezosa es la definición de un procedimiento ~unless~

#+begin_src scheme
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
#+end_src

que puede usarse en expresiones como

#+begin_src scheme
(unless (= b 0)
  (/ a b)
  (begin (display "exception: returning 0")
         0))
#+end_src

Esto no funcionará en un lenguaje de orden aplicativo porque tanto el valor usual como el valor excepcional serán evaluados antes de que se llame a ~unless~ (compara [[#exercise-1.6][Ejercicio 1.6]]). Una ventaja de la evaluación perezosa es que algunos procedimientos, como ~unless~, pueden hacer cálculos útiles incluso si la evaluación de algunos de sus argumentos produciría errores o no terminaría.

Si el cuerpo de un procedimiento se entra antes de que un argumento haya sido evaluado decimos que el procedimiento es <<i257>> no estricto en ese argumento. Si el argumento se evalúa antes de entrar al cuerpo del procedimiento decimos que el procedimiento es <<i372>> estricto en ese argumento.[fn:237] En un lenguaje puramente de orden aplicativo, todos los procedimientos son estrictos en cada argumento. En un lenguaje puramente de orden normal, todos los procedimientos compuestos son no estrictos en cada argumento, y los procedimientos primitivos pueden ser estrictos o no estrictos. También hay lenguajes (véase [[#exercise-4.31][Ejercicio 4.31]]) que dan a los programadores control detallado sobre la estrictez de los procedimientos que definen.

Un ejemplo notable de un procedimiento que puede hacerse útilmente no estricto es ~cons~ (o, en general, casi cualquier constructor para estructuras de datos). Se puede hacer cálculo útil, combinando elementos para formar estructuras de datos y operando sobre las estructuras de datos resultantes, incluso si los valores de los elementos no son conocidos. Tiene perfecto sentido, por ejemplo, calcular la longitud de una lista sin conocer los valores de los elementos individuales en la lista. Explotaremos esta idea en la sección [[#section-4.2.3][4.2.3]] para implementar los streams del [[#section-3][Capítulo 3]] como listas formadas de pares ~cons~ no estrictos.

**** Ejercicio 4.25
:properties:
:custom_id: exercise-4.25
:end:

Supón que (en Scheme ordinario de orden aplicativo) definimos ~unless~ como se muestra arriba y luego definimos ~factorial~ en términos de ~unless~ como

#+begin_src scheme
(define (factorial n)
  (unless (= n 1)
    (* n (factorial (- n 1)))
    1))
#+end_src

¿Qué sucede si intentamos evaluar ~(factorial 5)~? ¿Funcionarán nuestras definiciones en un lenguaje de orden normal?

**** Ejercicio 4.26
:properties:
:custom_id: exercise-4.26
:end:

Ben Bitdiddle y Alyssa P. Hacker no están de acuerdo sobre la importancia de la evaluación perezosa para implementar cosas como ~unless~. Ben señala que es posible implementar ~unless~ en orden aplicativo como una forma especial. Alyssa contesta que, si uno hiciera eso, ~unless~ sería meramente sintaxis, no un procedimiento que pudiera usarse en conjunción con procedimientos de orden superior. Completa los detalles en ambos lados del argumento. Muestra cómo implementar ~unless~ como una expresión derivada (como ~cond~ o ~let~), y da un ejemplo de una situación donde podría ser útil tener ~unless~ disponible como un procedimiento, en lugar de como una forma especial.

