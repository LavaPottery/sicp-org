** 4.2 Variations on a Scheme -- Lazy Evaluation
:properties:
:custom_id: section-4.2
:end:

Now that we have an evaluator expressed as a Lisp program, we can experiment with alternative choices in language design simply by modifying the evaluator.  Indeed, new languages are often invented by first writing an evaluator that embeds the new language within an existing high-level language.  For example, if we wish to discuss some aspect of a proposed modification to Lisp with another member of the Lisp community, we can supply an evaluator that embodies the change.  The recipient can then experiment with the new evaluator and send back comments as further modifications.  Not only does the high-level implementation base make it easier to test and debug the evaluator; in addition, the embedding enables the designer to snarf[fn:235] features from the underlying language, just as our embedded Lisp evaluator uses primitives and control structure from the underlying Lisp.  Only later (if ever) need the designer go to the trouble of building a complete implementation in a low-level language or in hardware.  In this section and the next we explore some variations on Scheme that provide significant additional expressive power.

*** 4.2.1 Normal Order and Applicative Order
:properties:
:custom_id: section-4.2.1
:end:

In section [[#section-1.1][1.1]], where we began our discussion of models of evaluation, we noted that Scheme is an <<i18>> applicative-order language, namely, that all the arguments to Scheme procedures are evaluated when the procedure is applied.  In contrast, <<i262>> normal-order languages delay evaluation of procedure arguments until the actual argument values are needed.  Delaying evaluation of procedure arguments until the last possible moment (e.g., until they are required by a primitive operation) is called <<i203>> lazy evaluation.[fn:236] Consider the procedure

#+begin_src scheme
(define (try a b)
  (if (= a 0) 1 b))
#+end_src

Evaluating ~(try 0 (/ 1 0))~ generates an error in Scheme.  With lazy evaluation, there would be no error.  Evaluating the expression would return 1, because the argument ~(/ 1 0)~ would never be evaluated.

An example that exploits lazy evaluation is the definition of a procedure ~unless~

#+begin_src scheme
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
#+end_src

that can be used in expressions such as

#+begin_src scheme
(unless (= b 0)
  (/ a b)
  (begin (display "exception: returning 0")
         0))
#+end_src

This won't work in an applicative-order language because both the usual value and the exceptional value will be evaluated before ~unless~ is called (compare [[#exercise-1.6][Exercise 1.6]]).  An advantage of lazy evaluation is that some procedures, such as ~unless~, can do useful computation even if evaluation of some of their arguments would produce errors or would not terminate.

If the body of a procedure is entered before an argument has been evaluated we say that the procedure is <<i257>> non-strict in that argument.  If the argument is evaluated before the body of the procedure is entered we say that the procedure is <<i372>> strict in that argument.[fn:237] In a purely applicative-order language, all procedures are strict in each argument.  In a purely normal-order language, all compound procedures are non-strict in each argument, and primitive procedures may be either strict or non-strict.  There are also languages (see [[#exercise-4.31][Exercise 4.31]]) that give programmers detailed control over the strictness of the procedures they define.

A striking example of a procedure that can usefully be made non-strict is ~cons~ (or, in general, almost any constructor for data structures).  One can do useful computation, combining elements to form data structures and operating on the resulting data structures, even if the values of the elements are not known.  It makes perfect sense, for instance, to compute the length of a list without knowing the values of the individual elements in the list.  We will exploit this idea in section [[#section-4.2.3][4.2.3]] to implement the streams of [[#section-3][Chapter 3]] as lists formed of non-strict ~cons~ pairs.

**** Exercise 4.25
:properties:
:custom_id: exercise-4.25
:end:

Suppose that (in ordinary applicative-order Scheme) we define ~unless~ as shown above and then define ~factorial~ in terms of ~unless~ as

#+begin_src scheme
(define (factorial n)
  (unless (= n 1)
    (* n (factorial (- n 1)))
    1))
#+end_src

What happens if we attempt to evaluate ~(factorial 5)~?  Will our definitions work in a normal-order language?

**** Exercise 4.26
:properties:
:custom_id: exercise-4.26
:end:

Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of lazy evaluation for implementing things such as ~unless~.  Ben points out that it's possible to implement ~unless~ in applicative order as a special form.  Alyssa counters that, if one did that, ~unless~ would be merely syntax, not a procedure that could be used in conjunction with higher-order procedures.  Fill in the details on both sides of the argument.  Show how to implement ~unless~ as a derived expression (like ~cond~ or ~let~), and give an example of a situation where it might be useful to have ~unless~ available as a procedure, rather than as a special form.

