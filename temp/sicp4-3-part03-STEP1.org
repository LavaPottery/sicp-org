*** 4.3.3 Implementando el Evaluador ~amb~
:properties:
:custom_id: section-4.3.3
:end:

La evaluación de una expresión ordinaria de Scheme puede devolver un valor, puede nunca terminar, o puede señalar un error. En Scheme no determinista, la evaluación de una expresión puede además resultar en el descubrimiento de un callejón sin salida, en cuyo caso la evaluación debe retroceder a un punto de elección anterior. La interpretación de Scheme no determinista se complica por este caso adicional.

Construiremos el evaluador ~amb~ para Scheme no determinista modificando el evaluador analizador de la sección [[#section-4.1.7][4.1.7]].[fn:259] Como en el evaluador analizador, la evaluación de una expresión se logra llamando a un procedimiento de ejecución producido por el análisis de esa expresión. La diferencia entre la interpretación de Scheme ordinario y la interpretación de Scheme no determinista estará completamente en los procedimientos de ejecución.

*Procedimientos de ejecución y continuaciones*

Recuerda que los procedimientos de ejecución para el evaluador ordinario toman un argumento: el entorno de ejecución. En contraste, los procedimientos de ejecución en el evaluador ~amb~ toman tres argumentos: el entorno, y dos procedimientos llamados <<i84>> procedimientos de continuación. La evaluación de una expresión terminará llamando a una de estas dos continuaciones: Si la evaluación resulta en un valor, se llama a la <<i377>> continuación de éxito con ese valor; si la evaluación resulta en el descubrimiento de un callejón sin salida, se llama a la <<i135>> continuación de fallo. Construir y llamar a continuaciones apropiadas es el mecanismo mediante el cual el evaluador no determinista implementa el retroceso.

Es el trabajo de la continuación de éxito recibir un valor y proceder con la computación. Junto con ese valor, se pasa a la continuación de éxito otra continuación de fallo, que debe ser llamada posteriormente si el uso de ese valor lleva a un callejón sin salida.

Es el trabajo de la continuación de fallo intentar otra rama del proceso no determinista. La esencia del lenguaje no determinista está en el hecho de que las expresiones pueden representar elecciones entre alternativas. La evaluación de tal expresión debe proceder con una de las elecciones alternativas indicadas, aunque no se sepa de antemano qué elecciones llevarán a resultados aceptables. Para lidiar con esto, el evaluador elige una de las alternativas y pasa este valor a la continuación de éxito. Junto con este valor, el evaluador construye y pasa una continuación de fallo que puede ser llamada más tarde para elegir una alternativa diferente.

Se desencadena un fallo durante la evaluación (es decir, se llama a una continuación de fallo) cuando un programa de usuario rechaza explícitamente la línea de ataque actual (por ejemplo, una llamada a ~require~ puede resultar en la ejecución de ~(amb)~, una expresión que siempre falla--ver sección [[#section-4.3.1][4.3.1]]). La continuación de fallo a mano en ese punto causará que el punto de elección más reciente elija otra alternativa. Si no hay más alternativas a considerar en ese punto de elección, se desencadena un fallo en un punto de elección anterior, y así sucesivamente. Las continuaciones de fallo también son invocadas por el bucle de controlador en respuesta a una solicitud de ~try-again~, para encontrar otro valor de la expresión.

Además, si ocurre una operación de efecto secundario (como una asignación a una variable) en una rama del proceso resultante de una elección, puede ser necesario, cuando el proceso encuentra un callejón sin salida, deshacer el efecto secundario antes de hacer una nueva elección. Esto se logra haciendo que la operación de efecto secundario produzca una continuación de fallo que deshace el efecto secundario y propaga el fallo.

En resumen, las continuaciones de fallo son construidas por

- expresiones ~amb~--para proporcionar un mecanismo para hacer elecciones alternativas si la elección actual hecha por la expresión ~amb~ lleva a un callejón sin salida;

- el controlador de nivel superior--para proporcionar un mecanismo para reportar fallo cuando se agotan las elecciones;

- asignaciones--para interceptar fallos y deshacer asignaciones durante el retroceso.

Los fallos se inician solo cuando se encuentra un callejón sin salida. Esto ocurre

- si el programa de usuario ejecuta ~(amb)~;
- si el usuario escribe ~try-again~ en el controlador de nivel superior.

Las continuaciones de fallo también se llaman durante el procesamiento de un fallo:

- Cuando la continuación de fallo creada por una asignación termina de deshacer un efecto secundario, llama a la continuación de fallo que interceptó, para propagar el fallo de vuelta al punto de elección que llevó a esta asignación o al nivel superior.

- Cuando la continuación de fallo para un ~amb~ se queda sin opciones, llama a la continuación de fallo que originalmente se dio al ~amb~, para propagar el fallo de vuelta al punto de elección anterior o al nivel superior.

*Estructura del evaluador*

Los procedimientos de sintaxis y representación de datos para el evaluador ~amb~, y también el procedimiento básico ~analyze~, son idénticos a aquellos en el evaluador de la sección [[#section-4.1.7][4.1.7]], excepto por el hecho de que necesitamos procedimientos de sintaxis adicionales para reconocer la forma especial ~amb~:[fn:260]

#+begin_src scheme
(define (amb? exp) (tagged-list? exp 'amb))

(define (amb-choices exp) (cdr exp))
#+end_src

También debemos agregar al despacho en ~analyze~ una cláusula que reconocerá esta forma especial y generará un procedimiento de ejecución apropiado:

#+begin_src scheme
((amb? exp) (analyze-amb exp))
#+end_src

El procedimiento de nivel superior ~ambeval~ (similar a la versión de ~eval~ dada en la sección [[#section-4.1.7][4.1.7]]) analiza la expresión dada y aplica el procedimiento de ejecución resultante al entorno dado, junto con dos continuaciones dadas:

#+begin_src scheme
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
#+end_src

Una continuación de éxito es un procedimiento de dos argumentos: el valor recién obtenido y otra continuación de fallo a usar si ese valor lleva a un fallo posterior. Una continuación de fallo es un procedimiento sin argumentos. Así que la forma general de un procedimiento de ejecución es

#+begin_src scheme
(lambda (env succeed fail)
  ;; ~succeed~ is '(lambda (value fail) ...)'
  ;; ~fail~ is '(lambda () ...)'
  ...)
#+end_src

Por ejemplo, ejecutar

#+begin_src scheme
(ambeval <EXP>
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
#+end_src

intentará evaluar la expresión dada y devolverá el valor de la expresión (si la evaluación tiene éxito) o el símbolo ~failed~ (si la evaluación falla). La llamada a ~ambeval~ en el bucle de controlador mostrado a continuación usa procedimientos de continuación mucho más complicados, que continúan el bucle y soportan la solicitud de ~try-again~.

La mayor parte de la complejidad del evaluador ~amb~ resulta de la mecánica de pasar las continuaciones mientras los procedimientos de ejecución se llaman entre sí. Al revisar el siguiente código, debes comparar cada uno de los procedimientos de ejecución con el procedimiento correspondiente para el evaluador ordinario dado en la sección [[#section-4.1.7][4.1.7]].

*Expresiones simples*

Los procedimientos de ejecución para los tipos de expresiones más simples son esencialmente los mismos que aquellos para el evaluador ordinario, excepto por la necesidad de gestionar las continuaciones. Los procedimientos de ejecución simplemente tienen éxito con el valor de la expresión, pasando la continuación de fallo que se les pasó.

#+begin_src scheme
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))

(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))

(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))

(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
#+end_src

Observa que buscar una variable siempre "tiene éxito". Si ~lookup-variable-value~ no logra encontrar la variable, señala un error, como es usual. Tal "fallo" indica un error de programa--una referencia a una variable no vinculada; no es una indicación de que debamos intentar otra elección no determinista en lugar de la que se está intentando actualmente.

*Condicionales y secuencias*

Los condicionales también se manejan de manera similar al evaluador ordinario. El procedimiento de ejecución generado por ~analyze-if~ invoca el procedimiento de ejecución del predicado ~pproc~ con una continuación de éxito que verifica si el valor del predicado es verdadero y continúa ejecutando el consecuente o la alternativa. Si la ejecución de ~pproc~ falla, se llama a la continuación de fallo original para la expresión ~if~.

#+begin_src scheme
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             ;; success continuation for evaluating the predicate
             ;; to obtain ~pred-value~
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             ;; failure continuation for evaluating the predicate
             fail))))
#+end_src

Las secuencias también se manejan de la misma manera que en el evaluador anterior, excepto por las maquinaciones en el subprocedimiento ~sequentially~ que se requieren para pasar las continuaciones. Es decir, para ejecutar secuencialmente ~a~ y luego ~b~, llamamos a ~a~ con una continuación de éxito que llama a ~b~.

#+begin_src scheme
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         ;; success continuation for calling ~a~
         (lambda (a-value fail2)
           (b env succeed fail2))
         ;; failure continuation for calling ~a~
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence - ANALYZE"))
    (loop (car procs) (cdr procs))))
#+end_src

*Definiciones y asignaciones*

Las definiciones son otro caso donde debemos tomarnos algunas molestias para gestionar las continuaciones, porque es necesario evaluar la expresión del valor de definición antes de definir realmente la nueva variable. Para lograr esto, se llama al procedimiento de ejecución del valor de definición ~vproc~ con el entorno, una continuación de éxito y la continuación de fallo. Si la ejecución de ~vproc~ tiene éxito, obteniendo un valor ~val~ para la variable definida, la variable se define y se propaga el éxito:

#+begin_src scheme
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
#+end_src

Las asignaciones son más interesantes. Este es el primer lugar donde realmente usamos las continuaciones, en lugar de solo pasarlas. El procedimiento de ejecución para asignaciones comienza como el de las definiciones. Primero intenta obtener el nuevo valor a asignar a la variable. Si esta evaluación de ~vproc~ falla, la asignación falla.

Si ~vproc~ tiene éxito, sin embargo, y procedemos a hacer la asignación, debemos considerar la posibilidad de que esta rama de la computación pueda fallar más tarde, lo que nos requerirá retroceder fuera de la asignación. Por lo tanto, debemos arreglar para deshacer la asignación como parte del proceso de retroceso.[fn:261]

Esto se logra dando a ~vproc~ una continuación de éxito (marcada con el comentario "*1*" a continuación) que guarda el valor antiguo de la variable antes de asignar el nuevo valor a la variable y proceder desde la asignación. La continuación de fallo que se pasa junto con el valor de la asignación (marcada con el comentario "*2*" a continuación) restaura el valor antiguo de la variable antes de continuar el fallo. Es decir, una asignación exitosa proporciona una continuación de fallo que interceptará un fallo posterior; cualquier fallo que de otro modo hubiera llamado a ~fail2~ llama a este procedimiento en su lugar, para deshacer la asignación antes de llamar realmente a ~fail2~.

#+begin_src scheme
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        ; *1*
               (let ((old-value
                      (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    ; *2*
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
#+end_src

*Aplicaciones de procedimiento*

El procedimiento de ejecución para aplicaciones no contiene nuevas ideas excepto por la complejidad técnica de gestionar las continuaciones. Esta complejidad surge en ~analyze-application~, debido a la necesidad de hacer un seguimiento de las continuaciones de éxito y fallo mientras evaluamos los operandos. Usamos un procedimiento ~get-args~ para evaluar la lista de operandos, en lugar de un simple ~map~ como en el evaluador ordinario.

#+begin_src scheme
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
#+end_src

En ~get-args~, observa cómo bajar con 'cdr' por la lista de procedimientos de ejecución ~aproc~ y construir con 'cons' la lista resultante de ~args~ se logra llamando a cada ~aproc~ en la lista con una continuación de éxito que llama recursivamente a ~get-args~. Cada una de estas llamadas recursivas a ~get-args~ tiene una continuación de éxito cuyo valor es el ~cons~ del argumento recién obtenido sobre la lista de argumentos acumulados:

#+begin_src scheme
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
       ;; success continuation for this ~aproc~
       (lambda (arg fail2)
         (get-args (cdr aprocs)
                   env
                   ;; success continuation for recursive
                   ;; call to ~get-args~
                   (lambda (args fail3)
                     (succeed (cons arg args)
                              fail3))
                   fail2))
       fail)))
#+end_src

La aplicación de procedimiento real, que es realizada por ~execute-application~, se logra de la misma manera que para el evaluador ordinario, excepto por la necesidad de gestionar las continuaciones.

#+begin_src scheme
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Unknown procedure type - EXECUTE-APPLICATION"
          proc))))
#+end_src

*Evaluando expresiones ~amb~*

La forma especial ~amb~ es el elemento clave en el lenguaje no determinista. Aquí vemos la esencia del proceso de interpretación y la razón para hacer un seguimiento de las continuaciones. El procedimiento de ejecución para ~amb~ define un bucle ~try-next~ que recorre los procedimientos de ejecución para todos los valores posibles de la expresión ~amb~. Cada procedimiento de ejecución se llama con una continuación de fallo que intentará el siguiente. Cuando no hay más alternativas que intentar, toda la expresión ~amb~ falla.

#+begin_src scheme
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
             succeed
             (lambda ()
               (try-next (cdr choices))))))
      (try-next cprocs))))
#+end_src

*Bucle de controlador*

El bucle de controlador para el evaluador ~amb~ es complejo, debido al mecanismo que permite al usuario intentar de nuevo al evaluar una expresión. El controlador usa un procedimiento llamado ~internal-loop~, que toma como argumento un procedimiento ~try-again~. La intención es que llamar a ~try-again~ deba continuar con la siguiente alternativa no probada en la evaluación no determinista. ~internal-loop~ llama a ~try-again~ en respuesta al usuario escribiendo ~try-again~ en el bucle de controlador, o inicia una nueva evaluación llamando a ~ambeval~.

La continuación de fallo para esta llamada a ~ambeval~ informa al usuario que no hay más valores y vuelve a invocar el bucle de controlador.

La continuación de éxito para la llamada a ~ambeval~ es más sutil. Imprimimos el valor obtenido y luego invocamos el bucle interno de nuevo con un procedimiento ~try-again~ que podrá intentar la siguiente alternativa. Este procedimiento ~next-alternative~ es el segundo argumento que se pasó a la continuación de éxito. Ordinariamente, pensamos en este segundo argumento como una continuación de fallo a usar si la rama de evaluación actual falla más tarde. En este caso, sin embargo, hemos completado una evaluación exitosa, así que podemos invocar la rama alternativa de "fallo" para buscar evaluaciones exitosas adicionales.

#+begin_src scheme
(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     ;; ~ambeval~ success
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                     ;; ~ambeval~ failure
                     (lambda ()
                       (announce-output
                        ";;; There are no more values of")
                       (user-print input)
                       (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
#+end_src

La llamada inicial a ~internal-loop~ usa un procedimiento ~try-again~ que se queja de que no hay ningún problema actual y reinicia el bucle de controlador. Este es el comportamiento que ocurrirá si el usuario escribe ~try-again~ cuando no hay ninguna evaluación en progreso.

**** Exercise 4.50
:properties:
:custom_id: exercise-4.50
:end:

Implementa una nueva forma especial ~ramb~ que sea como ~amb~ excepto que busca alternativas en un orden aleatorio, en lugar de de izquierda a derecha. Muestra cómo esto puede ayudar con el problema de Alyssa en el [[#exercise-4.49][Exercise 4.49]].

**** Exercise 4.51
:properties:
:custom_id: exercise-4.51
:end:

Implementa un nuevo tipo de asignación llamada ~permanent-set!~ que no se deshace al fallar. Por ejemplo, podemos elegir dos elementos distintos de una lista y contar el número de intentos requeridos para hacer una elección exitosa de la siguiente manera:

#+begin_src scheme
(define count 0)

(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
;;; Starting a new problem
;;; Amb-Eval value:
(a b 2)

;;; Amb-Eval input:
try-again
;;; Amb-Eval value:
(a c 3)
#+end_src

¿Qué valores se habrían mostrado si hubiéramos usado ~set!~ aquí en lugar de ~permanent-set!~?

**** Exercise 4.52
:properties:
:custom_id: exercise-4.52
:end:

Implementa una nueva construcción llamada ~if-fail~ que permita al usuario capturar el fallo de una expresión. ~if-fail~ toma dos expresiones. Evalúa la primera expresión como es usual y devuelve como es usual si la evaluación tiene éxito. Si la evaluación falla, sin embargo, se devuelve el valor de la segunda expresión, como en el siguiente ejemplo:

#+begin_src scheme
;;; Amb-Eval input:
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
;;; Starting a new problem
;;; Amb-Eval value:
all-odd

;;; Amb-Eval input:
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
;;; Starting a new problem
;;; Amb-Eval value:
8
#+end_src

**** Exercise 4.53
:properties:
:custom_id: exercise-4.53
:end:

Con ~permanent-set!~ como se describe en el [[#exercise-4.51][Exercise 4.51]] e ~if-fail~ como en el [[#exercise-4.52][Exercise 4.52]], ¿cuál será el resultado de evaluar

#+begin_src scheme
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
#+end_src

**** Exercise 4.54
:properties:
:custom_id: exercise-4.54
:end:

Si no nos hubiéramos dado cuenta de que ~require~ podría implementarse como un procedimiento ordinario que usa ~amb~, para ser definido por el usuario como parte de un programa no determinista, habríamos tenido que implementarlo como una forma especial. Esto requeriría procedimientos de sintaxis

#+begin_src scheme
(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
#+end_src

y una nueva cláusula en el despacho en ~analyze~

#+begin_src scheme
((require? exp) (analyze-require exp))
#+end_src

así como el procedimiento ~analyze-require~ que maneja expresiones ~require~. Completa la siguiente definición de ~analyze-require~.

#+begin_src scheme
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if <??>
                   <??>
                   (succeed 'ok fail2)))
             fail))))
#+end_src
