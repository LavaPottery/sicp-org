** 4.4 Logic Programming
:properties:
:custom_id: section-4.4
:end:

In [[#section-1][Chapter 1]] we stressed that computer science deals with imperative (how to) knowledge, whereas mathematics deals with declarative (what is) knowledge.  Indeed, programming languages require that the programmer express knowledge in a form that indicates the step-by-step methods for solving particular problems.  On the other hand, high-level languages provide, as part of the language implementation, a substantial amount of methodological knowledge that frees the user from concern with numerous details of how a specified computation will progress.

Most programming languages, including Lisp, are organized around computing the values of mathematical functions.  Expression-oriented languages (such as Lisp, Fortran, and Algol) capitalize on the "pun" that an expression that describes the value of a function may also be interpreted as a means of computing that value.  Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs).  There are, however, radically different programming languages that relax this bias.  We saw one such example in section [[#section-3.3.5][3.3.5]], where the objects of computation were arithmetic constraints.  In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed "how to" knowledge than would be the case with an ordinary arithmetic computation.  This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge.  There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation.

The nondeterministic program evaluator of section [[#section-4.3][4.3]] also moves away from the view that programming is about constructing algorithms for computing unidirectional functions.  In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with relations rather than with single-valued functions.  Logic programming extends this idea by combining a relational vision of programming with a powerful kind of symbolic pattern matching called <<i410>> unification.[fn:262]

This approach, when it works, can be a very powerful way to write programs.  Part of the power comes from the fact that a single "what is" fact can be used to solve a number of different problems that would have different "how to" components.  As an example, consider the ~append~ operation, which takes two lists as arguments and combines their elements to form a single list.  In a procedural language such as Lisp, we could define ~append~ in terms of the basic list constructor ~cons~, as we did in section [[#section-2.2.1][2.2.1]]:

#+begin_src scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+end_src

This procedure can be regarded as a translation into Lisp of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a ~cons~ of two parts:

- For any list ~y~, the empty list and ~y~ ~append~ to form ~y~.

- For any ~u~, ~v~, ~y~, and ~z~, ~(cons u v)~ and ~y~ ~append~ to form ~(cons u z)~ if ~v~ and ~y~ ~append~ to form ~z~.[fn:263]

Using the ~append~ procedure, we can answer questions such as

#+begin_example
Find the ~append~ of ~(a b)~ and ~(c d)~.
#+end_example

But the same two rules are also sufficient for answering the following sorts of questions, which the procedure can't answer:

#+begin_example
Find a list ~y~ that ~append~s with ~(a b)~ to produce ~(a
b c d)~.

Find all ~x~ and ~y~ that ~append~ to form ~(a b c d)~.
#+end_example

In a logic programming language, the programmer writes an ~append~ "procedure" by stating the two rules about ~append~ given above.  "How to" knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about ~append~.[fn:264]

Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general "how to" methods can lead them into spurious infinite loops or other undesirable behavior.  Logic programming is an active field of research in computer science.[fn:265]

Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a Lisp-like language (indeed, to an interpreter for any conventional language).  Now we will apply these ideas to discuss an interpreter for a logic programming language.  We call this language the <<i313>> query language, because it is very useful for retrieving information from data bases by formulating <<i312>> queries, or questions, expressed in the language.  Even though the query language is very different from Lisp, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units.  An interpreter for a logic programming language is considerably more complex than an interpreter for a language like Lisp.  Nevertheless, we will see that our query-language interpreter contains many of the same elements found in the interpreter of section [[#section-4.1][4.1]].  In particular, there will be an "eval" part that classifies expressions according to type and an "apply" part that implements the language's abstraction mechanism (procedures in the case of Lisp, and <<i339>> rules in the case of logic programming).  Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values.  One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in [[#section-3][Chapter 3]].

*** 4.4.1 Deductive Information Retrieval
:properties:
:custom_id: section-4.4.1
:end:

Logic programming excels in providing interfaces to data bases for information retrieval.  The query language we shall implement in this chapter is designed to be used in this way.

In order to illustrate what the query system does, we will show how it can be used to manage the data base of personnel records for Microshaft, a thriving high-technology company in the Boston area.  The language provides pattern-directed access to personnel information and can also take advantage of general rules in order to make logical deductions.

*A sample data base*

The personnel data base for Microshaft contains <<i23>> assertions about company personnel.  Here is the information about Ben Bitdiddle, the resident computer wizard:

#+begin_src scheme
(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
#+end_src

Each assertion is a list (in this case a triple) whose elements can themselves be lists.

As resident wizard, Ben is in charge of the company's computer division, and he supervises two programmers and one technician.  Here is the information about them:

#+begin_src scheme
(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))

(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))

(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
#+end_src

There is also a programmer trainee, who is supervised by Alyssa:

#+begin_src scheme
(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
#+end_src

All of these people are in the computer division, as indicated by the word ~computer~ as the first item in their job descriptions.

Ben is a high-level employee.  His supervisor is the company's big wheel himself:

#+begin_src scheme
(supervisor (Bitdiddle Ben) (Warbucks Oliver))

(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
#+end_src

Besides the computer division supervised by Ben, the company has an accounting division, consisting of a chief accountant and his assistant:

#+begin_src scheme
(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))

(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
#+end_src

There is also a secretary for the big wheel:

#+begin_src scheme
(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
#+end_src

The data base also contains assertions about which kinds of jobs can be done by people holding other kinds of jobs.  For instance, a computer wizard can do the jobs of both a computer programmer and a computer technician:

#+begin_src scheme
(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
#+end_src

A computer programmer could fill in for a trainee:

#+begin_src scheme
(can-do-job (computer programmer)
            (computer programmer trainee))
#+end_src

Also, as is well known,

#+begin_src scheme
(can-do-job (administration secretary)
            (administration big wheel))
#+end_src

*Simple queries*

The query language allows users to retrieve information from the data base by posing queries in response to the system's prompt.  For example, to find all computer programmers one can say

#+begin_src scheme
;;; Query input:
(job ?x (computer programmer))
#+end_src

The system will respond with the following items:

#+begin_src scheme
;;; Query results:
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
#+end_src

The input query specifies that we are looking for entries in the data base that match a certain <<i282>> pattern.  In this example, the pattern specifies entries consisting of three items, of which the first is the literal symbol ~job~, the second can be anything, and the third is the literal list ~(computer programmer)~.  The "anything" that can be the second item in the matching list is specified by a <<i285>> pattern variable, ~?x~.  The general form of a pattern variable is a symbol, taken to be the name of the variable, preceded by a question mark.  We will see below why it is useful to specify names for pattern variables rather than just putting ~?~ into patterns to represent "anything."  The system responds to a simple query by showing all entries in the data base that match the specified pattern.

A pattern can have more than one variable.  For example, the query

#+begin_src scheme
(address ?x ?y)
#+end_src

will list all the employees' addresses.

A pattern can have no variables, in which case the query simply determines whether that pattern is an entry in the data base.  If so, there will be one match; if not, there will be no matches.

The same pattern variable can appear more than once in a query, specifying that the same "anything" must appear in each position.  This is why variables have names.  For example,

#+begin_src scheme
(supervisor ?x ?x)
#+end_src

finds all people who supervise themselves (though there are no such assertions in our sample data base).

The query

#+begin_src scheme
(job ?x (computer ?type))
#+end_src

matches all job entries whose third item is a two-element list whose first item is ~computer~:

#+begin_src scheme
(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
#+end_src

This same pattern does /not/ match

#+begin_src scheme
(job (Reasoner Louis) (computer programmer trainee))
#+end_src

because the third item in the entry is a list of three elements, and the pattern's third item specifies that there should be two elements.  If we wanted to change the pattern so that the third item could be any list beginning with ~computer~, we could specify[fn:266]

#+begin_src scheme
(job ?x (computer . ?type))
#+end_src

For example,

#+begin_src scheme
(computer . ?type)
#+end_src

matches the data

#+begin_src scheme
(computer programmer trainee)
#+end_src

with ~?type~ as the list ~(programmer trainee)~.  It also matches the data

#+begin_src scheme
(computer programmer)
#+end_src

with ~?type~ as the list ~(programmer)~, and matches the data

#+begin_src scheme
(computer)
#+end_src

with ~?type~ as the empty list ~()~.

We can describe the query language's processing of simple queries as follows:

- The system finds all assignments to variables in the query pattern that <<i341>> satisfy the pattern--that is, all sets of values for the variables such that if the pattern variables are <<i183>> instantiated with (replaced by) the values, the result is in the data base.

- The system responds to the query by listing all instantiations of the query pattern with the variable assignments that satisfy it.

Note that if the pattern has no variables, the query reduces to a determination of whether that pattern is in the data base.  If so, the empty assignment, which assigns no values to variables, satisfies that pattern for that data base.

**** Exercise 4.55
:properties:
:custom_id: exercise-4.55
:end:

Give simple queries that retrieve the following information from the data base:

1. all people supervised by Ben Bitdiddle;
2. the names and jobs of all people in the accounting division;
3. the names and addresses of all people who live in Slumerville.

*Compound queries*

Simple queries form the primitive operations of the query language.  In order to form compound operations, the query language provides means of combination.  One thing that makes the query language a logic programming language is that the means of combination mirror the means of combination used in forming logical expressions: ~and~, ~or~, and ~not~.  (Here ~and~, ~or~, and ~not~ are not the Lisp primitives, but rather operations built into the query language.)

We can use ~and~ as follows to find the addresses of all the computer programmers:

#+begin_src scheme
(and (job ?person (computer programmer))
     (address ?person ?where))
#+end_src

The resulting output is

#+begin_src scheme
(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))

(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
#+end_src

In general,

#+begin_src scheme
(and <QUERY_1> <QUERY_2> ... <QUERY_N>)
#+end_src

is satisfied by all sets of values for the pattern variables that simultaneously satisfy <QUERY_1> ... <QUERY_N>.

As for simple queries, the system processes a compound query by finding all assignments to the pattern variables that satisfy the query, then displaying instantiations of the query with those values.

Another means of constructing compound queries is through ~or~.  For example,

#+begin_src scheme
(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
#+end_src

will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:

#+begin_src scheme
(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))

(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))

(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))

(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
#+end_src

In general,

#+begin_src scheme
(or <QUERY_1> <QUERY_2> ... <QUERY_N>)
#+end_src

is satisfied by all sets of values for the pattern variables that satisfy at least one of <QUERY_1> ... <QUERY_N>.

Compound queries can also be formed with ~not~.  For example,

#+begin_src scheme
(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
#+end_src

finds all people supervised by Ben Bitdiddle who are not computer programmers.  In general,

#+begin_src scheme
(not <QUERY_1>)
#+end_src

is satisfied by all assignments to the pattern variables that do not satisfy <QUERY_1>.[fn:267]

The final combining form is called ~lisp-value~.  When ~lisp-value~ is the first element of a pattern, it specifies that the next element is a Lisp predicate to be applied to the rest of the (instantiated) elements as arguments.  In general,

#+begin_src scheme
(lisp-value <PREDICATE> <ARG_1> ... <ARG_N>)
#+end_src

will be satisfied by assignments to the pattern variables for which the <PREDICATE> applied to the instantiated <ARG_1> ... <ARG_N> is true.  For example, to find all people whose salary is greater than $30,000 we could write[fn:268]

#+begin_src scheme
(and (salary ?person ?amount)
     (lisp-value > ?amount 30000))
#+end_src

**** Exercise 4.56
:properties:
:custom_id: exercise-4.56
:end:

Formulate compound queries that retrieve the following information:

a. the names of all people who are supervised by Ben Bitdiddle, together with their addresses;

b. all people whose salary is less than Ben Bitdiddle's, together with their salary and Ben Bitdiddle's salary;

c. all people who are supervised by someone who is not in the computer division, together with the supervisor's name and job.

*Rules*

In addition to primitive queries and compound queries, the query language provides means for abstracting queries.  These are given by <<i340>> rules.  The rule

#+begin_src scheme
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
#+end_src

specifies that two people live near each other if they live in the same town.  The final ~not~ clause prevents the rule from saying that all people live near themselves.  The ~same~ relation is defined by a very simple rule:[fn:269]

#+begin_src scheme
(rule (same ?x ?x))
#+end_src

The following rule declares that a person is a "wheel" in an organization if he supervises someone who is in turn a supervisor:

#+begin_src scheme
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
#+end_src

The general form of a rule is

#+begin_src scheme
(rule <CONCLUSION> <BODY>)
#+end_src

where <CONCLUSION> is a pattern and <BODY> is any query.[fn:270] We can think of a rule as representing a large (even infinite) set of assertions, namely all instantiations of the rule conclusion with variable assignments that satisfy the rule body.  When we described simple queries (patterns), we said that an assignment to variables satisfies a pattern if the instantiated pattern is in the data base.  But the pattern needn't be explicitly in the data base as an assertion.  It can be an implicit assertion implied by a rule.  For example, the query

#+begin_src scheme
(lives-near ?x (Bitdiddle Ben))
#+end_src

results in

#+begin_src scheme
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
#+end_src

To find all computer programmers who live near Ben Bitdiddle, we can ask

#+begin_src scheme
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
#+end_src

As in the case of compound procedures, rules can be used as parts of other rules (as we saw with the ~lives-near~ rule above) or even be defined recursively.  For instance, the rule

#+begin_src scheme
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
#+end_src

says that a staff person is outranked by a boss in the organization if the boss is the person's supervisor or (recursively) if the person's supervisor is outranked by the boss.

**** Exercise 4.57
:properties:
:custom_id: exercise-4.57
:end:

Define a rule that says that person 1 can replace person 2 if either person 1 does the same job as person 2 or someone who does person 1's job can also do person 2's job, and if person 1 and person 2 are not the same person.  Using your rule, give queries that find the following:

a. all people who can replace Cy D. Fect;

b. all people who can replace someone who is being paid more than they are, together with the two salaries.

**** Exercise 4.58
:properties:
:custom_id: exercise-4.58
:end:

Define a rule that says that a person is a "big shot" in a division if the person works in the division but does not have a supervisor who works in the division.

**** Exercise 4.59
:properties:
:custom_id: exercise-4.59
:end:

Ben Bitdiddle has missed one meeting too many.  Fearing that his habit of forgetting meetings could cost him his job, Ben decides to do something about it.  He adds all the weekly meetings of the firm to the Microshaft data base by asserting the following:

#+begin_src scheme
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
#+end_src

Each of the above assertions is for a meeting of an entire division.  Ben also adds an entry for the company-wide meeting that spans all the divisions.  All of the company's employees attend this meeting.

#+begin_src scheme
(meeting whole-company (Wednesday 4pm))
#+end_src

a. On Friday morning, Ben wants to query the data base for all the meetings that occur that day.  What query should he use?

b. Alyssa P. Hacker is unimpressed.  She thinks it would be much more useful to be able to ask for her meetings by specifying her name.  So she designs a rule that says that a person's meetings include all ~whole-company~ meetings plus all meetings of that person's division.  Fill in the body of Alyssa's rule.

#+begin_src scheme
(rule (meeting-time ?person ?day-and-time)
      <RULE-BODY>)
#+end_src

c. Alyssa arrives at work on Wednesday morning and wonders what meetings she has to attend that day.  Having defined the above rule, what query should she make to find this out?

**** Exercise 4.60
:properties:
:custom_id: exercise-4.60
:end:

By giving the query

#+begin_src scheme
(lives-near ?person (Hacker Alyssa P))
#+end_src

Alyssa P. Hacker is able to find people who live near her, with whom she can ride to work.  On the other hand, when she tries to find all pairs of people who live near each other by querying

#+begin_src scheme
(lives-near ?person-1 ?person-2)
#+end_src

she notices that each pair of people who live near each other is listed twice; for example,

#+begin_src scheme
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
#+end_src

Why does this happen?  Is there a way to find a list of people who live near each other, in which each pair appears only once?  Explain.

*Logic as programs*

We can regard a rule as a kind of logical implication: /If/ an assignment of values to pattern variables satisfies the body, /then/ it satisfies the conclusion.  Consequently, we can regard the query language as having the ability to perform <<i221>> logical deductions based upon the rules.  As an example, consider the ~append~ operation described at the beginning of section [[#section-4.4][4.4]].  As we said, ~append~ can be characterized by the following two rules:

- For any list ~y~, the empty list and ~y~ ~append~ to form ~y~.

- For any ~u~, ~v~, ~y~, and ~z~, ~(cons u v)~ and ~y~ ~append~ to form ~(cons u z)~ if ~v~ and ~y~ ~append~ to form ~z~.

To express this in our query language, we define two rules for a relation

#+begin_src scheme
(append-to-form x y z)
#+end_src

which we can interpret to mean "~x~ and ~y~ ~append~ to form ~z~":

#+begin_src scheme
(rule (append-to-form () ?y ?y))

(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
#+end_src

The first rule has no body, which means that the conclusion holds for any value of ~?y~.  Note how the second rule makes use of dotted-tail notation to name the ~car~ and ~cdr~ of a list.

Given these two rules, we can formulate queries that compute the ~append~ of two lists:

#+begin_src scheme
;;; Query input:
(append-to-form (a b) (c d) ?z)
;;; Query results:
(append-to-form (a b) (c d) (a b c d))
#+end_src

What is more striking, we can use the same rules to ask the question "Which list, when 'append'ed to ~(a b)~, yields ~(a b c d)~?"  This is done as follows:

#+begin_src scheme
;;; Query input:
(append-to-form (a b) ?y (a b c d))
;;; Query results:
(append-to-form (a b) (c d) (a b c d))
#+end_src

We can also ask for all pairs of lists that ~append~ to form ~(a b c d)~:

#+begin_src scheme
;;; Query input:
(append-to-form ?x ?y (a b c d))
;;; Query results:
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
#+end_src

The query system may seem to exhibit quite a bit of intelligence in using the rules to deduce the answers to the queries above.  Actually, as we will see in the next section, the system is following a well-determined algorithm in unraveling the rules.  Unfortunately, although the system works impressively in the ~append~ case, the general methods may break down in more complex cases, as we will see in section [[#section-4.4.3][4.4.3]].

**** Exercise 4.61
:properties:
:custom_id: exercise-4.61
:end:

The following rules implement a ~next-to~ relation that finds adjacent elements of a list:

#+begin_src scheme
(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
#+end_src

What will the response be to the following queries?

#+begin_src scheme
(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))
#+end_src

**** Exercise 4.62
:properties:
:custom_id: exercise-4.62
:end:

Define rules to implement the ~last-pair~ operation of [[#exercise-2.17][Exercise 2.17]], which returns a list containing the last element of a nonempty list.  Check your rules on queries such as ~(last-pair (3) ?x)~, ~(last-pair (1 2 3) ?x)~, and ~(last-pair (2 ?x) (3))~.  Do your rules work correctly on queries such as ~(last-pair ?x (3))~ ?

**** Exercise 4.63
:properties:
:custom_id: exercise-4.63
:end:

The following data base (see Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way of Cain:

#+begin_src scheme
(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
#+end_src

Formulate rules such as "If S is the son of f, and f is the son of G, then S is the grandson of G" and "If W is the wife of M, and S is the son of W, then S is the son of M" (which was supposedly more true in biblical times than today) that will enable the query system to find the grandson of Cain; the sons of Lamech; the grandsons of Methushael.  (See [[#exercise-4.69][Exercise 4.69]] for some rules to deduce more complicated relationships.)

