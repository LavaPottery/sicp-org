*** 4.4.2 Cómo Funciona el Sistema de Consultas
:properties:
:custom_id: section-4.4.2
:end:

En la sección [[#section-4.4.4][4.4.4]] presentaremos una implementación del intérprete de consultas como una colección de procedimientos. En esta sección damos una visión general que explica la estructura general del sistema independientemente de los detalles de implementación de bajo nivel. Después de describir la implementación del intérprete, estaremos en posición de entender algunas de sus limitaciones y algunas de las formas sutiles en que las operaciones lógicas del lenguaje de consultas difieren de las operaciones de la lógica matemática.

Debería ser evidente que el evaluador de consultas debe realizar algún tipo de búsqueda para hacer coincidir consultas con hechos y reglas en la base de datos. Una forma de hacer esto sería implementar el sistema de consultas como un programa no determinista, usando el evaluador ~amb~ de la sección [[#section-4.3][4.3]] (véase el [[#exercise-4.78][Ejercicio 4.78]]). Otra posibilidad es gestionar la búsqueda con la ayuda de flujos. Nuestra implementación sigue este segundo enfoque.

El sistema de consultas está organizado en torno a dos operaciones centrales llamadas <<i284>> emparejamiento de patrones y <<i411>> unificación. Primero describimos el emparejamiento de patrones y explicamos cómo esta operación, junto con la organización de la información en términos de flujos de marcos, nos permite implementar tanto consultas simples como compuestas. A continuación discutimos la unificación, una generalización del emparejamiento de patrones necesaria para implementar reglas. Finalmente, mostramos cómo el intérprete de consultas completo encaja mediante un procedimiento que clasifica las expresiones de manera análoga a la forma en que ~eval~ clasifica las expresiones para el intérprete descrito en la sección [[#section-4.1][4.1]].

*Emparejamiento de patrones*

Un <<i283>> emparejador de patrones es un programa que prueba si algún dato se ajusta a un patrón especificado. Por ejemplo, la lista de datos ~((a b) c (a b))~ coincide con el patrón ~(?x c ?x)~ con la variable de patrón ~?x~ vinculada a ~(a b)~. La misma lista de datos coincide con el patrón ~(?x ?y ?z)~ con ~?x~ y ~?z~ ambos vinculados a ~(a b)~ y ~?y~ vinculado a ~c~. También coincide con el patrón ~((?x ?y) c (?x ?y))~ con ~?x~ vinculado a ~a~ y ~?y~ vinculado a ~b~. Sin embargo, no coincide con el patrón ~(?x a ?y)~, ya que ese patrón especifica una lista cuyo segundo elemento es el símbolo ~a~.

El emparejador de patrones usado por el sistema de consultas toma como entradas un patrón, un dato, y un <<i144>> marco que especifica vinculaciones para varias variables de patrón. Comprueba si el dato coincide con el patrón de una manera que sea consistente con las vinculaciones ya en el marco. Si es así, devuelve el marco dado aumentado por cualquier vinculación que pueda haber sido determinada por la coincidencia. De lo contrario, indica que la coincidencia ha fallado.

Por ejemplo, usar el patrón ~(?x ?y ?x)~ para coincidir con ~(a b a)~ dado un marco vacío devolverá un marco que especifica que ~?x~ está vinculado a ~a~ y ~?y~ está vinculado a ~b~. Intentar la coincidencia con el mismo patrón, el mismo dato, y un marco que especifica que ~?y~ está vinculado a ~a~ fallará. Intentar la coincidencia con el mismo patrón, el mismo dato, y un marco en el que ~?y~ está vinculado a ~b~ y ~?x~ no está vinculado devolverá el marco dado aumentado por una vinculación de ~?x~ a ~a~.

El emparejador de patrones es todo el mecanismo que se necesita para procesar consultas simples que no involucran reglas. Por ejemplo, para procesar la consulta

#+begin_src scheme
(job ?x (computer programmer))
#+end_src

escaneamos todas las aserciones en la base de datos y seleccionamos aquellas que coinciden con el patrón con respecto a un marco inicialmente vacío. Para cada coincidencia que encontramos, usamos el marco devuelto por la coincidencia para instanciar el patrón con un valor para ~?x~.

*Flujos de marcos*

La prueba de patrones contra marcos está organizada mediante el uso de flujos. Dado un solo marco, el proceso de coincidencia recorre las entradas de la base de datos una por una. Para cada entrada de la base de datos, el emparejador genera o bien un símbolo especial que indica que la coincidencia ha fallado o una extensión al marco. Los resultados para todas las entradas de la base de datos se recopilan en un flujo, que se pasa a través de un filtro para eliminar los fallos. El resultado es un flujo de todos los marcos que extienden el marco dado mediante una coincidencia con alguna aserción en la base de datos.[fn:271]

En nuestro sistema, una consulta toma un flujo de entrada de marcos y realiza la operación de coincidencia anterior para cada marco en el flujo, como se indica en la [[figure-4.4][Figura 4.4]]. Es decir, para cada marco en el flujo de entrada, la consulta genera un nuevo flujo que consiste en todas las extensiones a ese marco mediante coincidencias con aserciones en la base de datos. Todos estos flujos se combinan entonces para formar un flujo enorme, que contiene todas las extensiones posibles de cada marco en el flujo de entrada. Este flujo es la salida de la consulta.

<<figure-4.4>> Una consulta procesa un flujo de marcos.

#+begin_example
                                   output stream
   input stream   +-------------+  of frames,
   of frames      |    query    |  filtered and extended
 ---------------->|             +------------------------->
                  | (job ?x ?y) |
                  +-------------+
                         ^
                         |
                stream of assertions
                   from data base
#+end_example

Para responder una consulta simple, usamos la consulta con un flujo de entrada que consiste en un solo marco vacío. El flujo de salida resultante contiene todas las extensiones al marco vacío (es decir, todas las respuestas a nuestra consulta). Este flujo de marcos se usa entonces para generar un flujo de copias del patrón de consulta original con las variables instanciadas por los valores en cada marco, y este es el flujo que finalmente se imprime.

*Consultas compuestas*

La verdadera elegancia de la implementación de flujo de marcos es evidente cuando tratamos con consultas compuestas. El procesamiento de consultas compuestas hace uso de la capacidad de nuestro emparejador para exigir que una coincidencia sea consistente con un marco especificado. Por ejemplo, para manejar el ~and~ de dos consultas, como

#+begin_src scheme
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
#+end_src

(informalmente, "Encuentra todas las personas que pueden hacer el trabajo de aprendiz de programador informático"), primero encontramos todas las entradas que coinciden con el patrón

#+begin_src scheme
(can-do-job ?x (computer programmer trainee))
#+end_src

Esto produce un flujo de marcos, cada uno de los cuales contiene una vinculación para ~?x~. Luego, para cada marco en el flujo, encontramos todas las entradas que coinciden con

#+begin_src scheme
(job ?person ?x)
#+end_src

de una manera que sea consistente con la vinculación dada para ~?x~. Cada coincidencia de este tipo producirá un marco que contiene vinculaciones para ~?x~ y ~?person~. El ~and~ de dos consultas puede verse como una combinación en serie de las dos consultas componentes, como se muestra en la [[figure-4.5][Figura 4.5]]. Los marcos que pasan a través del primer filtro de consulta son filtrados y extendidos aún más por la segunda consulta.

<<figure-4.5>> La combinación ~and~ de dos consultas se produce operando en el flujo de marcos en serie.

#+begin_example
                 +----------------------+
                 |       (and A B)      |
   input stream  |                      |  output stream
   of frames     |   +---+       +---+  |  of frames
 ------------------->| A +------>| B +-------------------->
                 |   +---+       +---+  |
                 |     ^           ^    |
                 |     |           |    |
                 |     +-----*-----+    |
                 +-----------|----------+
                             |
                         data base
#+end_example

La [[figure-4.6][Figura 4.6]] muestra el método análogo para calcular el ~or~ de dos consultas como una combinación paralela de las dos consultas componentes. El flujo de entrada de marcos se extiende por separado mediante cada consulta. Los dos flujos resultantes se fusionan entonces para producir el flujo de salida final.

<<figure-4.6>> La combinación ~or~ de dos consultas se produce operando en el flujo de marcos en paralelo y fusionando los resultados.

#+begin_example
            +---------------------------+
            |          (or A B)         |
            |    +---+                  |
 input      | +->| A |------------+     |  output
 stream of  | |  +---+            V     |  stream of
 frames     | |    ^          +-------+ |  frames
 -------------*    |          | merge +--------------->
            | |    |          +-------+ |
            | |    |              ^     |
            | |    |   +---+      |     |
            | +------->| B +------+     |
            |      |   +---+            |
            |      |     ^              |
            |      |     |              |
            |      +--*--+              |
            +---------|-----------------+
                      |
                  data base
#+end_example

Incluso a partir de esta descripción de alto nivel, es evidente que el procesamiento de consultas compuestas puede ser lento. Por ejemplo, dado que una consulta puede producir más de un marco de salida para cada marco de entrada, y cada consulta en un ~and~ obtiene sus marcos de entrada de la consulta anterior, una consulta ~and~ podría, en el peor de los casos, tener que realizar un número de coincidencias que es exponencial en el número de consultas (véase el [[#exercise-4.76][Ejercicio 4.76]]).[fn:272] Aunque los sistemas para manejar solo consultas simples son bastante prácticos, tratar con consultas complejas es extremadamente difícil.[fn:273]

Desde el punto de vista del flujo de marcos, el ~not~ de alguna consulta actúa como un filtro que elimina todos los marcos para los cuales la consulta puede ser satisfecha. Por ejemplo, dado el patrón

#+begin_src scheme
(not (job ?x (computer programmer)))
#+end_src

intentamos, para cada marco en el flujo de entrada, producir marcos de extensión que satisfagan ~(job ?x (computer programmer))~. Eliminamos del flujo de entrada todos los marcos para los cuales tales extensiones existen. El resultado es un flujo que consiste solo en aquellos marcos en los que la vinculación para ~?x~ no satisface ~(job ?x (computer programmer))~. Por ejemplo, al procesar la consulta

#+begin_src scheme
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
#+end_src

la primera cláusula generará marcos con vinculaciones para ~?x~ y ~?y~. La cláusula ~not~ entonces filtrará estos eliminando todos los marcos en los que la vinculación para ~?x~ satisface la restricción de que ~?x~ es un programador informático.[fn:274]

La forma especial ~lisp-value~ se implementa como un filtro similar en flujos de marcos. Usamos cada marco en el flujo para instanciar cualquier variable en el patrón, luego aplicamos el predicado de Lisp. Eliminamos del flujo de entrada todos los marcos para los cuales el predicado falla.

*Unificación*

Para manejar reglas en el lenguaje de consultas, debemos ser capaces de encontrar las reglas cuyas conclusiones coinciden con un patrón de consulta dado. Las conclusiones de las reglas son como aserciones excepto que pueden contener variables, por lo que necesitaremos una generalización del emparejamiento de patrones--llamada <<i412>> unificación--en la que tanto el "patrón" como el "dato" pueden contener variables.

Un unificador toma dos patrones, cada uno conteniendo constantes y variables, y determina si es posible asignar valores a las variables que harán que los dos patrones sean iguales. Si es así, devuelve un marco que contiene estas vinculaciones. Por ejemplo, unificar ~(?x a ?y)~ y ~(?y ?z a)~ especificará un marco en el que ~?x~, ~?y~, y ~?z~ deben estar todos vinculados a ~a~. Por otro lado, unificar ~(?x ?y a)~ y ~(?x b ?y)~ fallará, porque no hay valor para ~?y~ que pueda hacer que los dos patrones sean iguales. (Para que los segundos elementos de los patrones sean iguales, ~?y~ tendría que ser ~b~; sin embargo, para que los terceros elementos sean iguales, ~?y~ tendría que ser ~a~.) El unificador usado en el sistema de consultas, como el emparejador de patrones, toma un marco como entrada y realiza unificaciones que son consistentes con este marco.

El algoritmo de unificación es la parte técnicamente más difícil del sistema de consultas. Con patrones complejos, realizar la unificación puede parecer requerir deducción. Para unificar ~(?x ?x)~ y ~((a ?y c) (a b ?z))~, por ejemplo, el algoritmo debe inferir que ~?x~ debería ser ~(a b c)~, ~?y~ debería ser ~b~, y ~?z~ debería ser ~c~. Podemos pensar en este proceso como resolver un conjunto de ecuaciones entre los componentes del patrón. En general, estas son ecuaciones simultáneas, que pueden requerir manipulación sustancial para resolver.[fn:275] Por ejemplo, unificar ~(?x ?x)~ y ~((a ?y c) (a b ?z))~ puede pensarse como especificar las ecuaciones simultáneas

#+begin_src scheme
?x  =  (a ?y c)
?x  =  (a b ?z)
#+end_src

Estas ecuaciones implican que

#+begin_src scheme
(a ?y c)  =  (a b ?z)
#+end_src

lo cual a su vez implica que

#+begin_src scheme
a  =  a, ?y  =  b, c  =  ?z,
#+end_src

y por lo tanto que

#+begin_src scheme
?x  =  (a b c)
#+end_src

En un emparejamiento de patrones exitoso, todas las variables de patrón quedan vinculadas, y los valores a los que están vinculadas contienen solo constantes. Esto también es cierto para todos los ejemplos de unificación que hemos visto hasta ahora. En general, sin embargo, una unificación exitosa puede no determinar completamente los valores de las variables; algunas variables pueden permanecer sin vincular y otras pueden estar vinculadas a valores que contienen variables.

Considera la unificación de ~(?x a)~ y ~((b ?y) ?z)~. Podemos deducir que ~?x = (b ?y)~ y ~a = ?z~, pero no podemos resolver más para ~?x~ o ~?y~. La unificación no falla, ya que ciertamente es posible hacer que los dos patrones sean iguales asignando valores a ~?x~ y ~?y~. Dado que esta coincidencia de ninguna manera restringe los valores que ~?y~ puede tomar, no se coloca ninguna vinculación para ~?y~ en el marco de resultado. Sin embargo, la coincidencia sí restringe el valor de ~?x~. Cualquiera que sea el valor de ~?y~, ~?x~ debe ser ~(b ?y)~. Por lo tanto, se coloca una vinculación de ~?x~ al patrón ~(b ?y)~ en el marco. Si un valor para ~?y~ se determina posteriormente y se añade al marco (mediante un emparejamiento de patrones o unificación que debe ser consistente con este marco), el ~?x~ previamente vinculado se referirá a este valor.[fn:276]

*Aplicación de reglas*

La unificación es la clave para el componente del sistema de consultas que hace inferencias a partir de reglas. Para ver cómo se logra esto, considera el procesamiento de una consulta que involucra aplicar una regla, como

#+begin_src scheme
(lives-near ?x (Hacker Alyssa P))
#+end_src

Para procesar esta consulta, primero usamos el procedimiento ordinario de emparejamiento de patrones descrito anteriormente para ver si hay alguna aserción en la base de datos que coincida con este patrón. (No habrá ninguna en este caso, ya que nuestra base de datos no incluye aserciones directas sobre quién vive cerca de quién.) El siguiente paso es intentar unificar el patrón de consulta con la conclusión de cada regla. Encontramos que el patrón se unifica con la conclusión de la regla

#+begin_src scheme
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
#+end_src

resultando en un marco que especifica que ~?person-2~ está vinculado a ~(Hacker Alyssa P)~ y que ~?x~ debería estar vinculado a (tener el mismo valor que) ~?person-1~. Ahora, relativo a este marco, evaluamos la consulta compuesta dada por el cuerpo de la regla. Las coincidencias exitosas extenderán este marco proporcionando una vinculación para ~?person-1~, y en consecuencia un valor para ~?x~, que podemos usar para instanciar el patrón de consulta original.

En general, el evaluador de consultas usa el siguiente método para aplicar una regla cuando intenta establecer un patrón de consulta en un marco que especifica vinculaciones para algunas de las variables del patrón:

- Unificar la consulta con la conclusión de la regla para formar, si tiene éxito, una extensión del marco original.

- Relativo al marco extendido, evaluar la consulta formada por el cuerpo de la regla.

Nota cuán similar es esto al método para aplicar un procedimiento en el evaluador ~eval~/~apply~ para Lisp:

- Vincular los parámetros del procedimiento a sus argumentos para formar un marco que extiende el entorno del procedimiento original.

- Relativo al entorno extendido, evaluar la expresión formada por el cuerpo del procedimiento.

La similitud entre los dos evaluadores no debería ser una sorpresa. Así como las definiciones de procedimientos son los medios de abstracción en Lisp, las definiciones de reglas son los medios de abstracción en el lenguaje de consultas. En cada caso, desenrollamos la abstracción creando vinculaciones apropiadas y evaluando el cuerpo de la regla o procedimiento relativo a estas.

*Consultas simples*

Vimos anteriormente en esta sección cómo evaluar consultas simples en ausencia de reglas. Ahora que hemos visto cómo aplicar reglas, podemos describir cómo evaluar consultas simples usando tanto reglas como aserciones.

Dado el patrón de consulta y un flujo de marcos, producimos, para cada marco en el flujo de entrada, dos flujos:

- un flujo de marcos extendidos obtenidos emparejando el patrón con todas las aserciones en la base de datos (usando el emparejador de patrones), y

- un flujo de marcos extendidos obtenidos aplicando todas las reglas posibles (usando el unificador).[fn:277]

Añadir estos dos flujos produce un flujo que consiste en todas las formas en que el patrón dado puede ser satisfecho de manera consistente con el marco original. Estos flujos (uno para cada marco en el flujo de entrada) ahora se combinan todos para formar un gran flujo, que por lo tanto consiste en todas las formas en que cualquiera de los marcos en el flujo de entrada original puede ser extendido para producir una coincidencia con el patrón dado.

*El evaluador de consultas y el bucle del controlador*

A pesar de la complejidad de las operaciones de emparejamiento subyacentes, el sistema está organizado de manera muy similar a un evaluador para cualquier lenguaje. El procedimiento que coordina las operaciones de emparejamiento se llama ~qeval~, y desempeña un papel análogo al del procedimiento ~eval~ para Lisp. ~qeval~ toma como entradas una consulta y un flujo de marcos. Su salida es un flujo de marcos, correspondientes a coincidencias exitosas con el patrón de consulta, que extienden algún marco en el flujo de entrada, como se indica en la [[figure-4.4][Figura 4.4]]. Como ~eval~, ~qeval~ clasifica los diferentes tipos de expresiones (consultas) y despacha a un procedimiento apropiado para cada uno. Hay un procedimiento para cada forma especial (~and~, ~or~, ~not~, y ~lisp-value~) y uno para consultas simples.

El bucle del controlador, que es análogo al procedimiento ~driver-loop~ para los otros evaluadores en este capítulo, lee consultas desde el terminal. Para cada consulta, llama a ~qeval~ con la consulta y un flujo que consiste en un solo marco vacío. Esto producirá el flujo de todas las coincidencias posibles (todas las extensiones posibles al marco vacío). Para cada marco en el flujo resultante, instancia la consulta original usando los valores de las variables encontradas en el marco. Este flujo de consultas instanciadas se imprime entonces.[fn:278]

El controlador también verifica el comando especial ~assert!~, que señala que la entrada no es una consulta sino más bien una aserción o regla que se debe añadir a la base de datos. Por ejemplo,

#+begin_src scheme
(assert! (job (Bitdiddle Ben) (computer wizard)))

(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
#+end_src
