
*** 4.4.3 ¿Es la programación lógica lógica matemática?
:properties:
:custom_id: section-4.4.3
:end:

Los medios de combinación utilizados en el lenguaje de consultas pueden parecer al principio idénticos a las operaciones ~and~, ~or~ y ~not~ de la lógica matemática, y la aplicación de las reglas del lenguaje de consultas se logra de hecho mediante un método legítimo de inferencia.[fn:279] Sin embargo, esta identificación del lenguaje de consultas con la lógica matemática no es realmente válida, porque el lenguaje de consultas proporciona una <<i86>> estructura de control que interpreta las declaraciones lógicas de manera procedimental. A menudo podemos aprovechar esta estructura de control. Por ejemplo, para encontrar todos los supervisores de programadores podríamos formular una consulta en cualquiera de dos formas lógicamente equivalentes:

#+begin_src scheme
(and (job ?x (computer programmer))
     (supervisor ?x ?y))
#+end_src

o

#+begin_src scheme
(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
#+end_src

Si una empresa tiene muchos más supervisores que programadores (el caso habitual), es mejor usar la primera forma en lugar de la segunda porque la base de datos debe escanearse para cada resultado intermedio (marco) producido por la primera cláusula del ~and~.

El objetivo de la programación lógica es proporcionar al programador técnicas para descomponer un problema computacional en dos problemas separados: "qué" debe computarse y "cómo" debe computarse. Esto se logra seleccionando un subconjunto de las declaraciones de la lógica matemática que sea lo suficientemente potente como para poder describir cualquier cosa que se desee computar, pero lo suficientemente débil como para tener una interpretación procedimental controlable. La intención aquí es que, por un lado, un programa especificado en un lenguaje de programación lógica debe ser un programa efectivo que pueda ser ejecutado por una computadora. El control ("cómo" computar) se logra mediante el uso del orden de evaluación del lenguaje. Deberíamos poder organizar el orden de las cláusulas y el orden de los subobjetivos dentro de cada cláusula de modo que el cómputo se realice en un orden considerado efectivo y eficiente. Al mismo tiempo, deberíamos poder ver el resultado del cómputo ("qué" computar) como una simple consecuencia de las leyes de la lógica.

Nuestro lenguaje de consultas puede considerarse precisamente como un subconjunto de la lógica matemática que puede interpretarse procedimentalmente. Una aserción representa un hecho simple (una proposición atómica). Una regla representa la implicación de que la conclusión de la regla se cumple para aquellos casos en los que se cumple el cuerpo de la regla. Una regla tiene una interpretación procedimental natural: Para establecer la conclusión de la regla, establece el cuerpo de la regla. Las reglas, por lo tanto, especifican cómputos. Sin embargo, debido a que las reglas también pueden considerarse como declaraciones de lógica matemática, podemos justificar cualquier "inferencia" lograda por un programa lógico afirmando que el mismo resultado podría obtenerse trabajando enteramente dentro de la lógica matemática.[fn:280]

*Bucles infinitos*

Una consecuencia de la interpretación procedimental de los programas lógicos es que es posible construir programas desesperadamente ineficientes para resolver ciertos problemas. Un caso extremo de ineficiencia ocurre cuando el sistema cae en bucles infinitos al hacer deducciones. Como ejemplo simple, supongamos que estamos configurando una base de datos de matrimonios famosos, incluyendo

#+begin_src scheme
(assert! (married Minnie Mickey))
#+end_src

Si ahora preguntamos

#+begin_src scheme
(married Mickey ?who)
#+end_src

no obtendremos respuesta, porque el sistema no sabe que si A está casado con B, entonces B está casado con A. Así que afirmamos la regla

#+begin_src scheme
(assert! (rule (married ?x ?y)
               (married ?y ?x)))
#+end_src

y consultamos nuevamente

#+begin_src scheme
(married Mickey ?who)
#+end_src

Desafortunadamente, esto llevará al sistema a un bucle infinito, de la siguiente manera:

- El sistema encuentra que la regla ~married~ es aplicable; es decir, la conclusión de la regla ~(married ?x ?y)~ se unifica exitosamente con el patrón de consulta ~(married Mickey ?who)~ para producir un marco en el que ~?x~ está ligado a ~Mickey~ y ~?y~ está ligado a ~?who~. Entonces el intérprete procede a evaluar el cuerpo de la regla ~(married ?y ?x)~ en este marco—en efecto, a procesar la consulta ~(married ?who Mickey)~.

- Una respuesta aparece directamente como una aserción en la base de datos: ~(married Minnie Mickey)~.

- La regla ~married~ también es aplicable, por lo que el intérprete nuevamente evalúa el cuerpo de la regla, que esta vez es equivalente a ~(married Mickey ?who)~.

El sistema está ahora en un bucle infinito. De hecho, si el sistema encontrará la respuesta simple ~(married Minnie Mickey)~ antes de entrar en el bucle depende de detalles de implementación concernientes al orden en el que el sistema verifica los elementos en la base de datos. Este es un ejemplo muy simple de los tipos de bucles que pueden ocurrir. Colecciones de reglas interrelacionadas pueden conducir a bucles que son mucho más difíciles de anticipar, y la aparición de un bucle puede depender del orden de las cláusulas en un ~and~ (véase [[#exercise-4.64][Ejercicio 4.64]]) o de detalles de bajo nivel concernientes al orden en el que el sistema procesa las consultas.[fn:281]

*Problemas con 'not'*

Otra peculiaridad en el sistema de consultas concierne a ~not~. Dada la base de datos de la sección [[#section-4.4.1][4.4.1]], considera las siguientes dos consultas:

#+begin_src scheme
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))

(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
#+end_src

Estas dos consultas no producen el mismo resultado. La primera consulta comienza encontrando todas las entradas en la base de datos que coinciden con ~(supervisor ?x ?y)~, y luego filtra los marcos resultantes eliminando aquellos en los que el valor de ~?x~ satisface ~(job ?x (computer programmer))~. La segunda consulta comienza filtrando los marcos entrantes para eliminar aquellos que pueden satisfacer ~(job ?x (computer programmer))~. Dado que el único marco entrante está vacío, verifica la base de datos para ver si hay algún patrón que satisfaga ~(job ?x (computer programmer))~. Dado que generalmente hay entradas de esta forma, la cláusula ~not~ filtra el marco vacío y devuelve un flujo vacío de marcos. Consecuentemente, toda la consulta compuesta devuelve un flujo vacío.

El problema es que nuestra implementación de ~not~ realmente está destinada a servir como un filtro sobre valores para las variables. Si una cláusula ~not~ se procesa con un marco en el que algunas de las variables permanecen sin ligar (como sucede con ~?x~ en el ejemplo anterior), el sistema producirá resultados inesperados. Problemas similares ocurren con el uso de ~lisp-value~—el predicado Lisp no puede funcionar si algunos de sus argumentos están sin ligar. Véase [[#exercise-4.77][Ejercicio 4.77]].

También hay una manera mucho más seria en la que el ~not~ del lenguaje de consultas difiere del ~not~ de la lógica matemática. En lógica, interpretamos la declaración "not P" para significar que P no es verdadero. En el sistema de consultas, sin embargo, "not P" significa que P no es deducible del conocimiento en la base de datos. Por ejemplo, dada la base de datos de personal de la sección [[#section-4.4.1][4.4.1]], el sistema deduciría alegremente todo tipo de declaraciones ~not~, tales como que Ben Bitdiddle no es un aficionado al béisbol, que no está lloviendo afuera, y que 2 + 2 no es 4.[fn:282] En otras palabras, el ~not~ de los lenguajes de programación lógica refleja la llamada <<i61>> suposición del mundo cerrado de que toda la información relevante ha sido incluida en la base de datos.[fn:283]

**** Ejercicio 4.64
:properties:
:custom_id: exercise-4.64
:end:

Louis Reasoner elimina por error la regla ~outranked-by~ (sección [[#section-4.4.1][4.4.1]]) de la base de datos. Cuando se da cuenta de esto, rápidamente la reinstala. Desafortunadamente, hace un ligero cambio en la regla y la escribe como

#+begin_src scheme
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
#+end_src

Justo después de que Louis escribe esta información en el sistema, DeWitt Aull viene para averiguar quién supera a Ben Bitdiddle. Emite la consulta

#+begin_src scheme
(outranked-by (Bitdiddle Ben) ?who)
#+end_src

Después de responder, el sistema entra en un bucle infinito. Explica por qué.

**** Ejercicio 4.65
:properties:
:custom_id: exercise-4.65
:end:

Cy D. Fect, esperando el día en que ascenderá en la organización, realiza una consulta para encontrar todos los "wheels" (usando la regla ~wheel~ de la sección [[#section-4.4.1][4.4.1]]):

#+begin_src scheme
(wheel ?who)
#+end_src

Para su sorpresa, el sistema responde

#+begin_src scheme
;;; Query results:
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
#+end_src

¿Por qué Oliver Warbucks aparece listado cuatro veces?

**** Ejercicio 4.66
:properties:
:custom_id: exercise-4.66
:end:

Ben ha estado generalizando el sistema de consultas para proporcionar estadísticas sobre la empresa. Por ejemplo, para encontrar los salarios totales de todos los programadores de computadoras uno podrá decir

#+begin_src scheme
(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))
#+end_src

En general, el nuevo sistema de Ben permite expresiones de la forma

#+begin_src scheme
(accumulation-function <VARIABLE>
                       <QUERY PATTERN>)
#+end_src

donde ~accumulation-function~ puede ser cosas como ~sum~, ~average~ o ~maximum~. Ben razona que debería ser pan comido implementar esto. Simplemente alimentará el patrón de consulta a ~qeval~. Esto producirá un flujo de marcos. Luego pasará este flujo a través de una función de mapeo que extrae el valor de la variable designada de cada marco en el flujo y alimentará el flujo resultante de valores a la función de acumulación. Justo cuando Ben completa la implementación y está a punto de probarla, Cy pasa, todavía perplejo por el resultado de la consulta ~wheel~ en el ejercicio [[#exercise-4.65][Ejercicio 4.65]]. Cuando Cy le muestra a Ben la respuesta del sistema, Ben gime, "¡Oh, no, mi simple esquema de acumulación no funcionará!"

¿Qué acaba de darse cuenta Ben? Esboza un método que pueda usar para salvar la situación.

**** Ejercicio 4.67
:properties:
:custom_id: exercise-4.67
:end:

Diseña una manera de instalar un detector de bucles en el sistema de consultas para evitar los tipos de bucles simples ilustrados en el texto y en [[#exercise-4.64][Ejercicio 4.64]]. La idea general es que el sistema debe mantener algún tipo de historial de su cadena actual de deducciones y no debe comenzar a procesar una consulta en la que ya está trabajando. Describe qué tipo de información (patrones y marcos) se incluye en este historial, y cómo debe hacerse la verificación. (Después de estudiar los detalles de la implementación del sistema de consultas en la sección [[#section-4.4.4][4.4.4]], es posible que desees modificar el sistema para incluir tu detector de bucles.)

**** Ejercicio 4.68
:properties:
:custom_id: exercise-4.68
:end:

Define reglas para implementar la operación ~reverse~ del [[#exercise-2.18][Ejercicio 2.18]], que devuelve una lista que contiene los mismos elementos que una lista dada en orden inverso. (Sugerencia: Usa ~append-to-form~.) ¿Pueden tus reglas responder tanto ~(reverse (1 2 3) ?x)~ como ~(reverse ?x (1 2 3))~?

**** Ejercicio 4.69
:properties:
:custom_id: exercise-4.69
:end:

Comenzando con la base de datos y las reglas que formulaste en [[#exercise-4.63][Ejercicio 4.63]], diseña una regla para agregar "greats" a una relación de nieto. Esto debería permitir al sistema deducir que Irad es el bisnieto de Adam, o que Jabal y Jubal son los tatara-tatara-tatara-nietos de Adam. (Sugerencia: Representa el hecho sobre Irad, por ejemplo, como ~((great grandson) Adam Irad)~. Escribe reglas que determinen si una lista termina en la palabra ~grandson~. Usa esto para expresar una regla que permita derivar la relación ~((great . ?rel) ?x ?y)~, donde ~?rel~ es una lista que termina en ~grandson~.) Verifica tus reglas en consultas tales como ~((great grandson) ?g ?ggs)~ y ~(?relationship Adam Irad)~.

