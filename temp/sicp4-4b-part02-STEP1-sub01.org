*** 4.4.4 Implementación del Sistema de Consultas
:properties:
:custom_id: section-4.4.4
:end:

La sección [[#section-4.4.2][4.4.2]] describió cómo funciona el sistema de consultas. Ahora completamos los detalles presentando una implementación completa del sistema.

**** 4.4.4.1 El Bucle Conductor y la Instanciación
:properties:
:custom_id: section-4.4.4.1
:end:

El bucle conductor del sistema de consultas lee repetidamente expresiones de entrada. Si la expresión es una regla o aserción a añadir a la base de datos, entonces se añade la información. De lo contrario, se asume que la expresión es una consulta. El conductor pasa esta consulta al evaluador ~qeval~ junto con un flujo de marcos inicial que consiste en un único marco vacío. El resultado de la evaluación es un flujo de marcos generado al satisfacer la consulta con valores de variables encontrados en la base de datos. Estos marcos se usan para formar un nuevo flujo que consiste en copias de la consulta original en la que las variables se instancian con valores proporcionados por el flujo de marcos, y este flujo final se imprime en el terminal:

#+begin_src scheme
(define input-prompt ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate q
                   frame
                 (lambda (v f)
                   (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
#+end_src

Aquí, como en los otros evaluadores en este capítulo, usamos una sintaxis abstracta para las expresiones del lenguaje de consultas. La implementación de la sintaxis de expresiones, incluyendo el predicado ~assertion-to-be-added?~ y el selector ~add-assertion-body~, se da en la sección [[#section-4.4.4.7][4.4.4.7]]. ~add-rule-or-assertion!~ se define en la sección [[#section-4.4.4.5][4.4.4.5]].

Antes de hacer cualquier procesamiento en una expresión de entrada, el bucle conductor la transforma sintácticamente en una forma que hace el procesamiento más eficiente. Esto implica cambiar la representación de las variables de patrón. Cuando se instancia la consulta, cualquier variable que permanece sin ligar se transforma de nuevo a la representación de entrada antes de ser impresa. Estas transformaciones se realizan mediante los dos procedimientos ~query-syntax-process~ y ~contract-question-mark~ (sección [[#section-4.4.4.7][4.4.4.7]]).

Para instanciar una expresión, la copiamos, reemplazando cualquier variable en la expresión por sus valores en un marco dado. Los valores son ellos mismos instanciados, ya que podrían contener variables (por ejemplo, si ~?x~ en ~exp~ está ligada a ~?y~ como resultado de la unificación y ~?y~ está a su vez ligada a 5). La acción a tomar si una variable no puede ser instanciada se da mediante un argumento procedimental a ~instantiate~.

#+begin_src scheme
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
#+end_src

Los procedimientos que manipulan ligaduras se definen en la sección [[#section-4.4.4.8][4.4.4.8]].

