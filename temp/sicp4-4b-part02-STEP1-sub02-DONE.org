**** 4.4.4.2 El Evaluador
:properties:
:custom_id: section-4.4.4.2
:end:

El procedimiento ~qeval~, llamado por ~query-driver-loop~, es el evaluador básico del sistema de consultas. Toma como entradas una consulta y un flujo de marcos, y devuelve un flujo de marcos extendidos. Identifica formas especiales mediante un despacho dirigido por datos usando ~get~ y ~put~, tal como lo hicimos al implementar operaciones genéricas en el [[#section-2][Capítulo 2]]. Cualquier consulta que no se identifique como una forma especial se asume que es una consulta simple, a ser procesada por ~simple-query~.

#+begin_src scheme
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
#+end_src

~type~ y ~contents~, definidos en la sección [[#section-4.4.4.7][4.4.4.7]], implementan la sintaxis abstracta de las formas especiales.

*Consultas simples*

El procedimiento ~simple-query~ maneja consultas simples. Toma como argumentos una consulta simple (un patrón) junto con un flujo de marcos, y devuelve el flujo formado al extender cada marco mediante todas las coincidencias en la base de datos de la consulta.

#+begin_src scheme
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
#+end_src

Para cada marco en el flujo de entrada, usamos ~find-assertions~ (sección [[#section-4.4.4.3][4.4.4.3]]) para emparejar el patrón contra todas las aserciones en la base de datos, produciendo un flujo de marcos extendidos, y usamos ~apply-rules~ (sección [[#section-4.4.4.4][4.4.4.4]]) para aplicar todas las reglas posibles, produciendo otro flujo de marcos extendidos. Estos dos flujos se combinan (usando ~stream-append-delayed~, sección [[#section-4.4.4.6][4.4.4.6]]) para hacer un flujo de todas las formas en que el patrón dado puede ser satisfecho de manera consistente con el marco original (ver [[#exercise-4.71][Ejercicio 4.71]]). Los flujos para los marcos de entrada individuales se combinan usando ~stream-flatmap~ (sección [[#section-4.4.4.6][4.4.4.6]]) para formar un gran flujo de todas las formas en que cualquiera de los marcos en el flujo de entrada original puede ser extendido para producir una coincidencia con el patrón dado.

*Consultas compuestas*

Las consultas ~and~ se manejan como se ilustra en la [[figure-4.5][Figura 4.5]] mediante el procedimiento ~conjoin~. ~conjoin~ toma como entradas los conjuntos y el flujo de marcos y devuelve el flujo de marcos extendidos. Primero, ~conjoin~ procesa el flujo de marcos para encontrar el flujo de todas las extensiones de marco posibles que satisfagan la primera consulta en la conjunción. Luego, usando esto como el nuevo flujo de marcos, aplica recursivamente ~conjoin~ al resto de las consultas.

#+begin_src scheme
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
#+end_src

La expresión

#+begin_src scheme
(put 'and 'qeval conjoin)
#+end_src

configura ~qeval~ para despachar a ~conjoin~ cuando se encuentra una forma ~and~.

Las consultas ~or~ se manejan de manera similar, como se muestra en la [[figure-4.6][Figura 4.6]]. Los flujos de salida para los diversos disyuntos del ~or~ se calculan por separado y se fusionan usando el procedimiento ~interleave-delayed~ de la sección [[#section-4.4.4.6][4.4.4.6]]. (Ver [[#exercise-4.71][Ejercicio 4.71]] y [[#exercise-4.72][Ejercicio 4.72]].)

#+begin_src scheme
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))

(put 'or 'qeval disjoin)
#+end_src

Los predicados y selectores para la sintaxis de conjuntos y disyuntos se dan en la sección [[#section-4.4.4.7][4.4.4.7]].

*Filtros*

~not~ se maneja mediante el método delineado en la sección [[#section-4.4.2][4.4.2]]. Intentamos extender cada marco en el flujo de entrada para satisfacer la consulta que se niega, e incluimos un marco dado en el flujo de salida solo si no puede ser extendido.

#+begin_src scheme
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'not 'qeval negate)
#+end_src

~lisp-value~ es un filtro similar a ~not~. Cada marco en el flujo se usa para instanciar las variables en el patrón, se aplica el predicado indicado, y los marcos para los cuales el predicado devuelve falso se filtran del flujo de entrada. Resulta un error si hay variables de patrón sin ligar.

#+begin_src scheme
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
              call
              frame
            (lambda (v f)
              (error "Variable de patrón desconocida - LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'lisp-value 'qeval lisp-value)
#+end_src

~execute~, que aplica el predicado a los argumentos, debe evaluar (~eval~) la expresión predicado para obtener el procedimiento a aplicar. Sin embargo, no debe evaluar los argumentos, ya que ya son los argumentos reales, no expresiones cuya evaluación (en Lisp) producirá los argumentos. Nótese que ~execute~ se implementa usando ~eval~ y ~apply~ del sistema Lisp subyacente.

#+begin_src scheme
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
#+end_src

La forma especial ~always-true~ proporciona una consulta que siempre se satisface. Ignora su contenido (normalmente vacío) y simplemente pasa todos los marcos en el flujo de entrada. ~always-true~ se usa por el selector ~rule-body~ (sección [[#section-4.4.4.7][4.4.4.7]]) para proporcionar cuerpos para reglas que fueron definidas sin cuerpos (es decir, reglas cuyas conclusiones siempre se satisfacen).

#+begin_src scheme
(define (always-true ignore frame-stream) frame-stream)

(put 'always-true 'qeval always-true)
#+end_src

Los selectores que definen la sintaxis de ~not~ y ~lisp-value~ se dan en la sección [[#section-4.4.4.7][4.4.4.7]].

