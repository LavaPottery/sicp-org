**** 4.4.4.3 Búsqueda de Aserciones mediante Emparejamiento de Patrones
:properties:
:custom_id: section-4.4.4.3
:end:

~find-assertions~, llamado por ~simple-query~ (sección [[#section-4.4.4.2][4.4.4.2]]), toma como entrada un patrón y un marco. Devuelve un flujo de marcos, cada uno extendiendo el dado mediante una coincidencia de la base de datos del patrón dado. Usa ~fetch-assertions~ (sección [[#section-4.4.4.5][4.4.4.5]]) para obtener un flujo de todas las aserciones en la base de datos que deben verificarse para una coincidencia contra el patrón y el marco. La razón para ~fetch-assertions~ aquí es que a menudo podemos aplicar pruebas simples que eliminarán muchas de las entradas en la base de datos del conjunto de candidatos para una coincidencia exitosa. El sistema aún funcionaría si elimináramos ~fetch-assertions~ y simplemente verificáramos un flujo de todas las aserciones en la base de datos, pero el cómputo sería menos eficiente porque necesitaríamos hacer muchas más llamadas al emparejador.

#+begin_src scheme
(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
#+end_src

~check-an-assertion~ toma como argumentos un patrón, un objeto de datos (aserción), y un marco y devuelve o bien un flujo de un elemento que contiene el marco extendido o ~the-empty-stream~ si la coincidencia falla.

#+begin_src scheme
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
#+end_src

El emparejador de patrones básico devuelve o bien el símbolo ~failed~ o una extensión del marco dado. La idea básica del emparejador es verificar el patrón contra los datos, elemento por elemento, acumulando ligaduras para las variables de patrón. Si el patrón y el objeto de datos son iguales, la coincidencia tiene éxito y devolvemos el marco de ligaduras acumuladas hasta ahora. De lo contrario, si el patrón es una variable extendemos el marco actual ligando la variable a los datos, siempre que esto sea consistente con las ligaduras ya en el marco. Si el patrón y los datos son ambos pares, (recursivamente) emparejamos el ~car~ del patrón contra el ~car~ de los datos para producir un marco; en este marco luego emparejamos el ~cdr~ del patrón contra el ~cdr~ de los datos. Si ninguno de estos casos es aplicable, la coincidencia falla y devolvemos el símbolo ~failed~.

#+begin_src scheme
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
#+end_src

Aquí está el procedimiento que extiende un marco añadiendo una nueva ligadura, si esto es consistente con las ligaduras ya en el marco:

#+begin_src scheme
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
#+end_src

Si no hay ligadura para la variable en el marco, simplemente añadimos la ligadura de la variable a los datos. De lo contrario emparejamos, en el marco, los datos contra el valor de la variable en el marco. Si el valor almacenado contiene solo constantes, como debe ser si fue almacenado durante el emparejamiento de patrones por ~extend-if-consistent~, entonces la coincidencia simplemente prueba si los valores almacenado y nuevo son iguales. Si es así, devuelve el marco sin modificar; si no, devuelve una indicación de fallo. El valor almacenado puede, sin embargo, contener variables de patrón si fue almacenado durante la unificación (ver sección [[#section-4.4.4.4][4.4.4.4]]). El emparejamiento recursivo del patrón almacenado contra los nuevos datos añadirá o verificará ligaduras para las variables en este patrón. Por ejemplo, supongamos que tenemos un marco en el que ~?x~ está ligada a ~(f ?y)~ y ~?y~ no está ligada, y deseamos aumentar este marco mediante una ligadura de ~?x~ a ~(f b)~. Buscamos ~?x~ y encontramos que está ligada a ~(f ?y)~. Esto nos lleva a emparejar ~(f ?y)~ contra el nuevo valor propuesto ~(f b)~ en el mismo marco. Eventualmente esta coincidencia extiende el marco añadiendo una ligadura de ~?y~ a ~b~. ~?X~ permanece ligada a ~(f ?y)~. Nunca modificamos una ligadura almacenada y nunca almacenamos más de una ligadura para una variable dada.

Los procedimientos usados por ~extend-if-consistent~ para manipular ligaduras se definen en la sección [[#section-4.4.4.8][4.4.4.8]].

*Patrones con colas punteadas*

Si un patrón contiene un punto seguido por una variable de patrón, la variable de patrón coincide con el resto de la lista de datos (en lugar del siguiente elemento de la lista de datos), tal como uno esperaría con la notación de cola punteada descrita en el [[#exercise-2.20][Ejercicio 2.20]]. Aunque el emparejador de patrones que acabamos de implementar no busca puntos, sí se comporta como queremos. Esto es porque el primitivo ~read~ de Lisp, que es usado por ~query-driver-loop~ para leer la consulta y representarla como una estructura de lista, trata los puntos de una manera especial.

Cuando ~read~ ve un punto, en lugar de hacer que el siguiente elemento sea el siguiente elemento de una lista (el ~car~ de un ~cons~ cuyo ~cdr~ será el resto de la lista) hace que el siguiente elemento sea el ~cdr~ de la estructura de lista. Por ejemplo, la estructura de lista producida por ~read~ para el patrón ~(computer ?type)~ podría construirse evaluando la expresión ~(cons 'computer (cons '?type '()))~, y la de ~(computer .  ?type)~ podría construirse evaluando la expresión ~(cons 'computer '?type)~.

Por lo tanto, a medida que ~pattern-match~ compara recursivamente 'car's y 'cdr's de una lista de datos y un patrón que tenía un punto, eventualmente empareja la variable después del punto (que es un ~cdr~ del patrón) contra una sublista de la lista de datos, ligando la variable a esa lista. Por ejemplo, emparejar el patrón ~(computer .  ?type)~ contra ~(computer programmer trainee)~ emparejará ~?type~ contra la lista ~(programmer trainee)~.

