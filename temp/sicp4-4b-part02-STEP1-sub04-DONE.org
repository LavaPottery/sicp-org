**** 4.4.4.4 Reglas y Unificación
:properties:
:custom_id: section-4.4.4.4
:end:

~apply-rules~ es el análogo de regla de ~find-assertions~ (sección [[#section-4.4.4.3][4.4.4.3]]). Toma como entrada un patrón y un marco, y forma un flujo de marcos de extensión aplicando reglas de la base de datos. ~stream-flatmap~ mapea ~apply-a-rule~ a lo largo del flujo de reglas posiblemente aplicables (seleccionadas por ~fetch-rules~, sección [[#section-4.4.4.5][4.4.4.5]]) y combina los flujos de marcos resultantes.

#+begin_src scheme
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
#+end_src

~apply-a-rule~ aplica reglas usando el método delineado en la sección [[#section-4.4.2][4.4.2]]. Primero aumenta su marco de argumento unificando la conclusión de la regla con el patrón en el marco dado. Si esto tiene éxito, evalúa el cuerpo de la regla en este nuevo marco.

Antes de que suceda cualquiera de esto, sin embargo, el programa renombra todas las variables en la regla con nuevos nombres únicos. La razón para esto es evitar que las variables para diferentes aplicaciones de reglas se confundan entre sí. Por ejemplo, si dos reglas ambas usan una variable llamada ~?x~, entonces cada una puede añadir una ligadura para ~?x~ al marco cuando se aplica. Estos dos ~?x~'s no tienen nada que ver uno con el otro, y no deberíamos dejarnos engañar pensando que las dos ligaduras deben ser consistentes. En lugar de renombrar variables, podríamos idear una estructura de ambiente más inteligente; sin embargo, el enfoque de renombrado que hemos elegido aquí es el más directo, aunque no el más eficiente. (Ver [[#exercise-4.79][Ejercicio 4.79]].) Aquí está el procedimiento ~apply-a-rule~:

#+begin_src scheme
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
#+end_src

Los selectores ~rule-body~ y ~conclusion~ que extraen partes de una regla se definen en la sección [[#section-4.4.4.7][4.4.4.7]].

Generamos nombres de variables únicos asociando un identificador único (como un número) con cada aplicación de regla y combinando este identificador con los nombres de variables originales. Por ejemplo, si el identificador de aplicación de regla es 7, podríamos cambiar cada ~?x~ en la regla a ~?x-7~ y cada ~?y~ en la regla a ~?y-7~. (~make-new-variable~ y ~new-rule-application-id~ se incluyen con los procedimientos de sintaxis en la sección [[#section-4.4.4.7][4.4.4.7]].)

#+begin_src scheme
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
#+end_src

El algoritmo de unificación se implementa como un procedimiento que toma como entradas dos patrones y un marco y devuelve o bien el marco extendido o el símbolo ~failed~. El unificador es como el emparejador de patrones excepto que es simétrico--se permiten variables en ambos lados de la coincidencia. ~unify-match~ es básicamente lo mismo que ~pattern-match~, excepto que hay código extra (marcado "~***~" abajo) para manejar el caso donde el objeto en el lado derecho de la coincidencia es una variable.

#+begin_src scheme
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame)) ; ***
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
#+end_src

En la unificación, como en el emparejamiento de patrones unilateral, queremos aceptar una extensión propuesta del marco solo si es consistente con las ligaduras existentes. El procedimiento ~extend-if-possible~ usado en la unificación es el mismo que el ~extend-if-consistent~ usado en el emparejamiento de patrones excepto por dos verificaciones especiales, marcadas "~***~" en el programa abajo. En el primer caso, si la variable que estamos tratando de emparejar no está ligada, pero el valor que estamos tratando de emparejarla es en sí mismo una variable (diferente), es necesario verificar si el valor está ligado, y si es así, emparejar su valor. Si ambas partes de la coincidencia no están ligadas, podemos ligar cualquiera a la otra.

La segunda verificación trata con intentos de ligar una variable a un patrón que incluye esa variable. Tal situación puede ocurrir siempre que una variable se repite en ambos patrones. Consideremos, por ejemplo, unificar los dos patrones ~(?x ?x)~ y '(?y <EXPRESIÓN QUE INVOLUCRA ~?Y~>)' en un marco donde tanto ~?x~ como ~?y~ no están ligadas. Primero ~?x~ se empareja contra ~?y~, haciendo una ligadura de ~?x~ a ~?y~. Luego, la misma ~?x~ se empareja contra la expresión dada que involucra ~?y~. Dado que ~?x~ ya está ligada a ~?y~, esto resulta en emparejar ~?y~ contra la expresión. Si pensamos en el unificador como encontrando un conjunto de valores para las variables de patrón que hacen los patrones iguales, entonces estos patrones implican instrucciones para encontrar una ~?y~ tal que ~?y~ sea igual a la expresión que involucra ~?y~. No hay un método general para resolver tales ecuaciones, así que rechazamos tales ligaduras; estos casos son reconocidos por el predicado ~depends-on?~.[fn:284] Por otro lado, no queremos rechazar intentos de ligar una variable a sí misma. Por ejemplo, consideremos unificar ~(?x ?x)~ y ~(?y ?y)~. El segundo intento de ligar ~?x~ a ~?y~ empareja ~?y~ (el valor almacenado de ~?x~) contra ~?y~ (el nuevo valor de ~?x~). Esto se maneja mediante la cláusula ~equal?~ de ~unify-match~.

#+begin_src scheme
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                   ; ***
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)  ; ***
           'failed)
          (else (extend var val frame)))))
#+end_src

~depends-on?~ es un predicado que prueba si una expresión propuesta para ser el valor de una variable de patrón depende de la variable. Esto debe hacerse en relación al marco actual porque la expresión puede contener ocurrencias de una variable que ya tiene un valor que depende de nuestra variable de prueba. La estructura de ~depends-on?~ es un simple recorrido recursivo de árbol en el que sustituimos los valores de las variables cuando es necesario.

#+begin_src scheme
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
#+end_src

