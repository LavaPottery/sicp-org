**** Ejercicio 4.74
:properties:
:custom_id: exercise-4.74
:end:

Alyssa P. Hacker propone usar una versión más simple de ~stream-flatmap~ en ~negate~, ~lisp-value~, y ~find-assertions~. Ella observa que el procedimiento que se mapea sobre el flujo de marcos en estos casos siempre produce o bien el flujo vacío o un flujo singleton, por lo que no se necesita intercalado al combinar estos flujos.

a. Completa las expresiones faltantes en el programa de Alyssa.

#+begin_src scheme
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map <??>
              (stream-filter <??> stream)))
#+end_src

b. ¿Cambia el comportamiento del sistema de consultas si lo cambiamos de esta manera?

**** Ejercicio 4.75
:properties:
:custom_id: exercise-4.75
:end:

Implementa para el lenguaje de consultas una nueva forma especial llamada ~unique~. ~unique~ debe tener éxito si hay precisamente un elemento en la base de datos que satisface una consulta especificada. Por ejemplo,

#+begin_src scheme
(unique (job ?x (computer wizard)))
#+end_src

debe imprimir el flujo de un elemento

#+begin_src scheme
(unique (job (Bitdiddle Ben) (computer wizard)))
#+end_src

ya que Ben es el único mago de computadoras, y

#+begin_src scheme
(unique (job ?x (computer programmer)))
#+end_src

debe imprimir el flujo vacío, ya que hay más de un programador de computadoras. Además,

#+begin_src scheme
(and (job ?x ?j) (unique (job ?anyone ?j)))
#+end_src

debe listar todos los trabajos que son ocupados por solo una persona, y las personas que los ocupan.

Hay dos partes para implementar ~unique~. La primera es escribir un procedimiento que maneje esta forma especial, y la segunda es hacer que ~qeval~ despache a ese procedimiento. La segunda parte es trivial, ya que ~qeval~ hace su despacho de una manera dirigida por datos. Si tu procedimiento se llama ~uniquely-asserted~, todo lo que necesitas hacer es

#+begin_src scheme
(put 'unique 'qeval uniquely-asserted)
#+end_src

y ~qeval~ despachará a este procedimiento para cada consulta cuyo ~type~ (~car~) sea el símbolo ~unique~.

El problema real es escribir el procedimiento ~uniquely-asserted~. Este debe tomar como entrada el ~contents~ (~cdr~) de la consulta ~unique~, junto con un flujo de marcos. Para cada marco en el flujo, debe usar ~qeval~ para encontrar el flujo de todas las extensiones al marco que satisfagan la consulta dada. Cualquier flujo que no tenga exactamente un elemento en él debe ser eliminado. Los flujos restantes deben pasarse de vuelta para ser acumulados en un gran flujo que es el resultado de la consulta ~unique~. Esto es similar a la implementación de la forma especial ~not~.

Prueba tu implementación formando una consulta que liste todas las personas que supervisan precisamente a una persona.

