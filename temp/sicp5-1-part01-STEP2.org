* 5 Computación con Máquinas de Registros
:properties:
:custom_id: section-5
:end:
** Introducción
:properties:
:VISIBILITY: notoc
:end:

#+begin_quote
Mi objetivo es mostrar que la máquina celestial no es una especie de ser divino y viviente, sino una especie de mecanismo de relojería (y quien cree que un reloj tiene alma atribuye la gloria del creador a la obra), en la medida en que casi todos los múltiples movimientos son causados por una fuerza muy simple y material, así como todos los movimientos del reloj son causados por un solo peso.

Johannes Kepler (carta a Herwart von Hohenburg, 1605)
#+end_quote

Comenzamos este libro estudiando procesos y describiendo procesos en términos de procedimientos escritos en Lisp. Para explicar los significados de estos procedimientos, utilizamos una sucesión de modelos de evaluación: el modelo de sustitución del [[#section-1][Capítulo 1]], el modelo de entornos del [[#section-3][Capítulo 3]], y el evaluador metacircular del [[#section-4][Capítulo 4]]. Nuestro examen del evaluador metacircular, en particular, disipó gran parte del misterio de cómo se interpretan los lenguajes tipo Lisp. Pero incluso el evaluador metacircular deja preguntas importantes sin respuesta, porque no logra elucidar los mecanismos de control en un sistema Lisp. Por ejemplo, el evaluador no explica cómo la evaluación de una subexpresión logra devolver un valor a la expresión que usa este valor, ni tampoco el evaluador explica cómo algunos procedimientos recursivos generan procesos iterativos (es decir, se evalúan usando espacio constante) mientras que otros procedimientos recursivos generan procesos recursivos. Estas preguntas permanecen sin respuesta porque el evaluador metacircular es en sí mismo un programa Lisp y por lo tanto hereda la estructura de control del sistema Lisp subyacente. Para proporcionar una descripción más completa de la estructura de control del evaluador Lisp, debemos trabajar a un nivel más primitivo que Lisp mismo.

En este capítulo describiremos procesos en términos de la operación paso a paso de una computadora tradicional. Tal computadora, o <<i330>> máquina de registros, ejecuta secuencialmente <<i188>> instrucciones que manipulan el contenido de un conjunto fijo de elementos de almacenamiento llamados <<i332>> registros. Una instrucción típica de una máquina de registros aplica una operación primitiva al contenido de algunos registros y asigna el resultado a otro registro. Nuestras descripciones de procesos ejecutados por máquinas de registros se parecerán mucho a programas en "lenguaje de máquina" para computadoras tradicionales. Sin embargo, en lugar de enfocarnos en el lenguaje de máquina de cualquier computadora en particular, examinaremos varios procedimientos Lisp y diseñaremos una máquina de registros específica para ejecutar cada procedimiento. Por lo tanto, abordaremos nuestra tarea desde la perspectiva de un arquitecto de hardware en lugar de la de un programador de computadoras en lenguaje de máquina. Al diseñar máquinas de registros, desarrollaremos mecanismos para implementar construcciones de programación importantes como la recursión. También presentaremos un lenguaje para describir diseños de máquinas de registros. En la sección [[#section-5.2][5.2]] implementaremos un programa Lisp que utiliza estas descripciones para simular las máquinas que diseñamos.

La mayoría de las operaciones primitivas de nuestras máquinas de registros son muy simples. Por ejemplo, una operación podría sumar los números obtenidos de dos registros, produciendo un resultado que se almacenará en un tercer registro. Tal operación puede ser realizada por hardware fácilmente descrito. Sin embargo, para tratar con la estructura de listas, también usaremos las operaciones de memoria ~car~, ~cdr~ y ~cons~, que requieren un elaborado mecanismo de asignación de almacenamiento. En la sección [[#section-5.3][5.3]] estudiamos su implementación en términos de operaciones más elementales.

En la sección [[#section-5.4][5.4]], después de haber acumulado experiencia formulando procedimientos simples como máquinas de registros, diseñaremos una máquina que lleve a cabo el algoritmo descrito por el evaluador metacircular de la sección [[#section-4.1][4.1]]. Esto llenará el vacío en nuestra comprensión de cómo se interpretan las expresiones Scheme, proporcionando un modelo explícito para los mecanismos de control en el evaluador. En la sección [[#section-5.5][5.5]] estudiaremos un compilador simple que traduce programas Scheme en secuencias de instrucciones que pueden ser ejecutadas directamente con los registros y operaciones de la máquina de registros del evaluador.

** 5.1 Diseño de Máquinas de Registros
:properties:
:custom_id: section-5.1
:end:

Para diseñar una máquina de registros, debemos diseñar sus <<i95>> rutas de datos (registros y operaciones) y el <<i87>> controlador que secuencia estas operaciones. Para ilustrar el diseño de una máquina de registros simple, examinemos el Algoritmo de Euclides, que se usa para calcular el máximo común divisor (GCD) de dos enteros. Como vimos en la sección [[#section-1.2.5][1.2.5]], el Algoritmo de Euclides puede llevarse a cabo mediante un proceso iterativo, según lo especificado por el siguiente procedimiento:

#+begin_src scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src

Una máquina para llevar a cabo este algoritmo debe mantener un registro de dos números, a y b, así que asumamos que estos números están almacenados en dos registros con esos nombres. Las operaciones básicas requeridas son verificar si el contenido del registro ~b~ es cero y calcular el resto del contenido del registro ~a~ dividido por el contenido del registro ~b~. La operación de resto es un proceso complejo, pero asumamos por el momento que tenemos un dispositivo primitivo que calcula restos. En cada ciclo del algoritmo GCD, el contenido del registro ~a~ debe ser reemplazado por el contenido del registro ~b~, y el contenido de ~b~ debe ser reemplazado por el resto del contenido antiguo de ~a~ dividido por el contenido antiguo de ~b~. Sería conveniente si estos reemplazos pudieran hacerse simultáneamente, pero en nuestro modelo de máquinas de registros asumiremos que solo un registro puede recibir un nuevo valor en cada paso. Para lograr los reemplazos, nuestra máquina usará un tercer registro "temporal", que llamaremos ~t~. (Primero el resto se colocará en ~t~, luego el contenido de ~b~ se colocará en ~a~, y finalmente el resto almacenado en ~t~ se colocará en ~b~.)

Podemos ilustrar los registros y operaciones requeridos para esta máquina usando el diagrama de rutas de datos mostrado en la [[figure-5.1][Figura 5.1]]. En este diagrama, los registros (~a~, ~b~ y ~t~) están representados por rectángulos. Cada forma de asignar un valor a un registro se indica mediante una flecha con una ~X~ detrás de la punta, apuntando desde la fuente de datos hacia el registro. Podemos pensar en la ~X~ como un botón que, cuando se presiona, permite que el valor en la fuente "fluya" hacia el registro designado. La etiqueta junto a cada botón es el nombre que usaremos para referirnos al botón. Los nombres son arbitrarios y pueden elegirse para tener valor mnemotécnico (por ejemplo, ~a<-b~ denota presionar el botón que asigna el contenido del registro ~b~ al registro ~a~). La fuente de datos para un registro puede ser otro registro (como en la asignación ~a<-b~), un resultado de operación (como en la asignación ~t<-r~), o una constante (un valor incorporado que no se puede cambiar, representado en un diagrama de rutas de datos por un triángulo que contiene la constante).

Una operación que calcula un valor a partir de constantes y el contenido de registros se representa en un diagrama de rutas de datos mediante un trapezoide que contiene un nombre para la operación. Por ejemplo, la caja marcada ~rem~ en la [[figure-5.1][Figura 5.1]] representa una operación que calcula el resto del contenido de los registros ~a~ y ~b~ a los que está conectada. Las flechas (sin botones) apuntan desde los registros de entrada y constantes hacia la caja, y las flechas conectan el valor de salida de la operación a los registros. Una prueba se representa mediante un círculo que contiene un nombre para la prueba. Por ejemplo, nuestra máquina GCD tiene una operación que prueba si el contenido del registro ~b~ es cero. Una prueba también tiene flechas desde sus registros de entrada y constantes, pero no tiene flechas de salida; su valor es usado por el controlador en lugar de por las rutas de datos. En general, el diagrama de rutas de datos muestra los registros y operaciones que se requieren para la máquina y cómo deben estar conectados. Si vemos las flechas como cables y los botones ~X~ como interruptores, el diagrama de rutas de datos es muy similar al diagrama de cableado de una máquina que podría construirse a partir de componentes eléctricos.

<<figure-5.1>> Rutas de datos para una máquina GCD.

#+begin_example
                               ___
 +-----+          +-----+     /   \
 |  a  |<--(X)----|  b  +--->|  =  |
 +--+--+   a<-b   +-+---+     \___/
    |               |  ^        ^
    +------+   +----+  |        |
           |   |      (X) b<-t  |
        .--+---+--.    |       / \
         \  rem  /     |      / O \
          \_____/      |     +-----+
             |         |
            (X) t<-r   |
             |         |
             V         |
          +-----+      |
          |  t  +------+
          +-----+
#+end_example

Para que las rutas de datos realmente calculen GCDs, los botones deben presionarse en la secuencia correcta. Describiremos esta secuencia en términos de un diagrama de controlador, como se ilustra en la [[figure-5.2][Figura 5.2]]. Los elementos del diagrama de controlador indican cómo deben operarse los componentes de la ruta de datos. Las cajas rectangulares en el diagrama de controlador identifican botones de ruta de datos que deben presionarse, y las flechas describen la secuenciación de un paso al siguiente. El diamante en el diagrama representa una decisión. Se seguirá una de las dos flechas de secuencia, dependiendo del valor de la prueba de ruta de datos identificada en el diamante. Podemos interpretar el controlador en términos de una analogía física: Piense en el diagrama como un laberinto en el que rueda una canica. Cuando la canica rueda hacia una caja, presiona el botón de ruta de datos que está nombrado por la caja. Cuando la canica rueda hacia un nodo de decisión (como la prueba para ~b~ = 0), sale del nodo por el camino determinado por el resultado de la prueba indicada. Tomados en conjunto, las rutas de datos y el controlador describen completamente una máquina para calcular GCDs. Iniciamos el controlador (la canica rodante) en el lugar marcado ~start~, después de colocar números en los registros ~a~ y ~b~. Cuando el controlador alcanza ~done~, encontraremos el valor del GCD en el registro ~a~.

<<figure-5.2>> Controlador para una máquina GCD.

#+begin_example
      start
        |
        V
       / \ yes
 +--->< = >-----> done
 |     \ /
 |      | no
 |      V
 |  +------+
 |  | t<-r |
 |  +---+--+
 |      |
 |      V
 |  +------+
 |  | a<-b |
 |  +---+--+
 |      |
 |      V
 |  +------+
 +--+ b<-t |
    +------+
#+end_example

**** Ejercicio 5.1
:properties:
:custom_id: exercise-5.1
:end:

Diseñe una máquina de registros para calcular factoriales usando el algoritmo iterativo especificado por el siguiente procedimiento. Dibuje diagramas de ruta de datos y controlador para esta máquina.

#+begin_src scheme
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
#+end_src

