** 5.2 A Register-Machine Simulator
:properties:
:custom_id: section-5.2
:end:

In order to gain a good understanding of the design of register machines, we must test the machines we design to see if they perform as expected.  One way to test a design is to hand-simulate the operation of the controller, as in [[#exercise-5.5][Exercise 5.5]].  But this is extremely tedious for all but the simplest machines.  In this section we construct a simulator for machines described in the register-machine language.  The simulator is a Scheme program with four interface procedures.  The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model:

#+begin_src scheme
(make-machine <REGISTER-NAMES> <OPERATIONS> <CONTROLLER>)
#+end_src

constructs and returns a model of the machine with the given registers, operations, and controller.

#+begin_src scheme
(set-register-contents! <MACHINE-MODEL> <REGISTER-NAME> <VALUE>)
#+end_src

stores a value in a simulated register in the given machine.

#+begin_src scheme
(get-register-contents <MACHINE-MODEL> <REGISTER-NAME>)
#+end_src

returns the contents of a simulated register in the given machine.

#+begin_src scheme
(start <MACHINE-MODEL>)
#+end_src

simulates the execution of the given machine, starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence.

As an example of how these procedures are used, we can define ~gcd-machine~ to be a model of the GCD machine of section [[#section-5.1.1][5.1.1]] as follows:

#+begin_src scheme
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b))
     (assign b (reg t))
     (goto (label test-b))
     gcd-done)))
#+end_src

The first argument to ~make-machine~ is a list of register names.  The next argument is a table (a list of two-element lists) that pairs each operation name with a Scheme procedure that implements the operation (that is, produces the same output value given the same input values).  The last argument specifies the controller as a list of labels and machine instructions, as in section [[#section-5.1][5.1]].

To compute GCDs with this machine, we set the input registers, start the machine, and examine the result when the simulation terminates:

#+begin_src scheme
(set-register-contents! gcd-machine 'a 206)
done

(set-register-contents! gcd-machine 'b 40)
done

(start gcd-machine)
done

(get-register-contents gcd-machine 'a)
2
#+end_src

This computation will run much more slowly than a ~gcd~ procedure written in Scheme, because we will simulate low-level machine instructions, such as ~assign~, by much more complex operations.

**** Exercise 5.7
:properties:
:custom_id: exercise-5.7
:end:

Use the simulator to test the machines you designed in [[#exercise-5.4][Exercise 5.4]].

