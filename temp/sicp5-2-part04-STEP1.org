*** 5.2.3 Generación de procedimientos de ejecución para instrucciones
:properties:
:custom_id: section-5.2.3
:end:

El ensamblador llama a ~make-execution-procedure~ para generar el procedimiento de ejecución para una instrucción. Al igual que el procedimiento ~analyze~ en el evaluador de la sección [[#section-4.1.7][4.1.7]], este despacha según el tipo de instrucción para generar el procedimiento de ejecución apropiado.

#+begin_src scheme
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type - ASSEMBLE"
                     inst))))
#+end_src

Para cada tipo de instrucción en el lenguaje de máquina de registros, hay un generador que construye un procedimiento de ejecución apropiado. Los detalles de estos procedimientos determinan tanto la sintaxis como el significado de las instrucciones individuales en el lenguaje de máquina de registros. Usamos abstracción de datos para aislar la sintaxis detallada de las expresiones de máquina de registros del mecanismo de ejecución general, como hicimos para los evaluadores en la sección [[#section-4.1.2][4.1.2]], usando procedimientos de sintaxis para extraer y clasificar las partes de una instrucción.

*Instrucciones ~Assign~*

El procedimiento ~make-assign~ maneja las instrucciones ~assign~:

#+begin_src scheme
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda () ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))
#+end_src

~make-assign~ extrae el nombre del registro destino (el segundo elemento de la instrucción) y la expresión de valor (el resto de la lista que forma la instrucción) de la instrucción ~assign~ usando los selectores

#+begin_src scheme
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))

(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
#+end_src

El nombre del registro se busca con ~get-register~ para producir el objeto de registro destino. La expresión de valor se pasa a ~make-operation-exp~ si el valor es el resultado de una operación, y a ~make-primitive-exp~ en caso contrario. Estos procedimientos (mostrados abajo) analizan la expresión de valor y producen un procedimiento de ejecución para el valor. Este es un procedimiento sin argumentos, llamado ~value-proc~, que será evaluado durante la simulación para producir el valor real que se asignará al registro. Nota que el trabajo de buscar el nombre del registro y analizar la expresión de valor se realiza solo una vez, en tiempo de ensamblado, no cada vez que se simula la instrucción. Este ahorro de trabajo es la razón por la que usamos procedimientos de ejecución, y corresponde directamente al ahorro de trabajo que obtuvimos al separar el análisis del programa de la ejecución en el evaluador de la sección [[#section-4.1.7][4.1.7]].

El resultado devuelto por ~make-assign~ es el procedimiento de ejecución para la instrucción ~assign~. Cuando se llama a este procedimiento (por el procedimiento ~execute~ del modelo de máquina), establece el contenido del registro destino al resultado obtenido al ejecutar ~value-proc~. Luego avanza el ~pc~ a la siguiente instrucción ejecutando el procedimiento

#+begin_src scheme
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
#+end_src

~advance-pc~ es la terminación normal para todas las instrucciones excepto ~branch~ y ~goto~.

*Instrucciones 'Test', 'branch' y 'goto'*

~make-test~ maneja las instrucciones ~test~ de manera similar. Extrae la expresión que especifica la condición a probar y genera un procedimiento de ejecución para ella. En tiempo de simulación, se llama al procedimiento para la condición, el resultado se asigna al registro ~flag~, y el ~pc~ se avanza:

#+begin_src scheme
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction - ASSEMBLE" inst))))

(define (test-condition test-instruction)
  (cdr test-instruction))
#+end_src

El procedimiento de ejecución para una instrucción ~branch~ verifica el contenido del registro ~flag~ y o bien establece el contenido del ~pc~ al destino de la ramificación (si se toma la ramificación) o simplemente avanza el ~pc~ (si no se toma la ramificación). Nota que el destino indicado en una instrucción ~branch~ debe ser una etiqueta, y el procedimiento ~make-branch~ lo garantiza. Nota también que la etiqueta se busca en tiempo de ensamblado, no cada vez que se simula la instrucción ~branch~.

#+begin_src scheme
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction - ASSEMBLE" inst))))

(define (branch-dest branch-instruction)
  (cadr branch-instruction))
#+end_src

Una instrucción ~goto~ es similar a una ramificación, excepto que el destino puede especificarse como una etiqueta o como un registro, y no hay condición que verificar--el ~pc~ siempre se establece al nuevo destino.

#+begin_src scheme
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction - ASSEMBLE"
                       inst)))))

(define (goto-dest goto-instruction)
  (cadr goto-instruction))
#+end_src

*Otras instrucciones*

Las instrucciones de pila ~save~ y ~restore~ simplemente usan la pila con el registro designado y avanzan el ~pc~:

#+begin_src scheme
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
#+end_src

El tipo de instrucción final, manejado por ~make-perform~, genera un procedimiento de ejecución para la acción a realizar. En tiempo de simulación, el procedimiento de acción se ejecuta y el ~pc~ se avanza.

#+begin_src scheme
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction - ASSEMBLE" inst))))

(define (perform-action inst) (cdr inst))
#+end_src

*Procedimientos de ejecución para subexpresiones*

El valor de una expresión ~reg~, ~label~ o ~const~ puede necesitarse para la asignación a un registro (~make-assign~) o para entrada a una operación (~make-operation-exp~, abajo). El siguiente procedimiento genera procedimientos de ejecución para producir valores para estas expresiones durante la simulación:

#+begin_src scheme
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type - ASSEMBLE" exp))))
#+end_src

La sintaxis de las expresiones ~reg~, ~label~ y ~const~ está determinada por

#+begin_src scheme
(define (register-exp? exp) (tagged-list? exp 'reg))

(define (register-exp-reg exp) (cadr exp))

(define (constant-exp? exp) (tagged-list? exp 'const))

(define (constant-exp-value exp) (cadr exp))

(define (label-exp? exp) (tagged-list? exp 'label))

(define (label-exp-label exp) (cadr exp))
#+end_src

Las instrucciones ~assign~, ~perform~ y ~test~ pueden incluir la aplicación de una operación de máquina (especificada por una expresión ~op~) a algunos operandos (especificados por expresiones ~reg~ y ~const~). El siguiente procedimiento produce un procedimiento de ejecución para una "expresión de operación"--una lista que contiene la operación y las expresiones de operandos de la instrucción:

#+begin_src scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
#+end_src

La sintaxis de las expresiones de operación está determinada por

#+begin_src scheme
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
#+end_src

Observa que el tratamiento de las expresiones de operación es muy parecido al tratamiento de las aplicaciones de procedimientos por el procedimiento ~analyze-application~ en el evaluador de la sección [[#section-4.1.7][4.1.7]] en que generamos un procedimiento de ejecución para cada operando. En tiempo de simulación, llamamos a los procedimientos de operandos y aplicamos el procedimiento Scheme que simula la operación a los valores resultantes. El procedimiento de simulación se encuentra buscando el nombre de la operación en la tabla de operaciones para la máquina:

#+begin_src scheme
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation - ASSEMBLE" symbol))))
#+end_src

**** Ejercicio 5.9
:properties:
:custom_id: exercise-5.9
:end:

El tratamiento de las operaciones de máquina anterior les permite operar sobre etiquetas así como sobre constantes y el contenido de los registros. Modifica los procedimientos de procesamiento de expresiones para garantizar la condición de que las operaciones solo pueden usarse con registros y constantes.

**** Ejercicio 5.10
:properties:
:custom_id: exercise-5.10
:end:

Diseña una nueva sintaxis para las instrucciones de máquina de registros y modifica el simulador para usar tu nueva sintaxis. ¿Puedes implementar tu nueva sintaxis sin cambiar ninguna parte del simulador excepto los procedimientos de sintaxis en esta sección?

**** Ejercicio 5.11
:properties:
:custom_id: exercise-5.11
:end:

Cuando introdujimos ~save~ y ~restore~ en la sección [[#section-5.1.4][5.1.4]], no especificamos qué pasaría si intentaras restaurar un registro que no fue el último guardado, como en la secuencia

#+begin_src scheme
(save y)
(save x)
(restore y)
#+end_src

Hay varias posibilidades razonables para el significado de ~restore~:

a. ~(restore y)~ coloca en ~y~ el último valor guardado en la pila, sin importar de qué registro vino ese valor. Esta es la forma en que se comporta nuestro simulador. Muestra cómo aprovechar este comportamiento para eliminar una instrucción de la máquina Fibonacci de la sección [[#section-5.1.4][5.1.4]] ([[figure-5.12][Figura 5.12]]).

b. ~(restore y)~ coloca en ~y~ el último valor guardado en la pila, pero solo si ese valor fue guardado desde ~y~; de lo contrario, señala un error. Modifica el simulador para comportarse de esta manera. Tendrás que cambiar ~save~ para poner el nombre del registro en la pila junto con el valor.

c. ~(restore y)~ coloca en ~y~ el último valor guardado desde ~y~ sin importar qué otros registros fueron guardados después de ~y~ y no restaurados. Modifica el simulador para comportarse de esta manera. Tendrás que asociar una pila separada con cada registro. Debes hacer que la operación ~initialize-stack~ inicialice todas las pilas de registros.

**** Ejercicio 5.12
:properties:
:custom_id: exercise-5.12
:end:

El simulador puede usarse para ayudar a determinar las rutas de datos requeridas para implementar una máquina con un controlador dado. Extiende el ensamblador para almacenar la siguiente información en el modelo de máquina:

- una lista de todas las instrucciones, con duplicados eliminados, ordenadas por tipo de instrucción (~assign~, ~goto~, etc.);

- una lista (sin duplicados) de los registros usados para contener puntos de entrada (estos son los registros referenciados por instrucciones ~goto~);

- una lista (sin duplicados) de los registros que son guardados (~save~) o restaurados (~restore~);

- para cada registro, una lista (sin duplicados) de las fuentes desde las cuales se asigna (por ejemplo, las fuentes para el registro ~val~ en la máquina factorial de la [[figure-5.11][Figura 5.11]] son ~(const 1)~ y ~((op *) (reg n) (reg val))~).

Extiende la interfaz de paso de mensajes a la máquina para proporcionar acceso a esta nueva información. Para probar tu analizador, define la máquina Fibonacci de la [[figure-5.12][Figura 5.12]] y examina las listas que construiste.

**** Ejercicio 5.13
:properties:
:custom_id: exercise-5.13
:end:

Modifica el simulador para que use la secuencia del controlador para determinar qué registros tiene la máquina en lugar de requerir una lista de registros como argumento de ~make-machine~. En lugar de preasignar los registros en ~make-machine~, puedes asignarlos uno a la vez cuando se vean por primera vez durante el ensamblado de las instrucciones.

