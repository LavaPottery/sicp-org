** 5.3 Asignación de Almacenamiento y Recolección de Basura
:properties:
:custom_id: section-5.3
:end:

En la sección [[#section-5.4][5.4]], mostraremos cómo implementar un evaluador de Scheme como una máquina de registros. Para simplificar la discusión, asumiremos que nuestras máquinas de registros pueden estar equipadas con una <<i215>> memoria estructurada como lista, en la cual las operaciones básicas para manipular datos estructurados como listas son primitivas. Postular la existencia de tal memoria es una abstracción útil cuando uno se enfoca en los mecanismos de control en un intérprete de Scheme, pero esto no refleja una visión realista de las operaciones de datos primitivas reales de las computadoras contemporáneas. Para obtener una imagen más completa de cómo opera un sistema Lisp, debemos investigar cómo la estructura de lista puede ser representada de una manera que sea compatible con las memorias de computadoras convencionales.

Hay dos consideraciones en la implementación de la estructura de lista. La primera es puramente una cuestión de representación: cómo representar la estructura "caja y puntero" de los pares de Lisp, usando solamente las capacidades de almacenamiento y direccionamiento de las memorias de computadoras típicas. La segunda cuestión concierne la gestión de la memoria a medida que avanza un cálculo. La operación de un sistema Lisp depende crucialmente de la capacidad de crear continuamente nuevos objetos de datos. Estos incluyen objetos que son creados explícitamente por los procedimientos de Lisp que están siendo interpretados, así como estructuras creadas por el intérprete mismo, tales como ambientes y listas de argumentos. Aunque la creación constante de nuevos objetos de datos no plantearía ningún problema en una computadora con una cantidad infinita de memoria rápidamente direccionable, las memorias de computadoras están disponibles solo en tamaños finitos (qué lástima). Los sistemas Lisp proporcionan así una <<i26>> facilidad de asignación automática de almacenamiento para soportar la ilusión de una memoria infinita. Cuando un objeto de datos ya no se necesita, la memoria asignada a él se recicla automáticamente y se usa para construir nuevos objetos de datos. Existen varias técnicas para proporcionar tal asignación automática de almacenamiento. El método que discutiremos en esta sección se llama <<i157>> recolección de basura.

*** 5.3.1 Memoria como Vectores
:properties:
:custom_id: section-5.3.1
:end:

Una memoria de computadora convencional puede pensarse como un arreglo de casilleros, cada uno de los cuales puede contener una pieza de información. Cada casillero tiene un nombre único, llamado su <<i12>> dirección o <<i218>> ubicación. Los sistemas de memoria típicos proporcionan dos operaciones primitivas: una que obtiene los datos almacenados en una ubicación especificada y una que asigna nuevos datos a una ubicación especificada. Las direcciones de memoria pueden incrementarse para soportar el acceso secuencial a algún conjunto de los casilleros. Más generalmente, muchas operaciones de datos importantes requieren que las direcciones de memoria sean tratadas como datos, que pueden ser almacenados en ubicaciones de memoria y manipulados en registros de máquina. La representación de la estructura de lista es una aplicación de tal <<i13>> aritmética de direcciones.

Para modelar la memoria de computadora, usamos un nuevo tipo de estructura de datos llamada <<i422>> vector. Abstractamente, un vector es un objeto de datos compuesto cuyos elementos individuales pueden ser accedidos por medio de un índice entero en una cantidad de tiempo que es independiente del índice.[fn:290] Para describir las operaciones de memoria, usamos dos procedimientos primitivos de Scheme para manipular vectores:

- ~(vector-ref <VECTOR> <N>)~ devuelve el elemento n-ésimo del vector.

- ~(vector-set! <VECTOR> <N> <VALUE>)~ establece el elemento n-ésimo del vector al valor designado.

Por ejemplo, si ~v~ es un vector, entonces ~(vector-ref v 5)~ obtiene la quinta entrada en el vector ~v~ y ~(vector-set!  v 5 7)~ cambia el valor de la quinta entrada del vector ~v~ a 7.[fn:291] Para la memoria de computadora, este acceso puede ser implementado mediante el uso de aritmética de direcciones para combinar una <<i34>> dirección base que especifica la ubicación inicial de un vector en memoria con un <<i181>> índice que especifica el desplazamiento de un elemento particular del vector.

*Representación de datos de Lisp*

Podemos usar vectores para implementar las estructuras de pares básicas requeridas para una memoria estructurada como lista. Imaginemos que la memoria de computadora está dividida en dos vectores: ~the-cars~ y ~the-cdrs~. Representaremos la estructura de lista de la siguiente manera: Un puntero a un par es un índice en los dos vectores. El ~car~ del par es la entrada en ~the-cars~ con el índice designado, y el ~cdr~ del par es la entrada en ~the-cdrs~ con el índice designado. También necesitamos una representación para objetos distintos de pares (tales como números y símbolos) y una manera de distinguir un tipo de datos de otro. Hay muchos métodos para lograr esto, pero todos se reducen a usar <<i408>> punteros tipados, es decir, a extender la noción de "puntero" para incluir información sobre el tipo de datos.[fn:292] El tipo de datos permite al sistema distinguir un puntero a un par (que consiste del tipo de datos "par" y un índice en los vectores de memoria) de punteros a otros tipos de datos (que consisten de algún otro tipo de datos y lo que sea que se esté usando para representar datos de ese tipo). Dos objetos de datos se consideran iguales (~eq?~) si sus punteros son idénticos.[fn:293] La [[figure-5.14][Figura 5.14]] ilustra el uso de este método para representar la lista ~((1 2) 3 4)~, cuyo diagrama de caja y puntero también se muestra. Usamos prefijos de letras para denotar la información del tipo de datos. Así, un puntero al par con índice 5 se denota ~p5~, la lista vacía se denota por el puntero ~e0~, y un puntero al número 4 se denota ~n4~. En el diagrama de caja y puntero, hemos indicado en la parte inferior izquierda de cada par el índice del vector que especifica dónde se almacenan el ~car~ y el ~cdr~ del par. Las ubicaciones en blanco en ~the-cars~ y ~the-cdrs~ pueden contener partes de otras estructuras de lista (que no son de interés aquí).

<<figure-5.14>> Representaciones de caja y puntero y de vector de memoria de la lista ~((1 2) 3 4)~.

#+begin_example
                +---+---+               +---+---+    +---+---+
 ((1 2) 3 4) -->| * | *-+-------------->| * | *-+--->| * | / |
                +-|-+---+               +-|-+---+    +-|-+---+
               1  |                    2  |         4  |
                  V                       V            V
                +---+---+    +---+---+  +---+        +---+
                | * | *-+--->| * | / |  | 3 |        | 4 |
                +-|-+---+    +-|-+---+  +---+        +---+
               5  |         7  |
                  V            V
                +---+        +---+
                | 1 |        | 2 |
                +---+        +---+

    Index   0    1    2    3    4    5    6    7    8    ...
          +----+----+----+----+----+----+----+----+----+----
 the-cars |    | p5 | n3 |    | n4 | n1 |    | n2 |    | ...
          +----+----+----+----+----+----+----+----+----+----
 the-cdrs |    | p2 | p4 |    | e0 | p7 |    | e0 |    | ...
          +----+----+----+----+----+----+----+----+----+----
#+end_example

Un puntero a un número, tal como ~n4~, podría consistir de un tipo que indica datos numéricos junto con la representación real del número 4.[fn:294] Para tratar con números que son demasiado grandes para ser representados en la cantidad fija de espacio asignada para un solo puntero, podríamos usar un tipo de datos <<i36>> bignum distinto, para el cual el puntero designa una lista en la cual se almacenan las partes del número.[fn:295]

Un símbolo podría ser representado como un puntero tipado que designa una secuencia de los caracteres que forman la representación impresa del símbolo. Esta secuencia es construida por el lector de Lisp cuando la cadena de caracteres se encuentra inicialmente en la entrada. Dado que queremos que dos instancias de un símbolo sean reconocidas como el "mismo" símbolo por ~eq?~ y queremos que ~eq?~ sea una prueba simple de igualdad de punteros, debemos asegurar que si el lector ve la misma cadena de caracteres dos veces, usará el mismo puntero (a la misma secuencia de caracteres) para representar ambas ocurrencias. Para lograr esto, el lector mantiene una tabla, tradicionalmente llamada el <<i265>> obarray, de todos los símbolos que ha encontrado alguna vez. Cuando el lector encuentra una cadena de caracteres y está a punto de construir un símbolo, verifica el obarray para ver si alguna vez antes ha visto la misma cadena de caracteres. Si no lo ha hecho, usa los caracteres para construir un nuevo símbolo (un puntero tipado a una nueva secuencia de caracteres) y entra este puntero en el obarray. Si el lector ha visto la cadena antes, devuelve el puntero de símbolo almacenado en el obarray. Este proceso de reemplazar cadenas de caracteres por punteros únicos se llama <<i193>> internamiento de símbolos.

*Implementación de las operaciones primitivas de lista*

Dado el esquema de representación anterior, podemos reemplazar cada operación "primitiva" de lista de una máquina de registros con una o más operaciones primitivas de vector. Usaremos dos registros, ~the-cars~ y ~the-cdrs~, para identificar los vectores de memoria, y asumiremos que ~vector-ref~ y ~vector-set!~ están disponibles como operaciones primitivas. También asumimos que las operaciones numéricas sobre punteros (tales como incrementar un puntero, usar un puntero de par para indexar un vector, o sumar dos números) usan solo la porción de índice del puntero tipado.

Por ejemplo, podemos hacer que una máquina de registros soporte las instrucciones

#+begin_src scheme
(assign <REG_1> (op car) (reg <REG_2>))

(assign <REG_1> (op cdr) (reg <REG_2>))
#+end_src

si implementamos estas, respectivamente, como

#+begin_src scheme
(assign <REG_1> (op vector-ref) (reg the-cars) (reg <REG_2>))

(assign <REG_1> (op vector-ref) (reg the-cdrs) (reg <REG_2>))
#+end_src

Las instrucciones

#+begin_src scheme
(perform (op set-car!) (reg <REG_1>) (reg <REG_2>))

(perform (op set-cdr!) (reg <REG_1>) (reg <REG_2>))
#+end_src

se implementan como

#+begin_src scheme
(perform
 (op vector-set!) (reg the-cars) (reg <REG_1>) (reg <REG_2>))

(perform
 (op vector-set!) (reg the-cdrs) (reg <REG_1>) (reg <REG_2>))
#+end_src

~cons~ se realiza asignando un índice no usado y almacenando los argumentos de ~cons~ en ~the-cars~ y ~the-cdrs~ en esa posición del vector indexado. Presumimos que hay un registro especial, ~free~, que siempre contiene un puntero de par que contiene el siguiente índice disponible, y que podemos incrementar la parte del índice de ese puntero para encontrar la siguiente ubicación libre.[fn:296] Por ejemplo, la instrucción

#+begin_src scheme
(assign <REG_1> (op cons) (reg <REG_2>) (reg <REG_3>))
#+end_src

se implementa como la siguiente secuencia de operaciones de vector:[fn:297]

#+begin_src scheme
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg <REG_2>))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg <REG_3>))
(assign <REG_1> (reg free))
(assign free (op +) (reg free) (const 1))
#+end_src

La operación ~eq?~

#+begin_src scheme
(op eq?) (reg <REG_1>) (reg <REG_2>)
#+end_src

simplemente prueba la igualdad de todos los campos en los registros, y los predicados tales como ~pair?~, ~null?~, ~symbol?~, y ~number?~ solo necesitan verificar el campo de tipo.

*Implementación de pilas*

Aunque nuestras máquinas de registros usan pilas, no necesitamos hacer nada especial aquí, ya que las pilas pueden ser modeladas en términos de listas. La pila puede ser una lista de los valores guardados, apuntada por un registro especial ~the-stack~. Así, '(save <REG>)' puede ser implementado como

#+begin_src scheme
(assign the-stack (op cons) (reg <REG>) (reg the-stack))
#+end_src

De manera similar, '(restore <REG>)' puede ser implementado como

#+begin_src scheme
(assign <REG> (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
#+end_src

y ~(perform (op initialize-stack))~ puede ser implementado como

#+begin_src scheme
(assign the-stack (const ()))
#+end_src

Estas operaciones pueden ser expandidas más en términos de las operaciones de vector dadas arriba. Sin embargo, en las arquitecturas de computadoras convencionales, usualmente es ventajoso asignar la pila como un vector separado. Entonces empujar y sacar de la pila puede ser logrado incrementando o decrementando un índice en ese vector.

**** Ejercicio 5.20
:properties:
:custom_id: exercise-5.20
:end:

Dibuja la representación de caja y puntero y la representación de vector de memoria (como en la [[figure-5.14][Figura 5.14]]) de la estructura de lista producida por

#+begin_src scheme
(define x (cons 1 2))
(define y (list x x))
#+end_src

con el puntero ~free~ inicialmente ~p1~. ¿Cuál es el valor final de ~free~? ¿Qué punteros representan los valores de ~x~ y ~y~?

**** Ejercicio 5.21
:properties:
:custom_id: exercise-5.21
:end:

Implementa máquinas de registros para los siguientes procedimientos. Asume que las operaciones de memoria estructurada como lista están disponibles como primitivas de máquina.

a. ~count-leaves~ recursivo:

#+begin_src scheme
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
#+end_src

b. ~count-leaves~ recursivo con contador explícito:

#+begin_src scheme
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
#+end_src

**** Ejercicio 5.22
:properties:
:custom_id: exercise-5.22
:end:

El [[#exercise-3.12][Ejercicio 3.12]] de la sección [[#section-3.3.1][3.3.1]] presentó un procedimiento ~append~ que añade dos listas para formar una nueva lista y un procedimiento ~append!~ que empalma dos listas juntas. Diseña una máquina de registros para implementar cada uno de estos procedimientos. Asume que las operaciones de memoria estructurada como lista están disponibles como operaciones primitivas.
