*** 5.3.2 Manteniendo la Ilusión de Memoria Infinita
:properties:
:custom_id: section-5.3.2
:end:

El método de representación esbozado en la sección [[#section-5.3.1][5.3.1]] resuelve el problema de implementar la estructura de lista, siempre que tengamos una cantidad infinita de memoria. Con una computadora real, eventualmente nos quedaremos sin espacio libre en el cual construir nuevos pares.[fn:298] Sin embargo, la mayoría de los pares generados en un cálculo típico se usan solo para contener resultados intermedios. Después de que estos resultados son accedidos, los pares ya no se necesitan--son <<i156>> basura. Por ejemplo, el cálculo

#+begin_src scheme
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
#+end_src

construye dos listas: la enumeración y el resultado de filtrar la enumeración. Cuando la acumulación está completa, estas listas ya no se necesitan, y la memoria asignada puede ser reclamada. Si podemos arreglar recolectar toda la basura periódicamente, y si esto resulta reciclar memoria aproximadamente a la misma tasa a la que construimos nuevos pares, habremos preservado la ilusión de que hay una cantidad infinita de memoria.

Para reciclar pares, debemos tener una manera de determinar qué pares asignados no se necesitan (en el sentido de que sus contenidos ya no pueden influir en el futuro del cálculo). El método que examinaremos para lograr esto se conoce como <<i158>> recolección de basura. La recolección de basura se basa en la observación de que, en cualquier momento en una interpretación de Lisp, los únicos objetos que pueden afectar el futuro del cálculo son aquellos que pueden ser alcanzados por alguna sucesión de operaciones ~car~ y ~cdr~ comenzando desde los punteros que están actualmente en los registros de la máquina.[fn:299] Cualquier celda de memoria que no sea así accesible puede ser reciclada.

Hay muchas maneras de realizar la recolección de basura. El método que examinaremos aquí se llama <<i366>> detener y copiar. La idea básica es dividir la memoria en dos mitades: "memoria de trabajo" y "memoria libre". Cuando ~cons~ construye pares, los asigna en la memoria de trabajo. Cuando la memoria de trabajo está llena, realizamos la recolección de basura localizando todos los pares útiles en la memoria de trabajo y copiándolos en ubicaciones consecutivas en la memoria libre. (Los pares útiles se localizan trazando todos los punteros ~car~ y ~cdr~, comenzando con los registros de la máquina.) Dado que no copiamos la basura, presumiblemente habrá memoria libre adicional que podemos usar para asignar nuevos pares. Además, nada en la memoria de trabajo se necesita, ya que todos los pares útiles en ella han sido copiados. Así, si intercambiamos los roles de la memoria de trabajo y la memoria libre, podemos continuar procesando; nuevos pares serán asignados en la nueva memoria de trabajo (que era la antigua memoria libre). Cuando esta esté llena, podemos copiar los pares útiles en la nueva memoria libre (que era la antigua memoria de trabajo).[fn:300]

*Implementación de un recolector de basura de detener y copiar*

Ahora usamos nuestro lenguaje de máquina de registros para describir el algoritmo de detener y copiar con más detalle. Asumiremos que hay un registro llamado ~root~ que contiene un puntero a una estructura que eventualmente apunta a todos los datos accesibles. Esto puede arreglarse almacenando los contenidos de todos los registros de la máquina en una lista preasignada apuntada por ~root~ justo antes de comenzar la recolección de basura.[fn:301] También asumimos que, además de la memoria de trabajo actual, hay memoria libre disponible en la cual podemos copiar los datos útiles. La memoria de trabajo actual consiste de vectores cuyas direcciones base están en registros llamados ~the-cars~ y ~the-cdrs~, y la memoria libre está en registros llamados ~new-cars~ y ~new-cdrs~.

La recolección de basura se desencadena cuando agotamos las celdas libres en la memoria de trabajo actual, es decir, cuando una operación ~cons~ intenta incrementar el puntero ~free~ más allá del final del vector de memoria. Cuando el proceso de recolección de basura está completo, el puntero ~root~ apuntará a la nueva memoria, todos los objetos accesibles desde ~root~ habrán sido movidos a la nueva memoria, y el puntero ~free~ indicará el siguiente lugar en la nueva memoria donde un nuevo par puede ser asignado. Además, los roles de la memoria de trabajo y la nueva memoria habrán sido intercambiados--nuevos pares serán construidos en la nueva memoria, comenzando en el lugar indicado por ~free~, y la memoria de trabajo (previa) estará disponible como la nueva memoria para la siguiente recolección de basura. La [[figure-5.15][Figura 5.15]] muestra el arreglo de la memoria justo antes y justo después de la recolección de basura.

<<figure-5.15>> Reconfiguración de la memoria por el proceso de recolección de basura.

#+begin_example
              Just before garbage collection

          +------------------------------------+
 the-cars |                                    | working
          | mixture of useful data and garbage | memory
 the-cdrs |                                    |
          +------------------------------------+
                                             ^
                                             | free

          +------------------------------------+
 new-cars |                                    | free
          |            free memory             | memory
 new-cdrs |                                    |
          +------------------------------------+

              Just after garbage collection

          +------------------------------------+
 new-cars |                                    | new
          |          discarded memory          | free
 new-cdrs |                                    | memory
          +------------------------------------+

          +------------------+-----------------+
 the-cars |                  |                 | new
          |   useful data    |    free area    | working
 the-cdrs |                  |                 | memory
          +------------------+-----------------+
                               ^
                               | free
#+end_example

El estado del proceso de recolección de basura es controlado manteniendo dos punteros: ~free~ y ~scan~. Estos se inicializan para apuntar al comienzo de la nueva memoria. El algoritmo comienza reubicando el par apuntado por ~root~ al comienzo de la nueva memoria. El par es copiado, el puntero ~root~ se ajusta para apuntar a la nueva ubicación, y el puntero ~free~ se incrementa. Además, la antigua ubicación del par se marca para mostrar que sus contenidos han sido movidos. Este marcado se hace de la siguiente manera: En la posición ~car~, colocamos una etiqueta especial que señala que este es un objeto ya movido. (Tal objeto se llama tradicionalmente un <<i44>> corazón roto.)[fn:302] En la posición ~cdr~ colocamos una <<i143>> dirección de reenvío que apunta a la ubicación a la cual el objeto ha sido movido.

Después de reubicar la raíz, el recolector de basura entra en su ciclo básico. En cada paso del algoritmo, el puntero ~scan~ (inicialmente apuntando a la raíz reubicada) apunta a un par que ha sido movido a la nueva memoria pero cuyos punteros ~car~ y ~cdr~ todavía se refieren a objetos en la antigua memoria. Estos objetos son cada uno reubicados, y el puntero ~scan~ se incrementa. Para reubicar un objeto (por ejemplo, el objeto indicado por el puntero ~car~ del par que estamos escaneando) verificamos si el objeto ya ha sido movido (como se indica por la presencia de una etiqueta de corazón roto en la posición ~car~ del objeto). Si el objeto aún no ha sido movido, lo copiamos al lugar indicado por ~free~, actualizamos ~free~, establecemos un corazón roto en la antigua ubicación del objeto, y actualizamos el puntero al objeto (en este ejemplo, el puntero ~car~ del par que estamos escaneando) para apuntar a la nueva ubicación. Si el objeto ya ha sido movido, su dirección de reenvío (encontrada en la posición ~cdr~ del corazón roto) se sustituye por el puntero en el par siendo escaneado. Eventualmente, todos los objetos accesibles habrán sido movidos y escaneados, momento en el cual el puntero ~scan~ alcanzará al puntero ~free~ y el proceso terminará.

Podemos especificar el algoritmo de detener y copiar como una secuencia de instrucciones para una máquina de registros. El paso básico de reubicar un objeto se logra mediante una subrutina llamada ~relocate-old-result-in-new~. Esta subrutina obtiene su argumento, un puntero al objeto a ser reubicado, de un registro llamado ~old~. Reubica el objeto designado (incrementando ~free~ en el proceso), pone un puntero al objeto reubicado en un registro llamado ~new~, y retorna ramificándose al punto de entrada almacenado en el registro ~relocate-continue~. Para comenzar la recolección de basura, invocamos esta subrutina para reubicar el puntero ~root~, después de inicializar ~free~ y ~scan~. Cuando la reubicación de ~root~ ha sido lograda, instalamos el nuevo puntero como el nuevo ~root~ y entramos al bucle principal del recolector de basura.

#+begin_src scheme
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
#+end_src

En el bucle principal del recolector de basura debemos determinar si hay más objetos por escanear. Hacemos esto probando si el puntero ~scan~ es coincidente con el puntero ~free~. Si los punteros son iguales, entonces todos los objetos accesibles han sido reubicados, y ramificamos a ~gc-flip~, que limpia las cosas para que podamos continuar el cálculo interrumpido. Si todavía hay pares por escanear, llamamos a la subrutina de reubicación para reubicar el ~car~ del siguiente par (colocando el puntero ~car~ en ~old~). El registro ~relocate-continue~ se configura de modo que la subrutina retornará para actualizar el puntero ~car~.

#+begin_src scheme
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
#+end_src

En ~update-car~, modificamos el puntero ~car~ del par siendo escaneado, luego procedemos a reubicar el ~cdr~ del par. Retornamos a ~update-cdr~ cuando esa reubicación ha sido lograda. Después de reubicar y actualizar el ~cdr~, hemos terminado de escanear ese par, así que continuamos con el bucle principal.

#+begin_src scheme
update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
#+end_src

La subrutina ~relocate-old-result-in-new~ reubica objetos de la siguiente manera: Si el objeto a ser reubicado (apuntado por ~old~) no es un par, entonces retornamos el mismo puntero al objeto sin cambios (en ~new~). (Por ejemplo, podemos estar escaneando un par cuyo ~car~ es el número 4. Si representamos el ~car~ por ~n4~, como se describe en la sección [[#section-5.3.1][5.3.1]], entonces queremos que el puntero ~car~ "reubicado" siga siendo ~n4~.) De lo contrario, debemos realizar la reubicación. Si la posición ~car~ del par a ser reubicado contiene una etiqueta de corazón roto, entonces el par de hecho ya ha sido movido, así que recuperamos la dirección de reenvío (de la posición ~cdr~ del corazón roto) y retornamos esto en ~new~. Si el puntero en ~old~ apunta a un par aún no movido, entonces movemos el par a la primera celda libre en la nueva memoria (apuntada por ~free~) y establecemos el corazón roto almacenando una etiqueta de corazón roto y dirección de reenvío en la antigua ubicación. ~relocate-old-result-in-new~ usa un registro ~oldcr~ para contener el ~car~ o el ~cdr~ del objeto apuntado por ~old~.[fn:303]

#+begin_src scheme
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) ; nueva ubicación para el par
  ;; Actualizar puntero ~free~.
  (assign free (op +) (reg free) (const 1))
  ;; Copiar el ~car~ y el ~cdr~ a la nueva memoria.
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  ;; Construir el corazón roto.
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
#+end_src

Al final del proceso de recolección de basura, intercambiamos el rol de las memorias antigua y nueva intercambiando punteros: intercambiando ~the-cars~ con ~new-cars~, y ~the-cdrs~ con ~new-cdrs~. Estaremos entonces listos para realizar otra recolección de basura la próxima vez que se agote la memoria.

#+begin_src scheme
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
#+end_src
