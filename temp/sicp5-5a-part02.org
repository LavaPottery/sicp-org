
We sometimes need to construct an instruction sequence with no statements:

#+begin_src scheme
(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
#+end_src

The procedures for combining instruction sequences are shown in section [[#section-5.5.4][5.5.4]].

**** Exercise 5.31
:properties:
:custom_id: exercise-5.31
:end:

In evaluating a procedure application, the explicit-control evaluator always saves and restores the ~env~ register around the evaluation of the operator, saves and restores ~env~ around the evaluation of each operand (except the final one), saves and restores ~argl~ around the evaluation of each operand, and saves and restores ~proc~ around the evaluation of the operand sequence.  For each of the following combinations, say which of these ~save~ and ~restore~ operations are superfluous and thus could be eliminated by the compiler's ~preserving~ mechanism:

#+begin_src scheme
(f 'x 'y)

((f) 'x 'y)

(f (g 'x) y)

(f (g 'x) 'y)
#+end_src

**** Exercise 5.32
:properties:
:custom_id: exercise-5.32
:end:

Using the ~preserving~ mechanism, the compiler will avoid saving and restoring ~env~ around the evaluation of the operator of a combination in the case where the operator is a symbol.  We could also build such optimizations into the evaluator.  Indeed, the explicit-control evaluator of section [[#section-5.4][5.4]] already performs a similar optimization, by treating combinations with no operands as a special case.

a. Extend the explicit-control evaluator to recognize as a separate class of expressions combinations whose operator is a symbol, and to take advantage of this fact in evaluating such expressions.

b. Alyssa P. Hacker suggests that by extending the evaluator to recognize more and more special cases we could incorporate all the compiler's optimizations, and that this would eliminate the advantage of compilation altogether.  What do you think of this idea?

*** 5.5.2 Compiling Expressions
:properties:
:custom_id: section-5.5.2
:end:

In this section and the next we implement the code generators to which the ~compile~ procedure dispatches.

*Compiling linkage code*

In general, the output of each code generator will end with instructions--generated by the procedure ~compile-linkage~--that implement the required linkage.  If the linkage is ~return~ then we must generate the instruction ~(goto (reg continue))~.  This needs the ~continue~ register and does not modify any registers.  If the linkage is ~next~, then we needn't include any additional instructions.  Otherwise, the linkage is a label, and we generate a ~goto~ to that label, an instruction that does not need or modify any registers.[fn:321]

#+begin_src scheme
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
                                    '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
                                    '((goto (label ,linkage)))))))
#+end_src

The linkage code is appended to an instruction sequence by ~preserving~ the ~continue~ register, since a ~return~ linkage will require the ~continue~ register: If the given instruction sequence modifies ~continue~ and the linkage code needs it, ~continue~ will be saved and restored.

#+begin_src scheme
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
              instruction-sequence
              (compile-linkage linkage)))
#+end_src

*Compiling simple expressions*

The code generators for self-evaluating expressions, quotations, and variables construct instruction sequences that assign the required value to the target register and then proceed as specified by the linkage descriptor.

#+begin_src scheme
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '() (list target)
    '((assign ,target (const ,exp))))))

(define (compile-quoted exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '() (list target)
    '((assign ,target (const ,(text-of-quotation exp)))))))

(define (compile-variable exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '(env) (list target)
    '((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
#+end_src

All these assignment instructions modify the target register, and the one that looks up a variable needs the ~env~ register.

Assignments and definitions are handled much as they are in the interpreter.  We recursively generate code that computes the value to be assigned to the variable, and append to it a two-instruction sequence that actually sets or defines the variable and assigns the value of the whole expression (the symbol ~ok~) to the target register.  The recursive compilation has target ~val~ and linkage ~next~ so that the code will put its result into ~val~ and continue with the code that is appended after it.  The appending is done preserving ~env~, since the environment is needed for setting or defining the variable and the code for the variable value could be the compilation of a complex expression that might modify the registers in arbitrary ways.

#+begin_src scheme
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage
     linkage
     (preserving '(env)
                 get-value-code
                 (make-instruction-sequence
                  '(env val) (list target)
                  '((perform (op set-variable-value!)
                             (const ,var)
                             (reg val)
                             (reg env))
                    (assign ,target (const ok))))))))

(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage
     linkage
     (preserving '(env)
                 get-value-code
                 (make-instruction-sequence
                  '(env val) (list target)
                  '((perform (op define-variable!)
                             (const ,var)
                             (reg val)
                             (reg env))
                    (assign ,target (const ok))))))))
#+end_src

The appended two-instruction sequence requires ~env~ and ~val~ and modifies the target.  Note that although we preserve ~env~ for this sequence, we do not preserve ~val~, because the ~get-value-code~ is designed to explicitly place its result in ~val~ for use by this sequence.  (In fact, if we did preserve ~val~, we would have a bug, because this would cause the previous contents of ~val~ to be restored right after the ~get-value-code~ is run.)

*Compiling conditional expressions*

The code for an ~if~ expression compiled with a given target and linkage has the form

#+begin_src scheme
<compilation of predicate, target 'val', linkage 'next'>
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 <compilation of consequent with given target and given linkage or 'after-if'>
false-branch
 <compilation of alternative with given target and linkage>
after-if
#+end_src
