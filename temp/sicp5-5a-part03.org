
To generate this code, we compile the predicate, consequent, and alternative, and combine the resulting code with instructions to test the predicate result and with newly generated labels to mark the true and false branches and the end of the conditional.[fn:322] In this arrangement of code, we must branch around the true branch if the test is false.  The only slight complication is in how the linkage for the true branch should be handled.  If the linkage for the conditional is ~return~ or a label, then the true and false branches will both use this same linkage.  If the linkage is ~next~, the true branch ends with a jump around the code for the false branch to the label at the end of the conditional.

#+begin_src scheme
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
                    p-code
                    (append-instruction-sequences
                     (make-instruction-sequence
                      '(val) '()
                      '((test (op false?) (reg val))
                        (branch (label ,f-branch))))
                     (parallel-instruction-sequences
                      (append-instruction-sequences t-branch c-code)
                      (append-instruction-sequences f-branch a-code))
                     after-if))))))
#+end_src

~env~ is preserved around the predicate code because it could be needed by the true and false branches, and ~continue~ is preserved because it could be needed by the linkage code in those branches.  The code for the true and false branches (which are not executed sequentially) is appended using a special combiner ~parallel-instruction-sequences~ described in section [[#section-5.5.4][5.5.4]].

Note that ~cond~ is a derived expression, so all that the compiler needs to do handle it is to apply the ~cond->if~ transformer (from section [[#section-4.1.2][4.1.2]]) and compile the resulting ~if~ expression.

*Compiling sequences*

The compilation of sequences (from procedure bodies or explicit ~begin~ expressions) parallels their evaluation.  Each expression of the sequence is compiled--the last expression with the linkage specified for the sequence, and the other expressions with linkage ~next~ (to execute the rest of the sequence).  The instruction sequences for the individual expressions are appended to form a single instruction sequence, such that ~env~ (needed for the rest of the sequence) and ~continue~ (possibly needed for the linkage at the end of the sequence) are preserved.

#+begin_src scheme
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
                  (compile (first-exp seq) target 'next)
                  (compile-sequence (rest-exps seq) target linkage))))
#+end_src

*Compiling ~lambda~ expressions*

~lambda~ expressions construct procedures.  The object code for a ~lambda~ expression must have the form

#+begin_src scheme
<construct procedure object and assign it to target register>
<LINKAGE>
#+end_src

When we compile the ~lambda~ expression, we also generate the code for the procedure body.  Although the body won't be executed at the time of procedure construction, it is convenient to insert it into the object code right after the code for the ~lambda~.  If the linkage for the ~lambda~ expression is a label or ~return~, this is fine.  But if the linkage is ~next~, we will need to skip around the code for the procedure body by using a linkage that jumps to a label that is inserted after the body.  The object code thus has the form

#+begin_src scheme
<construct procedure object and assign it to target register>
 <code for given linkage> or '(goto (label after-lambda))'
 <compilation of procedure body>
after-lambda
#+end_src

~compile-lambda~ generates the code for constructing the procedure object followed by the code for the procedure body.  The procedure object will be constructed at run time by combining the current environment (the environment at the point of definition) with the entry point to the compiled procedure body (a newly generated label).[fn:323]

#+begin_src scheme
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
                          (make-instruction-sequence
                           '(env) (list target)
                           '((assign ,target
                                     (op make-compiled-procedure)
                                     (label ,proc-entry)
                                     (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
#+end_src

~compile-lambda~ uses the special combiner ~tack-on-instruction-sequence~ (section [[#section-5.5.4][5.5.4]]) rather than ~append-instruction-sequences~ to append the procedure body to the ~lambda~ expression code, because the body is not part of the sequence of instructions that will be executed when the combined sequence is entered; rather, it is in the sequence only because that was a convenient place to put it.

~compile-lambda-body~ constructs the code for the body of the procedure.  This code begins with a label for the entry point.  Next come instructions that will cause the run-time evaluation environment to switch to the correct environment for evaluating the procedure body--namely, the definition environment of the procedure, extended to include the bindings of the formal parameters to the arguments with which the procedure is called.  After this comes the code for the sequence of expressions that makes up the procedure body.  The sequence is compiled with linkage ~return~ and target ~val~ so that it will end by returning from the procedure with the procedure result in ~val~.

#+begin_src scheme
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
                                '(,proc-entry
                                  (assign env (op compiled-procedure-env) (reg proc))
                                  (assign env
                                          (op extend-environment)
                                          (const ,formals)
                                          (reg argl)
                                          (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
#+end_src

