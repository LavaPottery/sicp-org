
or like this if the linkage is ~return~.

#+begin_src scheme
(save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign <TARGET> (reg val))   ; included if target is not ~val~
 (restore continue)
 (goto (reg continue))   ; linkage code
#+end_src

This code sets up ~continue~ so that the procedure will return to a label ~proc-return~ and jumps to the procedure's entry point.  The code at ~proc-return~ transfers the procedure's result from ~val~ to the target register (if necessary) and then jumps to the location specified by the linkage.  (The linkage is always ~return~ or a label, because ~compile-procedure-call~ replaces a ~next~ linkage for the compound-procedure branch by an ~after-call~ label.)

In fact, if the target is not ~val~, that is exactly the code our compiler will generate.[fn:324] Usually, however, the target is ~val~ (the only time the compiler specifies a different register is when targeting the evaluation of an operator to ~proc~), so the procedure result is put directly into the target register and there is no need to return to a special location that copies it.  Instead, we simplify the code by setting up ~continue~ so that the procedure will "return" directly to the place specified by the caller's linkage:

#+begin_src scheme
<set up 'continue' for linkage>
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
#+end_src

If the linkage is a label, we set up ~continue~ so that the procedure will return to that label.  (That is, the ~(goto (reg continue))~ the procedure ends with becomes equivalent to the '(goto (label <LINKAGE>))' at ~proc-return~ above.)

#+begin_src scheme
(assign continue (label <LINKAGE>))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
#+end_src

If the linkage is ~return~, we don't need to set up ~continue~ at all: It already holds the desired location.  (That is, the ~(goto (reg continue))~ the procedure ends with goes directly to the place where the ~(goto (reg continue))~ at ~proc-return~ would have gone.)

#+begin_src scheme
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
#+end_src

With this implementation of the ~return~ linkage, the compiler generates tail-recursive code.  Calling a procedure as the final step in a procedure body does a direct transfer, without saving any information on the stack.

Suppose instead that we had handled the case of a procedure call with a linkage of ~return~ and a target of ~val~ as shown above for a non-~val~ target.  This would destroy tail recursion.  Our system would still give the same value for any expression.  But each time we called a procedure, we would save ~continue~ and return after the call to undo the (useless) save.  These extra saves would accumulate during a nest of procedure calls.[fn:325]

~compile-proc-appl~ generates the above procedure-application code by considering four cases, depending on whether the target for the call is ~val~ and whether the linkage is ~return~.  Observe that the instruction sequences are declared to modify all the registers, since executing the procedure body can change the registers in arbitrary ways.[fn:326] Also note that the code sequence for the case with target ~val~ and linkage ~return~ is declared to need ~continue~: Even though ~continue~ is not explicitly used in the two-instruction sequence, we must be sure that ~continue~ will have the correct value when we enter the compiled procedure.

#+begin_src scheme
(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence
          '(proc) all-regs
          '((assign continue (label ,linkage))
            (assign val (op compiled-procedure-entry)
                    (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence
            '(proc) all-regs
            '((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                      (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence
          '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                    (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error "return linkage, target not val - COMPILE"
                target))))
#+end_src

