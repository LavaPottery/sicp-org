** 4.4 Logic Programming
:properties:
:custom_id: section-4.4
:end:

In [[#section-1][Chapter 1]] we stressed that computer science deals with imperative (how to) knowledge, whereas mathematics deals with declarative (what is) knowledge.  Indeed, programming languages require that the programmer express knowledge in a form that indicates the step-by-step methods for solving particular problems.  On the other hand, high-level languages provide, as part of the language implementation, a substantial amount of methodological knowledge that frees the user from concern with numerous details of how a specified computation will progress.

Most programming languages, including Lisp, are organized around computing the values of mathematical functions.  Expression-oriented languages (such as Lisp, Fortran, and Algol) capitalize on the "pun" that an expression that describes the value of a function may also be interpreted as a means of computing that value.  Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs).  There are, however, radically different programming languages that relax this bias.  We saw one such example in section [[#section-3.3.5][3.3.5]], where the objects of computation were arithmetic constraints.  In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed "how to" knowledge than would be the case with an ordinary arithmetic computation.  This does not mean, however, that the user is released altogether from the responsibility of providing imperative knowledge.  There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation.

The nondeterministic program evaluator of section [[#section-4.3][4.3]] also moves away from the view that programming is about constructing algorithms for computing unidirectional functions.  In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with relations rather than with single-valued functions.  Logic programming extends this idea by combining a relational vision of programming with a powerful kind of symbolic pattern matching called <<i410>> unification.[fn:262]

This approach, when it works, can be a very powerful way to write programs.  Part of the power comes from the fact that a single "what is" fact can be used to solve a number of different problems that would have different "how to" components.  As an example, consider the ~append~ operation, which takes two lists as arguments and combines their elements to form a single list.  In a procedural language such as Lisp, we could define ~append~ in terms of the basic list constructor ~cons~, as we did in section [[#section-2.2.1][2.2.1]]:

#+begin_src scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+end_src

This procedure can be regarded as a translation into Lisp of the following two rules, the first of which covers the case where the first list is empty and the second of which handles the case of a nonempty list, which is a ~cons~ of two parts:

- For any list ~y~, the empty list and ~y~ ~append~ to form ~y~.

- For any ~u~, ~v~, ~y~, and ~z~, ~(cons u v)~ and ~y~ ~append~ to form ~(cons u z)~ if ~v~ and ~y~ ~append~ to form ~z~.[fn:263]

Using the ~append~ procedure, we can answer questions such as

#+begin_example
Find the ~append~ of ~(a b)~ and ~(c d)~.
#+end_example

But the same two rules are also sufficient for answering the following sorts of questions, which the procedure can't answer:

#+begin_example
Find a list ~y~ that ~append~s with ~(a b)~ to produce ~(a
b c d)~.

Find all ~x~ and ~y~ that ~append~ to form ~(a b c d)~.
#+end_example

In a logic programming language, the programmer writes an ~append~ "procedure" by stating the two rules about ~append~ given above.  "How to" knowledge is provided automatically by the interpreter to allow this single pair of rules to be used to answer all three types of questions about ~append~.[fn:264]

Contemporary logic programming languages (including the one we implement here) have substantial deficiencies, in that their general "how to" methods can lead them into spurious infinite loops or other undesirable behavior.  Logic programming is an active field of research in computer science.[fn:265]

Earlier in this chapter we explored the technology of implementing interpreters and described the elements that are essential to an interpreter for a Lisp-like language (indeed, to an interpreter for any conventional language).  Now we will apply these ideas to discuss an interpreter for a logic programming language.  We call this language the <<i313>> query language, because it is very useful for retrieving information from data bases by formulating <<i312>> queries, or questions, expressed in the language.  Even though the query language is very different from Lisp, we will find it convenient to describe the language in terms of the same general framework we have been using all along: as a collection of primitive elements, together with means of combination that enable us to combine simple elements to create more complex elements and means of abstraction that enable us to regard complex elements as single conceptual units.  An interpreter for a logic programming language is considerably more complex than an interpreter for a language like Lisp.  Nevertheless, we will see that our query-language interpreter contains many of the same elements found in the interpreter of section [[#section-4.1][4.1]].  In particular, there will be an "eval" part that classifies expressions according to type and an "apply" part that implements the language's abstraction mechanism (procedures in the case of Lisp, and <<i339>> rules in the case of logic programming).  Also, a central role is played in the implementation by a frame data structure, which determines the correspondence between symbols and their associated values.  One additional interesting aspect of our query-language implementation is that we make substantial use of streams, which were introduced in [[#section-3][Chapter 3]].

*** 4.4.1 Deductive Information Retrieval
:properties:
:custom_id: section-4.4.1
:end:

Logic programming excels in providing interfaces to data bases for information retrieval.  The query language we shall implement in this chapter is designed to be used in this way.

In order to illustrate what the query system does, we will show how it can be used to manage the data base of personnel records for Microshaft, a thriving high-technology company in the Boston area.  The language provides pattern-directed access to personnel information and can also take advantage of general rules in order to make logical deductions.

*A sample data base*

The personnel data base for Microshaft contains <<i23>> assertions about company personnel.  Here is the information about Ben Bitdiddle, the resident computer wizard:

#+begin_src scheme
(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
#+end_src

Each assertion is a list (in this case a triple) whose elements can themselves be lists.

As resident wizard, Ben is in charge of the company's computer division, and he supervises two programmers and one technician.  Here is the information about them:

#+begin_src scheme
(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))

(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))

(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
#+end_src

There is also a programmer trainee, who is supervised by Alyssa:

#+begin_src scheme
(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
#+end_src

All of these people are in the computer division, as indicated by the word ~computer~ as the first item in their job descriptions.

Ben is a high-level employee.  His supervisor is the company's big wheel himself:

#+begin_src scheme
(supervisor (Bitdiddle Ben) (Warbucks Oliver))

(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
#+end_src

Besides the computer division supervised by Ben, the company has an accounting division, consisting of a chief accountant and his assistant:

#+begin_src scheme
(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))

(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
#+end_src

There is also a secretary for the big wheel:

#+begin_src scheme
(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
#+end_src

The data base also contains assertions about which kinds of jobs can be done by people holding other kinds of jobs.  For instance, a computer wizard can do the jobs of both a computer programmer and a computer technician:

#+begin_src scheme
(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
#+end_src

A computer programmer could fill in for a trainee:

#+begin_src scheme
(can-do-job (computer programmer)
            (computer programmer trainee))
#+end_src

Also, as is well known,

#+begin_src scheme
(can-do-job (administration secretary)
            (administration big wheel))
#+end_src

*Simple queries*

The query language allows users to retrieve information from the data base by posing queries in response to the system's prompt.  For example, to find all computer programmers one can say

#+begin_src scheme
;;; Query input:
(job ?x (computer programmer))
#+end_src

The system will respond with the following items:

#+begin_src scheme
;;; Query results:
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
#+end_src

The input query specifies that we are looking for entries in the data base that match a certain <<i282>> pattern.  In this example, the pattern specifies entries consisting of three items, of which the first is the literal symbol ~job~, the second can be anything, and the third is the literal list ~(computer programmer)~.  The "anything" that can be the second item in the matching list is specified by a <<i285>> pattern variable, ~?x~.  The general form of a pattern variable is a symbol, taken to be the name of the variable, preceded by a question mark.  We will see below why it is useful to specify names for pattern variables rather than just putting ~?~ into patterns to represent "anything."  The system responds to a simple query by showing all entries in the data base that match the specified pattern.

A pattern can have more than one variable.  For example, the query

#+begin_src scheme
(address ?x ?y)
#+end_src

will list all the employees' addresses.

A pattern can have no variables, in which case the query simply determines whether that pattern is an entry in the data base.  If so, there will be one match; if not, there will be no matches.

The same pattern variable can appear more than once in a query, specifying that the same "anything" must appear in each position.  This is why variables have names.  For example,

#+begin_src scheme
(supervisor ?x ?x)
#+end_src

finds all people who supervise themselves (though there are no such assertions in our sample data base).

The query

#+begin_src scheme
(job ?x (computer ?type))
#+end_src

matches all job entries whose third item is a two-element list whose first item is ~computer~:

#+begin_src scheme
(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
#+end_src

This same pattern does /not/ match

#+begin_src scheme
(job (Reasoner Louis) (computer programmer trainee))
#+end_src

because the third item in the entry is a list of three elements, and the pattern's third item specifies that there should be two elements.  If we wanted to change the pattern so that the third item could be any list beginning with ~computer~, we could specify[fn:266]

#+begin_src scheme
(job ?x (computer . ?type))
#+end_src

For example,

#+begin_src scheme
(computer . ?type)
#+end_src

matches the data

#+begin_src scheme
(computer programmer trainee)
#+end_src

with ~?type~ as the list ~(programmer trainee)~.  It also matches the data

#+begin_src scheme
(computer programmer)
#+end_src

with ~?type~ as the list ~(programmer)~, and matches the data

#+begin_src scheme
(computer)
#+end_src

with ~?type~ as the empty list ~()~.

We can describe the query language's processing of simple queries as follows:

- The system finds all assignments to variables in the query pattern that <<i341>> satisfy the pattern--that is, all sets of values for the variables such that if the pattern variables are <<i183>> instantiated with (replaced by) the values, the result is in the data base.

- The system responds to the query by listing all instantiations of the query pattern with the variable assignments that satisfy it.

Note that if the pattern has no variables, the query reduces to a determination of whether that pattern is in the data base.  If so, the empty assignment, which assigns no values to variables, satisfies that pattern for that data base.

**** Exercise 4.55
:properties:
:custom_id: exercise-4.55
:end:

Give simple queries that retrieve the following information from the data base:

1. all people supervised by Ben Bitdiddle;
2. the names and jobs of all people in the accounting division;
3. the names and addresses of all people who live in Slumerville.

*Compound queries*

Simple queries form the primitive operations of the query language.  In order to form compound operations, the query language provides means of combination.  One thing that makes the query language a logic programming language is that the means of combination mirror the means of combination used in forming logical expressions: ~and~, ~or~, and ~not~.  (Here ~and~, ~or~, and ~not~ are not the Lisp primitives, but rather operations built into the query language.)

We can use ~and~ as follows to find the addresses of all the computer programmers:

#+begin_src scheme
(and (job ?person (computer programmer))
     (address ?person ?where))
#+end_src

The resulting output is

#+begin_src scheme
(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))

(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
#+end_src

In general,

#+begin_src scheme
(and <QUERY_1> <QUERY_2> ... <QUERY_N>)
#+end_src

is satisfied by all sets of values for the pattern variables that simultaneously satisfy <QUERY_1> ... <QUERY_N>.

As for simple queries, the system processes a compound query by finding all assignments to the pattern variables that satisfy the query, then displaying instantiations of the query with those values.

Another means of constructing compound queries is through ~or~.  For example,

#+begin_src scheme
(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
#+end_src

will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:

#+begin_src scheme
(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))

(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))

(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))

(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
#+end_src

In general,

#+begin_src scheme
(or <QUERY_1> <QUERY_2> ... <QUERY_N>)
#+end_src

is satisfied by all sets of values for the pattern variables that satisfy at least one of <QUERY_1> ... <QUERY_N>.

Compound queries can also be formed with ~not~.  For example,

#+begin_src scheme
(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
#+end_src

finds all people supervised by Ben Bitdiddle who are not computer programmers.  In general,

#+begin_src scheme
(not <QUERY_1>)
#+end_src

is satisfied by all assignments to the pattern variables that do not satisfy <QUERY_1>.[fn:267]

The final combining form is called ~lisp-value~.  When ~lisp-value~ is the first element of a pattern, it specifies that the next element is a Lisp predicate to be applied to the rest of the (instantiated) elements as arguments.  In general,

#+begin_src scheme
(lisp-value <PREDICATE> <ARG_1> ... <ARG_N>)
#+end_src

will be satisfied by assignments to the pattern variables for which the <PREDICATE> applied to the instantiated <ARG_1> ... <ARG_N> is true.  For example, to find all people whose salary is greater than $30,000 we could write[fn:268]

#+begin_src scheme
(and (salary ?person ?amount)
     (lisp-value > ?amount 30000))
#+end_src

**** Exercise 4.56
:properties:
:custom_id: exercise-4.56
:end:

Formulate compound queries that retrieve the following information:

a. the names of all people who are supervised by Ben Bitdiddle, together with their addresses;

b. all people whose salary is less than Ben Bitdiddle's, together with their salary and Ben Bitdiddle's salary;

c. all people who are supervised by someone who is not in the computer division, together with the supervisor's name and job.

*Rules*

In addition to primitive queries and compound queries, the query language provides means for abstracting queries.  These are given by <<i340>> rules.  The rule

#+begin_src scheme
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
#+end_src

specifies that two people live near each other if they live in the same town.  The final ~not~ clause prevents the rule from saying that all people live near themselves.  The ~same~ relation is defined by a very simple rule:[fn:269]

#+begin_src scheme
(rule (same ?x ?x))
#+end_src

The following rule declares that a person is a "wheel" in an organization if he supervises someone who is in turn a supervisor:

#+begin_src scheme
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
#+end_src

The general form of a rule is

#+begin_src scheme
(rule <CONCLUSION> <BODY>)
#+end_src

where <CONCLUSION> is a pattern and <BODY> is any query.[fn:270] We can think of a rule as representing a large (even infinite) set of assertions, namely all instantiations of the rule conclusion with variable assignments that satisfy the rule body.  When we described simple queries (patterns), we said that an assignment to variables satisfies a pattern if the instantiated pattern is in the data base.  But the pattern needn't be explicitly in the data base as an assertion.  It can be an implicit assertion implied by a rule.  For example, the query

#+begin_src scheme
(lives-near ?x (Bitdiddle Ben))
#+end_src

results in

#+begin_src scheme
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
#+end_src

To find all computer programmers who live near Ben Bitdiddle, we can ask

#+begin_src scheme
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
#+end_src

As in the case of compound procedures, rules can be used as parts of other rules (as we saw with the ~lives-near~ rule above) or even be defined recursively.  For instance, the rule

#+begin_src scheme
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
#+end_src

says that a staff person is outranked by a boss in the organization if the boss is the person's supervisor or (recursively) if the person's supervisor is outranked by the boss.

**** Exercise 4.57
:properties:
:custom_id: exercise-4.57
:end:

Define a rule that says that person 1 can replace person 2 if either person 1 does the same job as person 2 or someone who does person 1's job can also do person 2's job, and if person 1 and person 2 are not the same person.  Using your rule, give queries that find the following:

a. all people who can replace Cy D. Fect;

b. all people who can replace someone who is being paid more than they are, together with the two salaries.

**** Exercise 4.58
:properties:
:custom_id: exercise-4.58
:end:

Define a rule that says that a person is a "big shot" in a division if the person works in the division but does not have a supervisor who works in the division.

**** Exercise 4.59
:properties:
:custom_id: exercise-4.59
:end:

Ben Bitdiddle has missed one meeting too many.  Fearing that his habit of forgetting meetings could cost him his job, Ben decides to do something about it.  He adds all the weekly meetings of the firm to the Microshaft data base by asserting the following:

#+begin_src scheme
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
#+end_src

Each of the above assertions is for a meeting of an entire division.  Ben also adds an entry for the company-wide meeting that spans all the divisions.  All of the company's employees attend this meeting.

#+begin_src scheme
(meeting whole-company (Wednesday 4pm))
#+end_src

a. On Friday morning, Ben wants to query the data base for all the meetings that occur that day.  What query should he use?

b. Alyssa P. Hacker is unimpressed.  She thinks it would be much more useful to be able to ask for her meetings by specifying her name.  So she designs a rule that says that a person's meetings include all ~whole-company~ meetings plus all meetings of that person's division.  Fill in the body of Alyssa's rule.

#+begin_src scheme
(rule (meeting-time ?person ?day-and-time)
      <RULE-BODY>)
#+end_src

c. Alyssa arrives at work on Wednesday morning and wonders what meetings she has to attend that day.  Having defined the above rule, what query should she make to find this out?

**** Exercise 4.60
:properties:
:custom_id: exercise-4.60
:end:

By giving the query

#+begin_src scheme
(lives-near ?person (Hacker Alyssa P))
#+end_src

Alyssa P. Hacker is able to find people who live near her, with whom she can ride to work.  On the other hand, when she tries to find all pairs of people who live near each other by querying

#+begin_src scheme
(lives-near ?person-1 ?person-2)
#+end_src

she notices that each pair of people who live near each other is listed twice; for example,

#+begin_src scheme
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
#+end_src

Why does this happen?  Is there a way to find a list of people who live near each other, in which each pair appears only once?  Explain.

*Logic as programs*

We can regard a rule as a kind of logical implication: /If/ an assignment of values to pattern variables satisfies the body, /then/ it satisfies the conclusion.  Consequently, we can regard the query language as having the ability to perform <<i221>> logical deductions based upon the rules.  As an example, consider the ~append~ operation described at the beginning of section [[#section-4.4][4.4]].  As we said, ~append~ can be characterized by the following two rules:

- For any list ~y~, the empty list and ~y~ ~append~ to form ~y~.

- For any ~u~, ~v~, ~y~, and ~z~, ~(cons u v)~ and ~y~ ~append~ to form ~(cons u z)~ if ~v~ and ~y~ ~append~ to form ~z~.

To express this in our query language, we define two rules for a relation

#+begin_src scheme
(append-to-form x y z)
#+end_src

which we can interpret to mean "~x~ and ~y~ ~append~ to form ~z~":

#+begin_src scheme
(rule (append-to-form () ?y ?y))

(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
#+end_src

The first rule has no body, which means that the conclusion holds for any value of ~?y~.  Note how the second rule makes use of dotted-tail notation to name the ~car~ and ~cdr~ of a list.

Given these two rules, we can formulate queries that compute the ~append~ of two lists:

#+begin_src scheme
;;; Query input:
(append-to-form (a b) (c d) ?z)
;;; Query results:
(append-to-form (a b) (c d) (a b c d))
#+end_src

What is more striking, we can use the same rules to ask the question "Which list, when 'append'ed to ~(a b)~, yields ~(a b c d)~?"  This is done as follows:

#+begin_src scheme
;;; Query input:
(append-to-form (a b) ?y (a b c d))
;;; Query results:
(append-to-form (a b) (c d) (a b c d))
#+end_src

We can also ask for all pairs of lists that ~append~ to form ~(a b c d)~:

#+begin_src scheme
;;; Query input:
(append-to-form ?x ?y (a b c d))
;;; Query results:
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
#+end_src

The query system may seem to exhibit quite a bit of intelligence in using the rules to deduce the answers to the queries above.  Actually, as we will see in the next section, the system is following a well-determined algorithm in unraveling the rules.  Unfortunately, although the system works impressively in the ~append~ case, the general methods may break down in more complex cases, as we will see in section [[#section-4.4.3][4.4.3]].

**** Exercise 4.61
:properties:
:custom_id: exercise-4.61
:end:

The following rules implement a ~next-to~ relation that finds adjacent elements of a list:

#+begin_src scheme
(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
#+end_src

What will the response be to the following queries?

#+begin_src scheme
(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))
#+end_src

**** Exercise 4.62
:properties:
:custom_id: exercise-4.62
:end:

Define rules to implement the ~last-pair~ operation of [[#exercise-2.17][Exercise 2.17]], which returns a list containing the last element of a nonempty list.  Check your rules on queries such as ~(last-pair (3) ?x)~, ~(last-pair (1 2 3) ?x)~, and ~(last-pair (2 ?x) (3))~.  Do your rules work correctly on queries such as ~(last-pair ?x (3))~ ?

**** Exercise 4.63
:properties:
:custom_id: exercise-4.63
:end:

The following data base (see Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way of Cain:

#+begin_src scheme
(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
#+end_src

Formulate rules such as "If S is the son of f, and f is the son of G, then S is the grandson of G" and "If W is the wife of M, and S is the son of W, then S is the son of M" (which was supposedly more true in biblical times than today) that will enable the query system to find the grandson of Cain; the sons of Lamech; the grandsons of Methushael.  (See [[#exercise-4.69][Exercise 4.69]] for some rules to deduce more complicated relationships.)

*** 4.4.2 How the Query System Works
:properties:
:custom_id: section-4.4.2
:end:

In section [[#section-4.4.4][4.4.4]] we will present an implementation of the query interpreter as a collection of procedures.  In this section we give an overview that explains the general structure of the system independent of low-level implementation details.  After describing the implementation of the interpreter, we will be in a position to understand some of its limitations and some of the subtle ways in which the query language's logical operations differ from the operations of mathematical logic.

It should be apparent that the query evaluator must perform some kind of search in order to match queries against facts and rules in the data base.  One way to do this would be to implement the query system as a nondeterministic program, using the ~amb~ evaluator of section [[#section-4.3][4.3]] (see [[#exercise-4.78][Exercise 4.78]]).  Another possibility is to manage the search with the aid of streams.  Our implementation follows this second approach.

The query system is organized around two central operations called <<i284>> pattern matching and <<i411>> unification.  We first describe pattern matching and explain how this operation, together with the organization of information in terms of streams of frames, enables us to implement both simple and compound queries.  We next discuss unification, a generalization of pattern matching needed to implement rules.  Finally, we show how the entire query interpreter fits together through a procedure that classifies expressions in a manner analogous to the way ~eval~ classifies expressions for the interpreter described in section [[#section-4.1][4.1]].

*Pattern matching*

A <<i283>> pattern matcher is a program that tests whether some datum fits a specified pattern.  For example, the data list ~((a b) c (a b))~ matches the pattern ~(?x c ?x)~ with the pattern variable ~?x~ bound to ~(a b)~.  The same data list matches the pattern ~(?x ?y ?z)~ with ~?x~ and ~?z~ both bound to ~(a b)~ and ~?y~ bound to ~c~.  It also matches the pattern ~((?x ?y) c (?x ?y))~ with ~?x~ bound to ~a~ and ~?y~ bound to ~b~.  However, it does not match the pattern ~(?x a ?y)~, since that pattern specifies a list whose second element is the symbol ~a~.

The pattern matcher used by the query system takes as inputs a pattern, a datum, and a <<i144>> frame that specifies bindings for various pattern variables.  It checks whether the datum matches the pattern in a way that is consistent with the bindings already in the frame.  If so, it returns the given frame augmented by any bindings that may have been determined by the match.  Otherwise, it indicates that the match has failed.

For example, using the pattern ~(?x ?y ?x)~ to match ~(a b a)~ given an empty frame will return a frame specifying that ~?x~ is bound to ~a~ and ~?y~ is bound to ~b~.  Trying the match with the same pattern, the same datum, and a frame specifying that ~?y~ is bound to ~a~ will fail.  Trying the match with the same pattern, the same datum, and a frame in which ~?y~ is bound to ~b~ and ~?x~ is unbound will return the given frame augmented by a binding of ~?x~ to ~a~.

The pattern matcher is all the mechanism that is needed to process simple queries that don't involve rules.  For instance, to process the query

#+begin_src scheme
(job ?x (computer programmer))
#+end_src

we scan through all assertions in the data base and select those that match the pattern with respect to an initially empty frame.  For each match we find, we use the frame returned by the match to instantiate the pattern with a value for ~?x~.

*Streams of frames*

The testing of patterns against frames is organized through the use of streams.  Given a single frame, the matching process runs through the data-base entries one by one.  For each data-base entry, the matcher generates either a special symbol indicating that the match has failed or an extension to the frame.  The results for all the data-base entries are collected into a stream, which is passed through a filter to weed out the failures.  The result is a stream of all the frames that extend the given frame via a match to some assertion in the data base.[fn:271]

In our system, a query takes an input stream of frames and performs the above matching operation for every frame in the stream, as indicated in [[figure-4.4][Figure 4.4]].  That is, for each frame in the input stream, the query generates a new stream consisting of all extensions to that frame by matches to assertions in the data base.  All these streams are then combined to form one huge stream, which contains all possible extensions of every frame in the input stream.  This stream is the output of the query.

<<figure-4.4>> A query processes a stream of frames.

#+begin_example
                                   output stream
   input stream   +-------------+  of frames,
   of frames      |    query    |  filtered and extended
 ---------------->|             +------------------------->
                  | (job ?x ?y) |
                  +-------------+
                         ^
                         |
                stream of assertions
                   from data base
#+end_example

To answer a simple query, we use the query with an input stream consisting of a single empty frame.  The resulting output stream contains all extensions to the empty frame (that is, all answers to our query).  This stream of frames is then used to generate a stream of copies of the original query pattern with the variables instantiated by the values in each frame, and this is the stream that is finally printed.

*Compound queries*

The real elegance of the stream-of-frames implementation is evident when we deal with compound queries.  The processing of compound queries makes use of the ability of our matcher to demand that a match be consistent with a specified frame.  For example, to handle the ~and~ of two queries, such as

#+begin_src scheme
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
#+end_src

(informally, "Find all people who can do the job of a computer programmer trainee"), we first find all entries that match the pattern

#+begin_src scheme
(can-do-job ?x (computer programmer trainee))
#+end_src

This produces a stream of frames, each of which contains a binding for ~?x~.  Then for each frame in the stream we find all entries that match

#+begin_src scheme
(job ?person ?x)
#+end_src

in a way that is consistent with the given binding for ~?x~.  Each such match will produce a frame containing bindings for ~?x~ and ~?person~.  The ~and~ of two queries can be viewed as a series combination of the two component queries, as shown in [[figure-4.5][Figure 4.5]].  The frames that pass through the first query filter are filtered and further extended by the second query.

<<figure-4.5>> The ~and~ combination of two queries is produced by operating on the stream of frames in series.

#+begin_example
                 +----------------------+
                 |       (and A B)      |
   input stream  |                      |  output stream
   of frames     |   +---+       +---+  |  of frames
 ------------------->| A +------>| B +-------------------->
                 |   +---+       +---+  |
                 |     ^           ^    |
                 |     |           |    |
                 |     +-----*-----+    |
                 +-----------|----------+
                             |
                         data base
#+end_example

[[figure-4.6][Figure 4.6]] shows the analogous method for computing the ~or~ of two queries as a parallel combination of the two component queries.  The input stream of frames is extended separately by each query.  The two resulting streams are then merged to produce the final output stream.

<<figure-4.6>> The ~or~ combination of two queries is produced by operating on the stream of frames in parallel and merging the results.

#+begin_example
            +---------------------------+
            |          (or A B)         |
            |    +---+                  |
 input      | +->| A |------------+     |  output
 stream of  | |  +---+            V     |  stream of
 frames     | |    ^          +-------+ |  frames
 -------------*    |          | merge +--------------->
            | |    |          +-------+ |
            | |    |              ^     |
            | |    |   +---+      |     |
            | +------->| B +------+     |
            |      |   +---+            |
            |      |     ^              |
            |      |     |              |
            |      +--*--+              |
            +---------|-----------------+
                      |
                  data base
#+end_example

Even from this high-level description, it is apparent that the processing of compound queries can be slow.  For example, since a query may produce more than one output frame for each input frame, and each query in an ~and~ gets its input frames from the previous query, an ~and~ query could, in the worst case, have to perform a number of matches that is exponential in the number of queries (see [[#exercise-4.76][Exercise 4.76]]).[fn:272] Though systems for handling only simple queries are quite practical, dealing with complex queries is extremely difficult.[fn:273]

From the stream-of-frames viewpoint, the ~not~ of some query acts as a filter that removes all frames for which the query can be satisfied.  For instance, given the pattern

#+begin_src scheme
(not (job ?x (computer programmer)))
#+end_src

we attempt, for each frame in the input stream, to produce extension frames that satisfy ~(job ?x (computer programmer))~.  We remove from the input stream all frames for which such extensions exist.  The result is a stream consisting of only those frames in which the binding for ~?x~ does not satisfy ~(job ?x (computer programmer))~.  For example, in processing the query

#+begin_src scheme
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
#+end_src

the first clause will generate frames with bindings for ~?x~ and ~?y~.  The ~not~ clause will then filter these by removing all frames in which the binding for ~?x~ satisfies the restriction that ~?x~ is a computer programmer.[fn:274]

The ~lisp-value~ special form is implemented as a similar filter on frame streams.  We use each frame in the stream to instantiate any variables in the pattern, then apply the Lisp predicate.  We remove from the input stream all frames for which the predicate fails.

*Unification*

In order to handle rules in the query language, we must be able to find the rules whose conclusions match a given query pattern.  Rule conclusions are like assertions except that they can contain variables, so we will need a generalization of pattern matching--called <<i412>> unification--in which both the "pattern" and the "datum" may contain variables.

A unifier takes two patterns, each containing constants and variables, and determines whether it is possible to assign values to the variables that will make the two patterns equal.  If so, it returns a frame containing these bindings.  For example, unifying ~(?x a ?y)~ and ~(?y ?z a)~ will specify a frame in which ~?x~, ~?y~, and ~?z~ must all be bound to ~a~.  On the other hand, unifying ~(?x ?y a)~ and ~(?x b ?y)~ will fail, because there is no value for ~?y~ that can make the two patterns equal.  (For the second elements of the patterns to be equal, ~?y~ would have to be ~b~; however, for the third elements to be equal, ~?y~ would have to be ~a~.)  The unifier used in the query system, like the pattern matcher, takes a frame as input and performs unifications that are consistent with this frame.

The unification algorithm is the most technically difficult part of the query system.  With complex patterns, performing unification may seem to require deduction.  To unify ~(?x ?x)~ and ~((a ?y c) (a b ?z))~, for example, the algorithm must infer that ~?x~ should be ~(a b c)~, ~?y~ should be ~b~, and ~?z~ should be ~c~.  We may think of this process as solving a set of equations among the pattern components.  In general, these are simultaneous equations, which may require substantial manipulation to solve.[fn:275] For example, unifying ~(?x ?x)~ and ~((a ?y c) (a b ?z))~ may be thought of as specifying the simultaneous equations

#+begin_src scheme
?x  =  (a ?y c)
?x  =  (a b ?z)
#+end_src

These equations imply that

#+begin_src scheme
(a ?y c)  =  (a b ?z)
#+end_src

which in turn implies that

#+begin_src scheme
a  =  a, ?y  =  b, c  =  ?z,
#+end_src

and hence that

#+begin_src scheme
?x  =  (a b c)
#+end_src

In a successful pattern match, all pattern variables become bound, and the values to which they are bound contain only constants.  This is also true of all the examples of unification we have seen so far.  In general, however, a successful unification may not completely determine the variable values; some variables may remain unbound and others may be bound to values that contain variables.

Consider the unification of ~(?x a)~ and ~((b ?y) ?z)~.  We can deduce that ~?x = (b ?y)~ and ~a = ?z~, but we cannot further solve for ~?x~ or ~?y~.  The unification doesn't fail, since it is certainly possible to make the two patterns equal by assigning values to ~?x~ and ~?y~.  Since this match in no way restricts the values ~?y~ can take on, no binding for ~?y~ is put into the result frame.  The match does, however, restrict the value of ~?x~.  Whatever value ~?y~ has, ~?x~ must be ~(b ?y)~.  A binding of ~?x~ to the pattern ~(b ?y)~ is thus put into the frame.  If a value for ~?y~ is later determined and added to the frame (by a pattern match or unification that is required to be consistent with this frame), the previously bound ~?x~ will refer to this value.[fn:276]

*Applying rules*

Unification is the key to the component of the query system that makes inferences from rules.  To see how this is accomplished, consider processing a query that involves applying a rule, such as

#+begin_src scheme
(lives-near ?x (Hacker Alyssa P))
#+end_src

To process this query, we first use the ordinary pattern-match procedure described above to see if there are any assertions in the data base that match this pattern.  (There will not be any in this case, since our data base includes no direct assertions about who lives near whom.)  The next step is to attempt to unify the query pattern with the conclusion of each rule.  We find that the pattern unifies with the conclusion of the rule

#+begin_src scheme
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
#+end_src

resulting in a frame specifying that ~?person-2~ is bound to ~(Hacker Alyssa P)~ and that ~?x~ should be bound to (have the same value as) ~?person-1~.  Now, relative to this frame, we evaluate the compound query given by the body of the rule.  Successful matches will extend this frame by providing a binding for ~?person-1~, and consequently a value for ~?x~, which we can use to instantiate the original query pattern.

In general, the query evaluator uses the following method to apply a rule when trying to establish a query pattern in a frame that specifies bindings for some of the pattern variables:

- Unify the query with the conclusion of the rule to form, if successful, an extension of the original frame.

- Relative to the extended frame, evaluate the query formed by the body of the rule.

Notice how similar this is to the method for applying a procedure in the ~eval~/~apply~ evaluator for Lisp:

- Bind the procedure's parameters to its arguments to form a frame that extends the original procedure environment.

- Relative to the extended environment, evaluate the expression formed by the body of the procedure.

The similarity between the two evaluators should come as no surprise.  Just as procedure definitions are the means of abstraction in Lisp, rule definitions are the means of abstraction in the query language.  In each case, we unwind the abstraction by creating appropriate bindings and evaluating the rule or procedure body relative to these.

*Simple queries*

We saw earlier in this section how to evaluate simple queries in the absence of rules.  Now that we have seen how to apply rules, we can describe how to evaluate simple queries by using both rules and assertions.

Given the query pattern and a stream of frames, we produce, for each frame in the input stream, two streams:

- a stream of extended frames obtained by matching the pattern against all assertions in the data base (using the pattern matcher), and

- a stream of extended frames obtained by applying all possible rules (using the unifier).[fn:277]

Appending these two streams produces a stream that consists of all the ways that the given pattern can be satisfied consistent with the original frame.  These streams (one for each frame in the input stream) are now all combined to form one large stream, which therefore consists of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern.

*The query evaluator and the driver loop*

Despite the complexity of the underlying matching operations, the system is organized much like an evaluator for any language.  The procedure that coordinates the matching operations is called ~qeval~, and it plays a role analogous to that of the ~eval~ procedure for Lisp.  ~qeval~ takes as inputs a query and a stream of frames.  Its output is a stream of frames, corresponding to successful matches to the query pattern, that extend some frame in the input stream, as indicated in [[figure-4.4][Figure 4.4]].  Like ~eval~, ~qeval~ classifies the different types of expressions (queries) and dispatches to an appropriate procedure for each.  There is a procedure for each special form (~and~, ~or~, ~not~, and ~lisp-value~) and one for simple queries.

The driver loop, which is analogous to the ~driver-loop~ procedure for the other evaluators in this chapter, reads queries from the terminal.  For each query, it calls ~qeval~ with the query and a stream that consists of a single empty frame.  This will produce the stream of all possible matches (all possible extensions to the empty frame).  For each frame in the resulting stream, it instantiates the original query using the values of the variables found in the frame.  This stream of instantiated queries is then printed.[fn:278]

The driver also checks for the special command ~assert!~, which signals that the input is not a query but rather an assertion or rule to be added to the data base.  For instance,

#+begin_src scheme
(assert! (job (Bitdiddle Ben) (computer wizard)))

(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
#+end_src
