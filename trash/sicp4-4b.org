
*** 4.4.3 Is Logic Programming Mathematical Logic?
:properties:
:custom_id: section-4.4.3
:end:

The means of combination used in the query language may at first seem identical to the operations ~and~, ~or~, and ~not~ of mathematical logic, and the application of query-language rules is in fact accomplished through a legitimate method of inference.[fn:279] This identification of the query language with mathematical logic is not really valid, though, because the query language provides a <<i86>> control structure that interprets the logical statements procedurally.  We can often take advantage of this control structure.  For example, to find all of the supervisors of programmers we could formulate a query in either of two logically equivalent forms:

#+begin_src scheme
(and (job ?x (computer programmer))
     (supervisor ?x ?y))
#+end_src

or

#+begin_src scheme
(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
#+end_src

If a company has many more supervisors than programmers (the usual case), it is better to use the first form rather than the second because the data base must be scanned for each intermediate result (frame) produced by the first clause of the ~and~.

The aim of logic programming is to provide the programmer with techniques for decomposing a computational problem into two separate problems: "what" is to be computed, and "how" this should be computed.  This is accomplished by selecting a subset of the statements of mathematical logic that is powerful enough to be able to describe anything one might want to compute, yet weak enough to have a controllable procedural interpretation.  The intention here is that, on the one hand, a program specified in a logic programming language should be an effective program that can be carried out by a computer.  Control ("how" to compute) is effected by using the order of evaluation of the language.  We should be able to arrange the order of clauses and the order of subgoals within each clause so that the computation is done in an order deemed to be effective and efficient.  At the same time, we should be able to view the result of the computation ("what" to compute) as a simple consequence of the laws of logic.

Our query language can be regarded as just such a procedurally interpretable subset of mathematical logic.  An assertion represents a simple fact (an atomic proposition).  A rule represents the implication that the rule conclusion holds for those cases where the rule body holds.  A rule has a natural procedural interpretation: To establish the conclusion of the rule, establish the body of the rule.  Rules, therefore, specify computations.  However, because rules can also be regarded as statements of mathematical logic, we can justify any "inference" accomplished by a logic program by asserting that the same result could be obtained by working entirely within mathematical logic.[fn:280]

*Infinite loops*

A consequence of the procedural interpretation of logic programs is that it is possible to construct hopelessly inefficient programs for solving certain problems.  An extreme case of inefficiency occurs when the system falls into infinite loops in making deductions.  As a simple example, suppose we are setting up a data base of famous marriages, including

#+begin_src scheme
(assert! (married Minnie Mickey))
#+end_src

If we now ask

#+begin_src scheme
(married Mickey ?who)
#+end_src

we will get no response, because the system doesn't know that if A is married to B, then B is married to A. So we assert the rule

#+begin_src scheme
(assert! (rule (married ?x ?y)
               (married ?y ?x)))
#+end_src

and again query

#+begin_src scheme
(married Mickey ?who)
#+end_src

Unfortunately, this will drive the system into an infinite loop, as follows:

- The system finds that the ~married~ rule is applicable; that is, the rule conclusion ~(married ?x ?y)~ successfully unifies with the query pattern ~(married Mickey ?who)~ to produce a frame in which ~?x~ is bound to ~Mickey~ and ~?y~ is bound to ~?who~.  So the interpreter proceeds to evaluate the rule body ~(married ?y ?x)~ in this frame--in effect, to process the query ~(married ?who Mickey)~.

- One answer appears directly as an assertion in the data base: ~(married Minnie Mickey)~.

- The ~married~ rule is also applicable, so the interpreter again evaluates the rule body, which this time is equivalent to ~(married Mickey ?who)~.

The system is now in an infinite loop.  Indeed, whether the system will find the simple answer ~(married Minnie Mickey)~ before it goes into the loop depends on implementation details concerning the order in which the system checks the items in the data base.  This is a very simple example of the kinds of loops that can occur.  Collections of interrelated rules can lead to loops that are much harder to anticipate, and the appearance of a loop can depend on the order of clauses in an ~and~ (see [[#exercise-4.64][Exercise 4.64]]) or on low-level details concerning the order in which the system processes queries.[fn:281]

*Problems with 'not'*

Another quirk in the query system concerns ~not~.  Given the data base of section [[#section-4.4.1][4.4.1]], consider the following two queries:

#+begin_src scheme
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))

(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
#+end_src

These two queries do not produce the same result.  The first query begins by finding all entries in the data base that match ~(supervisor ?x ?y)~, and then filters the resulting frames by removing the ones in which the value of ~?x~ satisfies ~(job ?x (computer programmer))~.  The second query begins by filtering the incoming frames to remove those that can satisfy ~(job ?x (computer programmer))~.  Since the only incoming frame is empty, it checks the data base to see if there are any patterns that satisfy ~(job ?x (computer programmer))~.  Since there generally are entries of this form, the ~not~ clause filters out the empty frame and returns an empty stream of frames.  Consequently, the entire compound query returns an empty stream.

The trouble is that our implementation of ~not~ really is meant to serve as a filter on values for the variables.  If a ~not~ clause is processed with a frame in which some of the variables remain unbound (as does ~?x~ in the example above), the system will produce unexpected results.  Similar problems occur with the use of ~lisp-value~--the Lisp predicate can't work if some of its arguments are unbound.  See [[#exercise-4.77][Exercise 4.77]].

There is also a much more serious way in which the ~not~ of the query language differs from the ~not~ of mathematical logic.  In logic, we interpret the statement "not P" to mean that P is not true.  In the query system, however, "not P" means that P is not deducible from the knowledge in the data base.  For example, given the personnel data base of section [[#section-4.4.1][4.4.1]], the system would happily deduce all sorts of ~not~ statements, such as that Ben Bitdiddle is not a baseball fan, that it is not raining outside, and that 2 + 2 is not 4.[fn:282] In other words, the ~not~ of logic programming languages reflects the so-called <<i61>> closed world assumption that all relevant information has been included in the data base.[fn:283]

**** Exercise 4.64
:properties:
:custom_id: exercise-4.64
:end:

Louis Reasoner mistakenly deletes the ~outranked-by~ rule (section [[#section-4.4.1][4.4.1]]) from the data base.  When he realizes this, he quickly reinstalls it.  Unfortunately, he makes a slight change in the rule, and types it in as

#+begin_src scheme
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
#+end_src

Just after Louis types this information into the system, DeWitt Aull comes by to find out who outranks Ben Bitdiddle.  He issues the query

#+begin_src scheme
(outranked-by (Bitdiddle Ben) ?who)
#+end_src

After answering, the system goes into an infinite loop.  Explain why.

**** Exercise 4.65
:properties:
:custom_id: exercise-4.65
:end:

Cy D. Fect, looking forward to the day when he will rise in the organization, gives a query to find all the wheels (using the ~wheel~ rule of section [[#section-4.4.1][4.4.1]]):

#+begin_src scheme
(wheel ?who)
#+end_src

To his surprise, the system responds

#+begin_src scheme
;;; Query results:
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
#+end_src

Why is Oliver Warbucks listed four times?

**** Exercise 4.66
:properties:
:custom_id: exercise-4.66
:end:

Ben has been generalizing the query system to provide statistics about the company.  For example, to find the total salaries of all the computer programmers one will be able to say

#+begin_src scheme
(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))
#+end_src

In general, Ben's new system allows expressions of the form

#+begin_src scheme
(accumulation-function <VARIABLE>
                       <QUERY PATTERN>)
#+end_src

where ~accumulation-function~ can be things like ~sum~, ~average~, or ~maximum~.  Ben reasons that it should be a cinch to implement this.  He will simply feed the query pattern to ~qeval~.  This will produce a stream of frames.  He will then pass this stream through a mapping function that extracts the value of the designated variable from each frame in the stream and feed the resulting stream of values to the accumulation function.  Just as Ben completes the implementation and is about to try it out, Cy walks by, still puzzling over the ~wheel~ query result in exercise [[#exercise-4.65][Exercise 4.65]].  When Cy shows Ben the system's response, Ben groans, "Oh, no, my simple accumulation scheme won't work!"

What has Ben just realized?  Outline a method he can use to salvage the situation.

**** Exercise 4.67
:properties:
:custom_id: exercise-4.67
:end:

Devise a way to install a loop detector in the query system so as to avoid the kinds of simple loops illustrated in the text and in [[#exercise-4.64][Exercise 4.64]].  The general idea is that the system should maintain some sort of history of its current chain of deductions and should not begin processing a query that it is already working on.  Describe what kind of information (patterns and frames) is included in this history, and how the check should be made.  (After you study the details of the query-system implementation in section [[#section-4.4.4][4.4.4]], you may want to modify the system to include your loop detector.)

**** Exercise 4.68
:properties:
:custom_id: exercise-4.68
:end:

Define rules to implement the ~reverse~ operation of [[#exercise-2.18][Exercise 2.18]], which returns a list containing the same elements as a given list in reverse order.  (Hint: Use ~append-to-form~.)  Can your rules answer both ~(reverse (1 2 3) ?x)~ and ~(reverse ?x (1 2 3))~ ?

**** Exercise 4.69
:properties:
:custom_id: exercise-4.69
:end:

Beginning with the data base and the rules you formulated in [[#exercise-4.63][Exercise 4.63]], devise a rule for adding "greats" to a grandson relationship.  This should enable the system to deduce that Irad is the great-grandson of Adam, or that Jabal and Jubal are the great-great-great-great-great-grandsons of Adam.  (Hint: Represent the fact about Irad, for example, as ~((great grandson) Adam Irad)~.  Write rules that determine if a list ends in the word ~grandson~.  Use this to express a rule that allows one to derive the relationship ~((great .  ?rel) ?x ?y)~, where ~?rel~ is a list ending in ~grandson~.)  Check your rules on queries such as ~((great grandson) ?g ?ggs)~ and ~(?relationship Adam Irad)~.

*** 4.4.4 Implementing the Query System
:properties:
:custom_id: section-4.4.4
:end:

Section [[#section-4.4.2][4.4.2]] described how the query system works.  Now we fill in the details by presenting a complete implementation of the system.

**** 4.4.4.1 The Driver Loop and Instantiation
:properties:
:custom_id: section-4.4.4.1
:end:

The driver loop for the query system repeatedly reads input expressions.  If the expression is a rule or assertion to be added to the data base, then the information is added.  Otherwise the expression is assumed to be a query.  The driver passes this query to the evaluator ~qeval~ together with an initial frame stream consisting of a single empty frame.  The result of the evaluation is a stream of frames generated by satisfying the query with variable values found in the data base.  These frames are used to form a new stream consisting of copies of the original query in which the variables are instantiated with values supplied by the stream of frames, and this final stream is printed at the terminal:

#+begin_src scheme
(define input-prompt ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate q
                   frame
                 (lambda (v f)
                   (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
#+end_src

Here, as in the other evaluators in this chapter, we use an abstract syntax for the expressions of the query language.  The implementation of the expression syntax, including the predicate ~assertion-to-be-added?~ and the selector ~add-assertion-body~, is given in section [[#section-4.4.4.7][4.4.4.7]].  ~add-rule-or-assertion!~ is defined in section [[#section-4.4.4.5][4.4.4.5]].

Before doing any processing on an input expression, the driver loop transforms it syntactically into a form that makes the processing more efficient.  This involves changing the representation of pattern variables.  When the query is instantiated, any variables that remain unbound are transformed back to the input representation before being printed.  These transformations are performed by the two procedures ~query-syntax-process~ and ~contract-question-mark~ (section [[#section-4.4.4.7][4.4.4.7]]).

To instantiate an expression, we copy it, replacing any variables in the expression by their values in a given frame.  The values are themselves instantiated, since they could contain variables (for example, if ~?x~ in ~exp~ is bound to ~?y~ as the result of unification and ~?y~ is in turn bound to 5).  The action to take if a variable cannot be instantiated is given by a procedural argument to ~instantiate~.

#+begin_src scheme
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
#+end_src

The procedures that manipulate bindings are defined in section [[#section-4.4.4.8][4.4.4.8]].

**** 4.4.4.2 The Evaluator
:properties:
:custom_id: section-4.4.4.2
:end:

The ~qeval~ procedure, called by the ~query-driver-loop~, is the basic evaluator of the query system.  It takes as inputs a query and a stream of frames, and it returns a stream of extended frames.  It identifies special forms by a data-directed dispatch using ~get~ and ~put~, just as we did in implementing generic operations in [[#section-2][Chapter 2]].  Any query that is not identified as a special form is assumed to be a simple query, to be processed by ~simple-query~.

#+begin_src scheme
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
#+end_src

~type~ and ~contents~, defined in section [[#section-4.4.4.7][4.4.4.7]], implement the abstract syntax of the special forms.

*Simple queries*

The ~simple-query~ procedure handles simple queries.  It takes as arguments a simple query (a pattern) together with a stream of frames, and it returns the stream formed by extending each frame by all data-base matches of the query.

#+begin_src scheme
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
#+end_src

For each frame in the input stream, we use ~find-assertions~ (section [[#section-4.4.4.3][4.4.4.3]]) to match the pattern against all assertions in the data base, producing a stream of extended frames, and we use ~apply-rules~ (section [[#section-4.4.4.4][4.4.4.4]]) to apply all possible rules, producing another stream of extended frames.  These two streams are combined (using ~stream-append-delayed~, section [[#section-4.4.4.6][4.4.4.6]]) to make a stream of all the ways that the given pattern can be satisfied consistent with the original frame (see [[#exercise-4.71][Exercise 4.71]]).  The streams for the individual input frames are combined using ~stream-flatmap~ (section [[#section-4.4.4.6][4.4.4.6]]) to form one large stream of all the ways that any of the frames in the original input stream can be extended to produce a match with the given pattern.

*Compound queries*

~and~ queries are handled as illustrated in [[figure-4.5][Figure 4.5]] by the ~conjoin~ procedure.  ~conjoin~ takes as inputs the conjuncts and the frame stream and returns the stream of extended frames.  First, ~conjoin~ processes the stream of frames to find the stream of all possible frame extensions that satisfy the first query in the conjunction.  Then, using this as the new frame stream, it recursively applies ~conjoin~ to the rest of the queries.

#+begin_src scheme
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
#+end_src

The expression

#+begin_src scheme
(put 'and 'qeval conjoin)
#+end_src

sets up ~qeval~ to dispatch to ~conjoin~ when an ~and~ form is encountered.

~or~ queries are handled similarly, as shown in [[figure-4.6][Figure 4.6]].  The output streams for the various disjuncts of the ~or~ are computed separately and merged using the ~interleave-delayed~ procedure from section [[#section-4.4.4.6][4.4.4.6]].  (See [[#exercise-4.71][Exercise 4.71]] and [[#exercise-4.72][Exercise 4.72]].)

#+begin_src scheme
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))

(put 'or 'qeval disjoin)
#+end_src

The predicates and selectors for the syntax of conjuncts and disjuncts are given in section [[#section-4.4.4.7][4.4.4.7]].

*Filters*

~not~ is handled by the method outlined in section [[#section-4.4.2][4.4.2]].  We attempt to extend each frame in the input stream to satisfy the query being negated, and we include a given frame in the output stream only if it cannot be extended.

#+begin_src scheme
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'not 'qeval negate)
#+end_src

~lisp-value~ is a filter similar to ~not~.  Each frame in the stream is used to instantiate the variables in the pattern, the indicated predicate is applied, and the frames for which the predicate returns false are filtered out of the input stream.  An error results if there are unbound pattern variables.

#+begin_src scheme
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
              call
              frame
            (lambda (v f)
              (error "Unknown pat var - LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))

(put 'lisp-value 'qeval lisp-value)
#+end_src

~execute~, which applies the predicate to the arguments, must ~eval~ the predicate expression to get the procedure to apply.  However, it must not evaluate the arguments, since they are already the actual arguments, not expressions whose evaluation (in Lisp) will produce the arguments.  Note that ~execute~ is implemented using ~eval~ and ~apply~ from the underlying Lisp system.

#+begin_src scheme
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
#+end_src

The ~always-true~ special form provides for a query that is always satisfied.  It ignores its contents (normally empty) and simply passes through all the frames in the input stream.  ~always-true~ is used by the ~rule-body~ selector (section [[#section-4.4.4.7][4.4.4.7]]) to provide bodies for rules that were defined without bodies (that is, rules whose conclusions are always satisfied).

#+begin_src scheme
(define (always-true ignore frame-stream) frame-stream)

(put 'always-true 'qeval always-true)
#+end_src

The selectors that define the syntax of ~not~ and ~lisp-value~ are given in section [[#section-4.4.4.7][4.4.4.7]].

**** 4.4.4.3 Finding Assertions by Pattern Matching
:properties:
:custom_id: section-4.4.4.3
:end:

~find-assertions~, called by ~simple-query~ (section [[#section-4.4.4.2][4.4.4.2]]), takes as input a pattern and a frame.  It returns a stream of frames, each extending the given one by a data-base match of the given pattern.  It uses ~fetch-assertions~ (section [[#section-4.4.4.5][4.4.4.5]]) to get a stream of all the assertions in the data base that should be checked for a match against the pattern and the frame.  The reason for ~fetch-assertions~ here is that we can often apply simple tests that will eliminate many of the entries in the data base from the pool of candidates for a successful match.  The system would still work if we eliminated ~fetch-assertions~ and simply checked a stream of all assertions in the data base, but the computation would be less efficient because we would need to make many more calls to the matcher.

#+begin_src scheme
(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
#+end_src

~check-an-assertion~ takes as arguments a pattern, a data object (assertion), and a frame and returns either a one-element stream containing the extended frame or ~the-empty-stream~ if the match fails.

#+begin_src scheme
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
#+end_src

The basic pattern matcher returns either the symbol ~failed~ or an extension of the given frame.  The basic idea of the matcher is to check the pattern against the data, element by element, accumulating bindings for the pattern variables.  If the pattern and the data object are the same, the match succeeds and we return the frame of bindings accumulated so far.  Otherwise, if the pattern is a variable we extend the current frame by binding the variable to the data, so long as this is consistent with the bindings already in the frame.  If the pattern and the data are both pairs, we (recursively) match the ~car~ of the pattern against the ~car~ of the data to produce a frame; in this frame we then match the ~cdr~ of the pattern against the ~cdr~ of the data.  If none of these cases are applicable, the match fails and we return the symbol ~failed~.

#+begin_src scheme
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
#+end_src

Here is the procedure that extends a frame by adding a new binding, if this is consistent with the bindings already in the frame:

#+begin_src scheme
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
#+end_src

If there is no binding for the variable in the frame, we simply add the binding of the variable to the data.  Otherwise we match, in the frame, the data against the value of the variable in the frame.  If the stored value contains only constants, as it must if it was stored during pattern matching by ~extend-if-consistent~, then the match simply tests whether the stored and new values are the same.  If so, it returns the unmodified frame; if not, it returns a failure indication.  The stored value may, however, contain pattern variables if it was stored during unification (see section [[#section-4.4.4.4][4.4.4.4]]).  The recursive match of the stored pattern against the new data will add or check bindings for the variables in this pattern.  For example, suppose we have a frame in which ~?x~ is bound to ~(f ?y)~ and ~?y~ is unbound, and we wish to augment this frame by a binding of ~?x~ to ~(f b)~.  We look up ~?x~ and find that it is bound to ~(f ?y)~.  This leads us to match ~(f ?y)~ against the proposed new value ~(f b)~ in the same frame.  Eventually this match extends the frame by adding a binding of ~?y~ to ~b~.  ~?X~ remains bound to ~(f ?y)~.  We never modify a stored binding and we never store more than one binding for a given variable.

The procedures used by ~extend-if-consistent~ to manipulate bindings are defined in section [[#section-4.4.4.8][4.4.4.8]].

*Patterns with dotted tails*

If a pattern contains a dot followed by a pattern variable, the pattern variable matches the rest of the data list (rather than the next element of the data list), just as one would expect with the dotted-tail notation described in [[#exercise-2.20][Exercise 2.20]].  Although the pattern matcher we have just implemented doesn't look for dots, it does behave as we want.  This is because the Lisp ~read~ primitive, which is used by ~query-driver-loop~ to read the query and represent it as a list structure, treats dots in a special way.

When ~read~ sees a dot, instead of making the next item be the next element of a list (the ~car~ of a ~cons~ whose ~cdr~ will be the rest of the list) it makes the next item be the ~cdr~ of the list structure.  For example, the list structure produced by ~read~ for the pattern ~(computer ?type)~ could be constructed by evaluating the expression ~(cons 'computer (cons '?type '()))~, and that for ~(computer .  ?type)~ could be constructed by evaluating the expression ~(cons 'computer '?type)~.

Thus, as ~pattern-match~ recursively compares 'car's and 'cdr's of a data list and a pattern that had a dot, it eventually matches the variable after the dot (which is a ~cdr~ of the pattern) against a sublist of the data list, binding the variable to that list.  For example, matching the pattern ~(computer .  ?type)~ against ~(computer programmer trainee)~ will match ~?type~ against the list ~(programmer trainee)~.

**** 4.4.4.4 Rules and Unification
:properties:
:custom_id: section-4.4.4.4
:end:

~apply-rules~ is the rule analog of ~find-assertions~ (section [[#section-4.4.4.3][4.4.4.3]]).  It takes as input a pattern and a frame, and it forms a stream of extension frames by applying rules from the data base.  ~stream-flatmap~ maps ~apply-a-rule~ down the stream of possibly applicable rules (selected by ~fetch-rules~, section [[#section-4.4.4.5][4.4.4.5]]) and combines the resulting streams of frames.

#+begin_src scheme
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
#+end_src

~apply-a-rule~ applies rules using the method outlined in section [[#section-4.4.2][4.4.2]].  It first augments its argument frame by unifying the rule conclusion with the pattern in the given frame.  If this succeeds, it evaluates the rule body in this new frame.

Before any of this happens, however, the program renames all the variables in the rule with unique new names.  The reason for this is to prevent the variables for different rule applications from becoming confused with each other.  For instance, if two rules both use a variable named ~?x~, then each one may add a binding for ~?x~ to the frame when it is applied.  These two ~?x~'s have nothing to do with each other, and we should not be fooled into thinking that the two bindings must be consistent.  Rather than rename variables, we could devise a more clever environment structure; however, the renaming approach we have chosen here is the most straightforward, even if not the most efficient.  (See [[#exercise-4.79][Exercise 4.79]].)  Here is the ~apply-a-rule~ procedure:

#+begin_src scheme
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
#+end_src

The selectors ~rule-body~ and ~conclusion~ that extract parts of a rule are defined in section [[#section-4.4.4.7][4.4.4.7]].

We generate unique variable names by associating a unique identifier (such as a number) with each rule application and combining this identifier with the original variable names.  For example, if the rule-application identifier is 7, we might change each ~?x~ in the rule to ~?x-7~ and each ~?y~ in the rule to ~?y-7~.  (~make-new-variable~ and ~new-rule-application-id~ are included with the syntax procedures in section [[#section-4.4.4.7][4.4.4.7]].)

#+begin_src scheme
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
#+end_src

The unification algorithm is implemented as a procedure that takes as inputs two patterns and a frame and returns either the extended frame or the symbol ~failed~.  The unifier is like the pattern matcher except that it is symmetrical--variables are allowed on both sides of the match.  ~unify-match~ is basically the same as ~pattern-match~, except that there is extra code (marked "~***~" below) to handle the case where the object on the right side of the match is a variable.

#+begin_src scheme
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame)) ; ***
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
#+end_src

In unification, as in one-sided pattern matching, we want to accept a proposed extension of the frame only if it is consistent with existing bindings.  The procedure ~extend-if-possible~ used in unification is the same as the ~extend-if-consistent~ used in pattern matching except for two special checks, marked "~***~" in the program below.  In the first case, if the variable we are trying to match is not bound, but the value we are trying to match it with is itself a (different) variable, it is necessary to check to see if the value is bound, and if so, to match its value.  If both parties to the match are unbound, we may bind either to the other.

The second check deals with attempts to bind a variable to a pattern that includes that variable.  Such a situation can occur whenever a variable is repeated in both patterns.  Consider, for example, unifying the two patterns ~(?x ?x)~ and '(?y <EXPRESSION INVOLVING ~?Y~>)' in a frame where both ~?x~ and ~?y~ are unbound.  First ~?x~ is matched against ~?y~, making a binding of ~?x~ to ~?y~.  Next, the same ~?x~ is matched against the given expression involving ~?y~.  Since ~?x~ is already bound to ~?y~, this results in matching ~?y~ against the expression.  If we think of the unifier as finding a set of values for the pattern variables that make the patterns the same, then these patterns imply instructions to find a ~?y~ such that ~?y~ is equal to the expression involving ~?y~.  There is no general method for solving such equations, so we reject such bindings; these cases are recognized by the predicate ~depends-on?~.[fn:284] On the other hand, we do not want to reject attempts to bind a variable to itself.  For example, consider unifying ~(?x ?x)~ and ~(?y ?y)~.  The second attempt to bind ~?x~ to ~?y~ matches ~?y~ (the stored value of ~?x~) against ~?y~ (the new value of ~?x~).  This is taken care of by the ~equal?~ clause of ~unify-match~.

#+begin_src scheme
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                   ; ***
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)  ; ***
           'failed)
          (else (extend var val frame)))))
#+end_src

~depends-on?~ is a predicate that tests whether an expression proposed to be the value of a pattern variable depends on the variable.  This must be done relative to the current frame because the expression may contain occurrences of a variable that already has a value that depends on our test variable.  The structure of ~depends-on?~ is a simple recursive tree walk in which we substitute for the values of variables whenever necessary.

#+begin_src scheme
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
#+end_src

**** 4.4.4.5 Maintaining the Data Base
:properties:
:custom_id: section-4.4.4.5
:end:

One important problem in designing logic programming languages is that of arranging things so that as few irrelevant data-base entries as possible will be examined in checking a given pattern.  In our system, in addition to storing all assertions in one big stream, we store all assertions whose 'car's are constant symbols in separate streams, in a table indexed by the symbol.  To fetch an assertion that may match a pattern, we first check to see if the ~car~ of the pattern is a constant symbol.  If so, we return (to be tested using the matcher) all the stored assertions that have the same ~car~.  If the pattern's ~car~ is not a constant symbol, we return all the stored assertions.  Cleverer methods could also take advantage of information in the frame, or try also to optimize the case where the ~car~ of the pattern is not a constant symbol.  We avoid building our criteria for indexing (using the ~car~, handling only the case of constant symbols) into the program; instead we call on predicates and selectors that embody our criteria.

#+begin_src scheme
(define THE-ASSERTIONS the-empty-stream)

(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))

(define (get-all-assertions) THE-ASSERTIONS)

(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
#+end_src

~get-stream~ looks up a stream in the table and returns an empty stream if nothing is stored there.

#+begin_src scheme
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
#+end_src

Rules are stored similarly, using the ~car~ of the rule conclusion.  Rule conclusions are arbitrary patterns, however, so they differ from assertions in that they can contain variables.  A pattern whose ~car~ is a constant symbol can match rules whose conclusions start with a variable as well as rules whose conclusions have the same ~car~.  Thus, when fetching rules that might match a pattern whose ~car~ is a constant symbol we fetch all rules whose conclusions start with a variable as well as those whose conclusions have the same ~car~ as the pattern.  For this purpose we store all rules whose conclusions start with a variable in a separate stream in our table, indexed by the symbol ~?~.

#+begin_src scheme
(define THE-RULES the-empty-stream)

(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))

(define (get-all-rules) THE-RULES)

(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
#+end_src

~add-rule-or-assertion!~ is used by ~query-driver-loop~ to add assertions and rules to the data base.  Each item is stored in the index, if appropriate, and in a stream of all assertions or rules in the data base.

#+begin_src scheme
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))

(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
      (cons-stream assertion old-assertions))
    'ok))

(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
#+end_src

To actually store an assertion or a rule, we check to see if it can be indexed.  If so, we store it in the appropriate stream.

#+begin_src scheme
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream assertion
                            current-assertion-stream))))))

(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
#+end_src

The following procedures define how the data-base index is used.  A pattern (an assertion or a rule conclusion) will be stored in the table if it starts with a variable or a constant symbol.

#+begin_src scheme
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
#+end_src

The key under which a pattern is stored in the table is either ~?~ (if it starts with a variable) or the constant symbol with which it starts.

#+begin_src scheme
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
#+end_src

The index will be used to retrieve items that might match a pattern if the pattern starts with a constant symbol.

#+begin_src scheme
(define (use-index? pat)
  (constant-symbol? (car pat)))
#+end_src

**** Exercise 4.70
:properties:
:custom_id: exercise-4.70
:end:

What is the purpose of the ~let~ bindings in the procedures ~add-assertion!~ and ~add-rule!~ ?  What would be wrong with the following implementation of ~add-assertion!~ ?  Hint: Recall the definition of the infinite stream of ones in section [[#section-3.5.2][3.5.2]]: ~(define ones (cons-stream 1 ones))~.

#+begin_src scheme
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
    (cons-stream assertion THE-ASSERTIONS))
  'ok)
#+end_src

**** 4.4.4.6 Stream Operations
:properties:
:custom_id: section-4.4.4.6
:end:

The query system uses a few stream operations that were not presented in [[#section-3][Chapter 3]].

~stream-append-delayed~ and ~interleave-delayed~ are just like ~stream-append~ and ~interleave~ (section [[#section-3.5.3][3.5.3]]), except that they take a delayed argument (like the ~integral~ procedure in section [[#section-3.5.4][3.5.4]]).  This postpones looping in some cases (see [[#exercise-4.71][Exercise 4.71]]).

#+begin_src scheme
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))

(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
#+end_src

~stream-flatmap~, which is used throughout the query evaluator to map a procedure over a stream of frames and combine the resulting streams of frames, is the stream analog of the ~flatmap~ procedure introduced for ordinary lists in section [[#section-2.2.3][2.2.3]].  Unlike ordinary ~flatmap~, however, we accumulate the streams with an interleaving process, rather than simply appending them (see [[#exercise-4.72][Exercise 4.72]] and [[#exercise-4.73][Exercise 4.73]]).

#+begin_src scheme
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
#+end_src

The evaluator also uses the following simple procedure to generate a stream consisting of a single element:

#+begin_src scheme
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
#+end_src

**** 4.4.4.7 Query Syntax Procedures
:properties:
:custom_id: section-4.4.4.7
:end:

~type~ and ~contents~, used by ~qeval~ (section [[#section-4.4.4.2][4.4.4.2]]), specify that a special form is identified by the symbol in its ~car~.  They are the same as the ~type-tag~ and ~contents~ procedures in section [[#section-2.4.2][2.4.2]], except for the error message.

#+begin_src scheme
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))

(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
#+end_src

The following procedures, used by ~query-driver-loop~ (in section [[#section-4.4.4.1][4.4.4.1]]), specify that rules and assertions are added to the data base by expressions of the form '(assert! <RULE-OR-ASSERTION>)':

#+begin_src scheme
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))

(define (add-assertion-body exp)
  (car (contents exp)))
#+end_src

Here are the syntax definitions for the ~and~, ~or~, ~not~, and ~lisp-value~ special forms (section [[#section-4.4.4.2][4.4.4.2]]):

#+begin_src scheme
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))

(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))

(define (negated-query exps) (car exps))

(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
#+end_src

The following three procedures define the syntax of rules:

#+begin_src scheme
(define (rule? statement)
  (tagged-list? statement 'rule))

(define (conclusion rule) (cadr rule))

(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (caddr rule)))
#+end_src

~query-driver-loop~ (section [[#section-4.4.4.1][4.4.4.1]]) calls ~query-syntax-process~ to transform pattern variables in the expression, which have the form ~?symbol~, into the internal format ~(?  symbol)~.  That is to say, a pattern such as ~(job ?x ?y)~ is actually represented internally by the system as ~(job (?  x) (?  y))~.  This increases the efficiency of query processing, since it means that the system can check to see if an expression is a pattern variable by checking whether the ~car~ of the expression is the symbol ~?~, rather than having to extract characters from the symbol.  The syntax transformation is accomplished by the following procedure:[fn:285]

#+begin_src scheme
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))

(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))

(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
#+end_src

Once the variables are transformed in this way, the variables in a pattern are lists starting with ~?~, and the constant symbols (which need to be recognized for data-base indexing, section [[#section-4.4.4.5][4.4.4.5]]) are just the symbols.

#+begin_src scheme
(define (var? exp)
  (tagged-list? exp '?))

(define (constant-symbol? exp) (symbol? exp))
#+end_src

Unique variables are constructed during rule application (in section [[#section-4.4.4.4][4.4.4.4]]) by means of the following procedures.  The unique identifier for a rule application is a number, which is incremented each time a rule is applied.

#+begin_src scheme
(define rule-counter 0)

(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)

(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
#+end_src

When ~query-driver-loop~ instantiates the query to print the answer, it converts any unbound pattern variables back to the right form for printing, using

#+begin_src scheme
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?"
                  (if (number? (cadr variable))
                      (string-append (symbol->string (caddr variable))
                                     "-"
                                     (number->string (cadr variable)))
                      (symbol->string (cadr variable))))))
#+end_src

**** 4.4.4.8 Frames and Bindings
:properties:
:custom_id: section-4.4.4.8
:end:

Frames are represented as lists of bindings, which are variable-value pairs:

#+begin_src scheme
(define (make-binding variable value)
  (cons variable value))

(define (binding-variable binding)
  (car binding))

(define (binding-value binding)
  (cdr binding))

(define (binding-in-frame variable frame)
  (assoc variable frame))

(define (extend variable value frame)
  (cons (make-binding variable value) frame))
#+end_src

**** Exercise 4.71
:properties:
:custom_id: exercise-4.71
:end:

Louis Reasoner wonders why the ~simple-query~ and ~disjoin~ procedures (section [[#section-4.4.4.2][4.4.4.2]]) are implemented using explicit ~delay~ operations, rather than being defined as follows:

#+begin_src scheme
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append (find-assertions query-pattern frame)
                    (apply-rules query-pattern frame)))
   frame-stream))

(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts) frame-stream)
       (disjoin (rest-disjuncts disjuncts) frame-stream))))
#+end_src

Can you give examples of queries where these simpler definitions would lead to undesirable behavior?

**** Exercise 4.72
:properties:
:custom_id: exercise-4.72
:end:

Why do ~disjoin~ and ~stream-flatmap~ interleave the streams rather than simply append them?  Give examples that illustrate why interleaving works better.  (Hint: Why did we use ~interleave~ in section [[#section-3.5.3][3.5.3]]?)

**** Exercise 4.73
:properties:
:custom_id: exercise-4.73
:end:

Why does ~flatten-stream~ use ~delay~ explicitly?  What would be wrong with defining it as follows:

#+begin_src scheme
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
#+end_src

**** Exercise 4.74
:properties:
:custom_id: exercise-4.74
:end:

Alyssa P. Hacker proposes to use a simpler version of ~stream-flatmap~ in ~negate~, ~lisp-value~, and ~find-assertions~.  She observes that the procedure that is mapped over the frame stream in these cases always produces either the empty stream or a singleton stream, so no interleaving is needed when combining these streams.

a. Fill in the missing expressions in Alyssa's program.

#+begin_src scheme
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map <??>
              (stream-filter <??> stream)))
#+end_src

b. Does the query system's behavior change if we change it in this way?

**** Exercise 4.75
:properties:
:custom_id: exercise-4.75
:end:

Implement for the query language a new special form called ~unique~.  ~unique~ should succeed if there is precisely one item in the data base satisfying a specified query.  For example,

#+begin_src scheme
(unique (job ?x (computer wizard)))
#+end_src

should print the one-item stream

#+begin_src scheme
(unique (job (Bitdiddle Ben) (computer wizard)))
#+end_src

since Ben is the only computer wizard, and

#+begin_src scheme
(unique (job ?x (computer programmer)))
#+end_src

should print the empty stream, since there is more than one computer programmer.  Moreover,

#+begin_src scheme
(and (job ?x ?j) (unique (job ?anyone ?j)))
#+end_src

should list all the jobs that are filled by only one person, and the people who fill them.

There are two parts to implementing ~unique~.  The first is to write a procedure that handles this special form, and the second is to make ~qeval~ dispatch to that procedure.  The second part is trivial, since ~qeval~ does its dispatching in a data-directed way.  If your procedure is called ~uniquely-asserted~, all you need to do is

#+begin_src scheme
(put 'unique 'qeval uniquely-asserted)
#+end_src

and ~qeval~ will dispatch to this procedure for every query whose ~type~ (~car~) is the symbol ~unique~.

The real problem is to write the procedure ~uniquely-asserted~.  This should take as input the ~contents~ (~cdr~) of the ~unique~ query, together with a stream of frames.  For each frame in the stream, it should use ~qeval~ to find the stream of all extensions to the frame that satisfy the given query.  Any stream that does not have exactly one item in it should be eliminated.  The remaining streams should be passed back to be accumulated into one big stream that is the result of the ~unique~ query.  This is similar to the implementation of the ~not~ special form.

Test your implementation by forming a query that lists all people who supervise precisely one person.

**** Exercise 4.76
:properties:
:custom_id: exercise-4.76
:end:

Our implementation of ~and~ as a series combination of queries ([[figure-4.5][Figure 4.5]]) is elegant, but it is inefficient because in processing the second query of the ~and~ we must scan the data base for each frame produced by the first query.  If the data base has n elements, and a typical query produces a number of output frames proportional to n (say n/k), then scanning the data base for each frame produced by the first query will require n^2/k calls to the pattern matcher.  Another approach would be to process the two clauses of the ~and~ separately, then look for all pairs of output frames that are compatible.  If each query produces n/k output frames, then this means that we must perform n^2/k^2 compatibility checks--a factor of k fewer than the number of matches required in our current method.

Devise an implementation of ~and~ that uses this strategy.  You must implement a procedure that takes two frames as inputs, checks whether the bindings in the frames are compatible, and, if so, produces a frame that merges the two sets of bindings.  This operation is similar to unification.

**** Exercise 4.77
:properties:
:custom_id: exercise-4.77
:end:

In section [[#section-4.4.3][4.4.3]] we saw that ~not~ and ~lisp-value~ can cause the query language to give "wrong" answers if these filtering operations are applied to frames in which variables are unbound.  Devise a way to fix this shortcoming.  One idea is to perform the filtering in a "delayed" manner by appending to the frame a "promise" to filter that is fulfilled only when enough variables have been bound to make the operation possible.  We could wait to perform filtering until all other operations have been performed.  However, for efficiency's sake, we would like to perform filtering as soon as possible so as to cut down on the number of intermediate frames generated.

**** Exercise 4.78
:properties:
:custom_id: exercise-4.78
:end:

Redesign the query language as a nondeterministic program to be implemented using the evaluator of section [[#section-4.3][4.3]], rather than as a stream process.  In this approach, each query will produce a single answer (rather than the stream of all answers) and the user can type ~try-again~ to see more answers.  You should find that much of the mechanism we built in this section is subsumed by nondeterministic search and backtracking.  You will probably also find, however, that your new query language has subtle differences in behavior from the one implemented here.  Can you find examples that illustrate this difference?

**** Exercise 4.79
:properties:
:custom_id: exercise-4.79
:end:

When we implemented the Lisp evaluator in section [[#section-4.1][4.1]], we saw how to use local environments to avoid name conflicts between the parameters of procedures.  For example, in evaluating

#+begin_src scheme
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
#+end_src

there is no confusion between the ~x~ in ~square~ and the ~x~ in ~sum-of-squares~, because we evaluate the body of each procedure in an environment that is specially constructed to contain bindings for the local variables.  In the query system, we used a different strategy to avoid name conflicts in applying rules.  Each time we apply a rule we rename the variables with new names that are guaranteed to be unique.  The analogous strategy for the Lisp evaluator would be to do away with local environments and simply rename the variables in the body of a procedure each time we apply the procedure.

Implement for the query language a rule-application method that uses environments rather than renaming.  See if you can build on your environment structure to create constructs in the query language for dealing with large systems, such as the rule analog of block-structured procedures.  Can you relate any of this to the problem of making deductions in a context (e.g., "If I supposed that P were true, then I would be able to deduce A and B.") as a method of problem solving?  (This problem is open-ended.  A good answer is probably worth a Ph.D.)
