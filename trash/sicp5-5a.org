** 5.5 Compilation
:properties:
:custom_id: section-5.5
:end:

The explicit-control evaluator of section [[#section-5.4][5.4]] is a register machine whose controller interprets Scheme programs.  In this section we will see how to run Scheme programs on a register machine whose controller is not a Scheme interpreter.

The explicit-control evaluator machine is universal--it can carry out any computational process that can be described in Scheme.  The evaluator's controller orchestrates the use of its data paths to perform the desired computation.  Thus, the evaluator's data paths are universal: They are sufficient to perform any computation we desire, given an appropriate controller.[fn:318]

Commercial general-purpose computers are register machines organized around a collection of registers and operations that constitute an efficient and convenient universal set of data paths.  The controller for a general-purpose machine is an interpreter for a register-machine language like the one we have been using.  This language is called the <<i251>> native language of the machine, or simply <<i223>> machine language.  Programs written in machine language are sequences of instructions that use the machine's data paths.  For example, the explicit-control evaluator's instruction sequence can be thought of as a machine-language program for a general-purpose computer rather than as the controller for a specialized interpreter machine.

There are two common strategies for bridging the gap between higher-level languages and register-machine languages.  The explicit-control evaluator illustrates the strategy of interpretation.  An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the <<i357>> source language) that may differ from the native language of the machine performing the evaluation.  The primitive procedures of the source language are implemented as a library of subroutines written in the native language of the given machine.  A program to be interpreted (called the <<i358>> source program) is represented as a data structure.  The interpreter traverses this data structure, analyzing the source program.  As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library.

In this section, we explore the alternative strategy of <<i70>> compilation.  A compiler for a given source language and machine translates a source program into an equivalent program (called the <<i266>> object program) written in the machine's native language.  The compiler that we implement in this section translates programs written in Scheme into sequences of instructions to be executed using the explicit-control evaluator machine's data paths.[fn:319]

Compared with interpretation, compilation can provide a great increase in the efficiency of program execution, as we will explain below in the overview of the compiler.  On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified.  In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging.

In view of the complementary advantages of compilation and interpretation, modern program-development environments pursue a mixed strategy.  Lisp interpreters are generally organized so that interpreted procedures and compiled procedures can call each other.  This enables a programmer to compile those parts of a program that are assumed to be debugged, thus gaining the efficiency advantage of compilation, while retaining the interpretive mode of execution for those parts of the program that are in the flux of interactive development and debugging.  In section [[#section-5.5.7][5.5.7]], after we have implemented the compiler, we will show how to interface it with our interpreter to produce an integrated interpreter-compiler development system.

*An overview of the compiler*

Our compiler is much like our interpreter, both in its structure and in the function it performs.  Accordingly, the mechanisms used by the compiler for analyzing expressions will be similar to those used by the interpreter.  Moreover, to make it easy to interface compiled and interpreted code, we will design the compiler to generate code that obeys the same conventions of register usage as the interpreter: The environment will be kept in the ~env~ register, argument lists will be accumulated in ~argl~, a procedure to be applied will be in ~proc~, procedures will return their answers in ~val~, and the location to which a procedure should return will be kept in ~continue~.  In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program.

This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression in the same way the interpreter does.  When we encounter a register instruction that the interpreter would perform in evaluating the expression, we do not execute the instruction but instead accumulate it into a sequence.  The resulting sequence of instructions will be the object code.  Observe the efficiency advantage of compilation over interpretation.  Each time the interpreter evaluates an expression--for example, ~(f 84 96)~--it performs the work of classifying the expression (discovering that this is a procedure application) and testing for the end of the operand list (discovering that there are two operands).  With a compiler, the expression is analyzed only once, when the instruction sequence is generated at compile time.  The object code produced by the compiler contains only the instructions that evaluate the operator and the two operands, assemble the argument list, and apply the procedure (in ~proc~) to the arguments (in ~argl~).

This is the same kind of optimization we implemented in the analyzing evaluator of section [[#section-4.1.7][4.1.7]].  But there are further opportunities to gain efficiency in compiled code.  As the interpreter runs, it follows a process that must be applicable to any expression in the language.  In contrast, a given segment of compiled code is meant to execute some particular expression.  This can make a big difference, for example in the use of the stack to save registers.  When the interpreter evaluates an expression, it must be prepared for any contingency.  Before evaluating a subexpression, the interpreter saves all registers that will be needed later, because the subexpression might require an arbitrary evaluation.  A compiler, on the other hand, can exploit the structure of the particular expression it is processing to generate code that avoids unnecessary stack operations.

As a case in point, consider the combination ~(f 84 96)~.  Before the interpreter evaluates the operator of the combination, it prepares for this evaluation by saving the registers containing the operands and the environment, whose values will be needed later.  The interpreter then evaluates the operator to obtain the result in ~val~, restores the saved registers, and finally moves the result from ~val~ to ~proc~.  However, in the particular expression we are dealing with, the operator is the symbol ~f~, whose evaluation is accomplished by the machine operation ~lookup-variable-value~, which does not alter any registers.  The compiler that we implement in this section will take advantage of this fact and generate code that evaluates the operator using the instruction

#+begin_src scheme
(assign proc (op lookup-variable-value) (const f) (reg env))
#+end_src

This code not only avoids the unnecessary saves and restores but also assigns the value of the lookup directly to ~proc~, whereas the interpreter would obtain the result in ~val~ and then move this to ~proc~.

A compiler can also optimize access to the environment.  Having analyzed the code, the compiler can in many cases know in which frame a particular variable will be located and access that frame directly, rather than performing the ~lookup-variable-value~ search.  We will discuss how to implement such variable access in section [[#section-5.5.6][5.5.6]].  Until then, however, we will focus on the kind of register and stack optimizations described above.  There are many other optimizations that can be performed by a compiler, such as coding primitive operations "in line" instead of using a general ~apply~ mechanism (see [[#exercise-5.38][Exercise 5.38]]); but we will not emphasize these here.  Our main goal in this section is to illustrate the compilation process in a simplified (but still interesting) context.

*** 5.5.1 Structure of the Compiler
:properties:
:custom_id: section-5.5.1
:end:

In section [[#section-4.1.7][4.1.7]] we modified our original metacircular interpreter to separate analysis from execution.  We analyzed each expression to produce an execution procedure that took an environment as argument and performed the required operations.  In our compiler, we will do essentially the same analysis.  Instead of producing execution procedures, however, we will generate sequences of instructions to be run by our register machine.

The procedure ~compile~ is the top-level dispatch in the compiler.  It corresponds to the ~eval~ procedure of section [[#section-4.1.1][4.1.1]], the ~analyze~ procedure of section [[#section-4.1.7][4.1.7]], and the ~eval-dispatch~ entry point of the explicit-control-evaluator in section [[#section-5.4.1][5.4.1]].  The compiler, like the interpreters, uses the expression-syntax procedures defined in section [[#section-4.1.2][4.1.2]].[fn:320] ~compile~ performs a case analysis on the syntactic type of the expression to be compiled.  For each type of expression, it dispatches to a specialized <<i64>> code generator:

#+begin_src scheme
(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence (begin-actions exp)
                           target
                           linkage))
        ((cond? exp) (compile (cond->if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Unknown expression type - COMPILE" exp))))
#+end_src

*Targets and linkages*

~compile~ and the code generators that it calls take two arguments in addition to the expression to compile.  There is a <<i392>> target, which specifies the register in which the compiled code is to return the value of the expression.  There is also a <<i209>> linkage descriptor, which describes how the code resulting from the compilation of the expression should proceed when it has finished its execution.  The linkage descriptor can require that the code do one of the following three things:

- continue at the next instruction in sequence (this is specified by the linkage descriptor ~next~),

- return from the procedure being compiled (this is specified by the linkage descriptor ~return~), or

- jump to a named entry point (this is specified by using the designated label as the linkage descriptor).

For example, compiling the expression ~5~ (which is self-evaluating) with a target of the ~val~ register and a linkage of ~next~ should produce the instruction

#+begin_src scheme
(assign val (const 5))
#+end_src

Compiling the same expression with a linkage of ~return~ should produce the instructions

#+begin_src scheme
(assign val (const 5))
(goto (reg continue))
#+end_src

In the first case, execution will continue with the next instruction in the sequence.  In the second case, we will return from a procedure call.  In both cases, the value of the expression will be placed into the target ~val~ register.

*Instruction sequences and stack usage*

Each code generator returns an <<i186>> instruction sequence containing the object code it has generated for the expression.  Code generation for a compound expression is accomplished by combining the output from simpler code generators for component expressions, just as evaluation of a compound expression is accomplished by evaluating the component expressions.

The simplest method for combining instruction sequences is a procedure called ~append-instruction-sequences~.  It takes as arguments any number of instruction sequences that are to be executed sequentially; it appends them and returns the combined sequence.  That is, if <SEQ_1> and <SEQ_2> are sequences of instructions, then evaluating

#+begin_src scheme
(append-instruction-sequences <SEQ_1> <SEQ_2>)
#+end_src

produces the sequence

#+begin_src scheme
<SEQ_1>
<SEQ_2>
#+end_src

Whenever registers might need to be saved, the compiler's code generators use ~preserving~, which is a more subtle method for combining instruction sequences.  ~preserving~ takes three arguments: a set of registers and two instruction sequences that are to be executed sequentially.  It appends the sequences in such a way that the contents of each register in the set is preserved over the execution of the first sequence, if this is needed for the execution of the second sequence.  That is, if the first sequence modifies the register and the second sequence actually needs the register's original contents, then ~preserving~ wraps a ~save~ and a ~restore~ of the register around the first sequence before appending the sequences.  Otherwise, ~preserving~ simply returns the appended instruction sequences.  Thus, for example,

#+begin_src scheme
(preserving (list <REG_1> <REG_2>) <SEQ_1> <SEQ_2>)
#+end_src

produces one of the following four sequences of instructions, depending on how <SEQ_1> and <SEQ_2> use <REG_1> and <REG_2>:

#+begin_example
 <seq_1> | (save <reg_1>)    | (save <reg_2>)    | (save <reg_2>)
 <seq_2> | <seq_1>           | <seq_1>           | (save <reg_1>)
         | (restore <reg_1>) | (restore <reg_2>) | <seq_1>
         | <seq_2>           | <seq_2>           | (restore <reg_1>)
         |                   |                   | (restore <reg_2>)
         |                   |                   | <seq_2>
#+end_example

By using ~preserving~ to combine instruction sequences the compiler avoids unnecessary stack operations.  This also isolates the details of whether or not to generate ~save~ and ~restore~ instructions within the ~preserving~ procedure, separating them from the concerns that arise in writing each of the individual code generators.  In fact no ~save~ or ~restore~ instructions are explicitly produced by the code generators.

In principle, we could represent an instruction sequence simply as a list of instructions.  ~append-instruction-sequences~ could then combine instruction sequences by performing an ordinary list ~append~.  However, ~preserving~ would then be a complex operation, because it would have to analyze each instruction sequence to determine how the sequence uses its registers.  ~preserving~ would be inefficient as well as complex, because it would have to analyze each of its instruction sequence arguments, even though these sequences might themselves have been constructed by calls to ~preserving~, in which case their parts would have already been analyzed.  To avoid such repetitious analysis we will associate with each instruction sequence some information about its register use.  When we construct a basic instruction sequence we will provide this information explicitly, and the procedures that combine instruction sequences will derive register-use information for the combined sequence from the information associated with the component sequences.

An instruction sequence will contain three pieces of information:

- the set of registers that must be initialized before the instructions in the sequence are executed (these registers are said to be <<i252>> needed by the sequence),

- the set of registers whose values are modified by the instructions in the sequence, and

- the actual instructions (also called <<i365>> statements) in the sequence.

We will represent an instruction sequence as a list of its three parts.  The constructor for instruction sequences is thus

#+begin_src scheme
(define (make-instruction-sequence needs modifies statements)
  (list needs modifies statements))
#+end_src

For example, the two-instruction sequence that looks up the value of the variable ~x~ in the current environment, assigns the result to ~val~, and then returns, requires registers ~env~ and ~continue~ to have been initialized, and modifies register ~val~.  This sequence would therefore be constructed as

#+begin_src scheme
(make-instruction-sequence
 '(env continue) '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
#+end_src

We sometimes need to construct an instruction sequence with no statements:

#+begin_src scheme
(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
#+end_src

The procedures for combining instruction sequences are shown in section [[#section-5.5.4][5.5.4]].

**** Exercise 5.31
:properties:
:custom_id: exercise-5.31
:end:

In evaluating a procedure application, the explicit-control evaluator always saves and restores the ~env~ register around the evaluation of the operator, saves and restores ~env~ around the evaluation of each operand (except the final one), saves and restores ~argl~ around the evaluation of each operand, and saves and restores ~proc~ around the evaluation of the operand sequence.  For each of the following combinations, say which of these ~save~ and ~restore~ operations are superfluous and thus could be eliminated by the compiler's ~preserving~ mechanism:

#+begin_src scheme
(f 'x 'y)

((f) 'x 'y)

(f (g 'x) y)

(f (g 'x) 'y)
#+end_src

**** Exercise 5.32
:properties:
:custom_id: exercise-5.32
:end:

Using the ~preserving~ mechanism, the compiler will avoid saving and restoring ~env~ around the evaluation of the operator of a combination in the case where the operator is a symbol.  We could also build such optimizations into the evaluator.  Indeed, the explicit-control evaluator of section [[#section-5.4][5.4]] already performs a similar optimization, by treating combinations with no operands as a special case.

a. Extend the explicit-control evaluator to recognize as a separate class of expressions combinations whose operator is a symbol, and to take advantage of this fact in evaluating such expressions.

b. Alyssa P. Hacker suggests that by extending the evaluator to recognize more and more special cases we could incorporate all the compiler's optimizations, and that this would eliminate the advantage of compilation altogether.  What do you think of this idea?

*** 5.5.2 Compiling Expressions
:properties:
:custom_id: section-5.5.2
:end:

In this section and the next we implement the code generators to which the ~compile~ procedure dispatches.

*Compiling linkage code*

In general, the output of each code generator will end with instructions--generated by the procedure ~compile-linkage~--that implement the required linkage.  If the linkage is ~return~ then we must generate the instruction ~(goto (reg continue))~.  This needs the ~continue~ register and does not modify any registers.  If the linkage is ~next~, then we needn't include any additional instructions.  Otherwise, the linkage is a label, and we generate a ~goto~ to that label, an instruction that does not need or modify any registers.[fn:321]

#+begin_src scheme
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
                                    '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
                                    '((goto (label ,linkage)))))))
#+end_src

The linkage code is appended to an instruction sequence by ~preserving~ the ~continue~ register, since a ~return~ linkage will require the ~continue~ register: If the given instruction sequence modifies ~continue~ and the linkage code needs it, ~continue~ will be saved and restored.

#+begin_src scheme
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
              instruction-sequence
              (compile-linkage linkage)))
#+end_src

*Compiling simple expressions*

The code generators for self-evaluating expressions, quotations, and variables construct instruction sequences that assign the required value to the target register and then proceed as specified by the linkage descriptor.

#+begin_src scheme
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '() (list target)
    '((assign ,target (const ,exp))))))

(define (compile-quoted exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '() (list target)
    '((assign ,target (const ,(text-of-quotation exp)))))))

(define (compile-variable exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '(env) (list target)
    '((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
#+end_src

All these assignment instructions modify the target register, and the one that looks up a variable needs the ~env~ register.

Assignments and definitions are handled much as they are in the interpreter.  We recursively generate code that computes the value to be assigned to the variable, and append to it a two-instruction sequence that actually sets or defines the variable and assigns the value of the whole expression (the symbol ~ok~) to the target register.  The recursive compilation has target ~val~ and linkage ~next~ so that the code will put its result into ~val~ and continue with the code that is appended after it.  The appending is done preserving ~env~, since the environment is needed for setting or defining the variable and the code for the variable value could be the compilation of a complex expression that might modify the registers in arbitrary ways.

#+begin_src scheme
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage
     linkage
     (preserving '(env)
                 get-value-code
                 (make-instruction-sequence
                  '(env val) (list target)
                  '((perform (op set-variable-value!)
                             (const ,var)
                             (reg val)
                             (reg env))
                    (assign ,target (const ok))))))))

(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage
     linkage
     (preserving '(env)
                 get-value-code
                 (make-instruction-sequence
                  '(env val) (list target)
                  '((perform (op define-variable!)
                             (const ,var)
                             (reg val)
                             (reg env))
                    (assign ,target (const ok))))))))
#+end_src

The appended two-instruction sequence requires ~env~ and ~val~ and modifies the target.  Note that although we preserve ~env~ for this sequence, we do not preserve ~val~, because the ~get-value-code~ is designed to explicitly place its result in ~val~ for use by this sequence.  (In fact, if we did preserve ~val~, we would have a bug, because this would cause the previous contents of ~val~ to be restored right after the ~get-value-code~ is run.)

*Compiling conditional expressions*

The code for an ~if~ expression compiled with a given target and linkage has the form

#+begin_src scheme
<compilation of predicate, target 'val', linkage 'next'>
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 <compilation of consequent with given target and given linkage or 'after-if'>
false-branch
 <compilation of alternative with given target and linkage>
after-if
#+end_src

To generate this code, we compile the predicate, consequent, and alternative, and combine the resulting code with instructions to test the predicate result and with newly generated labels to mark the true and false branches and the end of the conditional.[fn:322] In this arrangement of code, we must branch around the true branch if the test is false.  The only slight complication is in how the linkage for the true branch should be handled.  If the linkage for the conditional is ~return~ or a label, then the true and false branches will both use this same linkage.  If the linkage is ~next~, the true branch ends with a jump around the code for the false branch to the label at the end of the conditional.

#+begin_src scheme
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
                    p-code
                    (append-instruction-sequences
                     (make-instruction-sequence
                      '(val) '()
                      '((test (op false?) (reg val))
                        (branch (label ,f-branch))))
                     (parallel-instruction-sequences
                      (append-instruction-sequences t-branch c-code)
                      (append-instruction-sequences f-branch a-code))
                     after-if))))))
#+end_src

~env~ is preserved around the predicate code because it could be needed by the true and false branches, and ~continue~ is preserved because it could be needed by the linkage code in those branches.  The code for the true and false branches (which are not executed sequentially) is appended using a special combiner ~parallel-instruction-sequences~ described in section [[#section-5.5.4][5.5.4]].

Note that ~cond~ is a derived expression, so all that the compiler needs to do handle it is to apply the ~cond->if~ transformer (from section [[#section-4.1.2][4.1.2]]) and compile the resulting ~if~ expression.

*Compiling sequences*

The compilation of sequences (from procedure bodies or explicit ~begin~ expressions) parallels their evaluation.  Each expression of the sequence is compiled--the last expression with the linkage specified for the sequence, and the other expressions with linkage ~next~ (to execute the rest of the sequence).  The instruction sequences for the individual expressions are appended to form a single instruction sequence, such that ~env~ (needed for the rest of the sequence) and ~continue~ (possibly needed for the linkage at the end of the sequence) are preserved.

#+begin_src scheme
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
                  (compile (first-exp seq) target 'next)
                  (compile-sequence (rest-exps seq) target linkage))))
#+end_src

*Compiling ~lambda~ expressions*

~lambda~ expressions construct procedures.  The object code for a ~lambda~ expression must have the form

#+begin_src scheme
<construct procedure object and assign it to target register>
<LINKAGE>
#+end_src

When we compile the ~lambda~ expression, we also generate the code for the procedure body.  Although the body won't be executed at the time of procedure construction, it is convenient to insert it into the object code right after the code for the ~lambda~.  If the linkage for the ~lambda~ expression is a label or ~return~, this is fine.  But if the linkage is ~next~, we will need to skip around the code for the procedure body by using a linkage that jumps to a label that is inserted after the body.  The object code thus has the form

#+begin_src scheme
<construct procedure object and assign it to target register>
 <code for given linkage> or '(goto (label after-lambda))'
 <compilation of procedure body>
after-lambda
#+end_src

~compile-lambda~ generates the code for constructing the procedure object followed by the code for the procedure body.  The procedure object will be constructed at run time by combining the current environment (the environment at the point of definition) with the entry point to the compiled procedure body (a newly generated label).[fn:323]

#+begin_src scheme
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
                          (make-instruction-sequence
                           '(env) (list target)
                           '((assign ,target
                                     (op make-compiled-procedure)
                                     (label ,proc-entry)
                                     (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
#+end_src

~compile-lambda~ uses the special combiner ~tack-on-instruction-sequence~ (section [[#section-5.5.4][5.5.4]]) rather than ~append-instruction-sequences~ to append the procedure body to the ~lambda~ expression code, because the body is not part of the sequence of instructions that will be executed when the combined sequence is entered; rather, it is in the sequence only because that was a convenient place to put it.

~compile-lambda-body~ constructs the code for the body of the procedure.  This code begins with a label for the entry point.  Next come instructions that will cause the run-time evaluation environment to switch to the correct environment for evaluating the procedure body--namely, the definition environment of the procedure, extended to include the bindings of the formal parameters to the arguments with which the procedure is called.  After this comes the code for the sequence of expressions that makes up the procedure body.  The sequence is compiled with linkage ~return~ and target ~val~ so that it will end by returning from the procedure with the procedure result in ~val~.

#+begin_src scheme
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
                                '(,proc-entry
                                  (assign env (op compiled-procedure-env) (reg proc))
                                  (assign env
                                          (op extend-environment)
                                          (const ,formals)
                                          (reg argl)
                                          (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
#+end_src

*** 5.5.3 Compiling Combinations
:properties:
:custom_id: section-5.5.3
:end:

The essence of the compilation process is the compilation of procedure applications.  The code for a combination compiled with a given target and linkage has the form

#+begin_src scheme
<compilation of operator, target 'proc', linkage 'next'>
<evaluate operands and construct argument list in 'argl'>
<compilation of procedure call with given target and linkage>
#+end_src

The registers ~env~, ~proc~, and ~argl~ may have to be saved and restored during evaluation of the operator and operands.  Note that this is the only place in the compiler where a target other than ~val~ is specified.

The required code is generated by ~compile-application~.  This recursively compiles the operator, to produce code that puts the procedure to be applied into ~proc~, and compiles the operands, to produce code that evaluates the individual operands of the application.  The instruction sequences for the operands are combined (by ~construct-arglist~) with code that constructs the list of arguments in ~argl~, and the resulting argument-list code is combined with the procedure code and the code that performs the procedure call (produced by ~compile-procedure-call~).  In appending the code sequences, the ~env~ register must be preserved around the evaluation of the operator (since evaluating the operator might modify ~env~, which will be needed to evaluate the operands), and the ~proc~ register must be preserved around the construction of the argument list (since evaluating the operands might modify ~proc~, which will be needed for the actual procedure application).  ~continue~ must also be preserved throughout, since it is needed for the linkage in the procedure call.

#+begin_src scheme
(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
                proc-code
                (preserving '(proc continue)
                            (construct-arglist operand-codes)
                            (compile-procedure-call target linkage)))))
#+end_src

The code to construct the argument list will evaluate each operand into ~val~ and then ~cons~ that value onto the argument list being accumulated in ~argl~.  Since we ~cons~ the arguments onto ~argl~ in sequence, we must start with the last argument and end with the first, so that the arguments will appear in order from first to last in the resulting list.  Rather than waste an instruction by initializing ~argl~ to the empty list to set up for this sequence of evaluations, we make the first code sequence construct the initial ~argl~.  The general form of the argument-list construction is thus as follows:

#+begin_src scheme
<compilation of last operand, targeted to 'val'>
(assign argl (op list) (reg val))
<compilation of next operand, targeted to 'val'>
(assign argl (op cons) (reg val) (reg argl))
...
<compilation of first operand, targeted to 'val'>
(assign argl (op cons) (reg val) (reg argl))
#+end_src

~argl~ must be preserved around each operand evaluation except the first (so that arguments accumulated so far won't be lost), and ~env~ must be preserved around each operand evaluation except the last (for use by subsequent operand evaluations).

Compiling this argument code is a bit tricky, because of the special treatment of the first operand to be evaluated and the need to preserve ~argl~ and ~env~ in different places.  The ~construct-arglist~ procedure takes as arguments the code that evaluates the individual operands.  If there are no operands at all, it simply emits the instruction

#+begin_src scheme
(assign argl (const ()))
#+end_src

Otherwise, ~construct-arglist~ creates code that initializes ~argl~ with the last argument, and appends code that evaluates the rest of the arguments and adjoins them to ~argl~ in succession.  In order to process the arguments from last to first, we must reverse the list of operand code sequences from the order supplied by ~compile-application~.

#+begin_src scheme
(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence
         '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence
                 '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
                          code-to-get-last-arg
                          (code-to-get-rest-args
                           (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
                     (car operand-codes)
                     (make-instruction-sequence
                      '(val argl) '(argl)
                      '((assign argl
                                (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
                    code-for-next-arg
                    (code-to-get-rest-args (cdr operand-codes))))))
#+end_src

*Applying procedures*

After evaluating the elements of a combination, the compiled code must apply the procedure in ~proc~ to the arguments in ~argl~.  The code performs essentially the same dispatch as the ~apply~ procedure in the metacircular evaluator of section [[#section-4.1.1][4.1.1]] or the ~apply-dispatch~ entry point in the explicit-control evaluator of section [[#section-5.4.1][5.4.1]].  It checks whether the procedure to be applied is a primitive procedure or a compiled procedure.  For a primitive procedure, it uses ~apply-primitive-procedure~; we will see shortly how it handles compiled procedures.  The procedure-application code has the following form:

#+begin_src scheme
(test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 <code to apply compiled procedure with given target and appropriate linkage>
primitive-branch
 (assign <TARGET>
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 <LINKAGE>
after-call
#+end_src

Observe that the compiled branch must skip around the primitive branch.  Therefore, if the linkage for the original procedure call was ~next~, the compound branch must use a linkage that jumps to a label that is inserted after the primitive branch.  (This is similar to the linkage used for the true branch in ~compile-if~.)

#+begin_src scheme
(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence
        '(proc) '()
        '((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '(proc argl)
           (list target)
           '((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
#+end_src

The primitive and compound branches, like the true and false branches in ~compile-if~, are appended using ~parallel-instruction-sequences~ rather than the ordinary ~append-instruction-sequences~, because they will not be executed sequentially.

*Applying compiled procedures*

The code that handles procedure application is the most subtle part of the compiler, even though the instruction sequences it generates are very short.  A compiled procedure (as constructed by ~compile-lambda~) has an entry point, which is a label that designates where the code for the procedure starts.  The code at this entry point computes a result in ~val~ and returns by executing the instruction ~(goto (reg continue))~.  Thus, we might expect the code for a compiled-procedure application (to be generated by ~compile-proc-appl~) with a given target and linkage to look like this if the linkage is a label

#+begin_src scheme
(assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign <TARGET> (reg val))   ; included if target is not ~val~
 (goto (label <LINKAGE>))   ; linkage code
#+end_src

or like this if the linkage is ~return~.

#+begin_src scheme
(save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign <TARGET> (reg val))   ; included if target is not ~val~
 (restore continue)
 (goto (reg continue))   ; linkage code
#+end_src

This code sets up ~continue~ so that the procedure will return to a label ~proc-return~ and jumps to the procedure's entry point.  The code at ~proc-return~ transfers the procedure's result from ~val~ to the target register (if necessary) and then jumps to the location specified by the linkage.  (The linkage is always ~return~ or a label, because ~compile-procedure-call~ replaces a ~next~ linkage for the compound-procedure branch by an ~after-call~ label.)

In fact, if the target is not ~val~, that is exactly the code our compiler will generate.[fn:324] Usually, however, the target is ~val~ (the only time the compiler specifies a different register is when targeting the evaluation of an operator to ~proc~), so the procedure result is put directly into the target register and there is no need to return to a special location that copies it.  Instead, we simplify the code by setting up ~continue~ so that the procedure will "return" directly to the place specified by the caller's linkage:

#+begin_src scheme
<set up 'continue' for linkage>
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
#+end_src

If the linkage is a label, we set up ~continue~ so that the procedure will return to that label.  (That is, the ~(goto (reg continue))~ the procedure ends with becomes equivalent to the '(goto (label <LINKAGE>))' at ~proc-return~ above.)

#+begin_src scheme
(assign continue (label <LINKAGE>))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
#+end_src

If the linkage is ~return~, we don't need to set up ~continue~ at all: It already holds the desired location.  (That is, the ~(goto (reg continue))~ the procedure ends with goes directly to the place where the ~(goto (reg continue))~ at ~proc-return~ would have gone.)

#+begin_src scheme
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
#+end_src

With this implementation of the ~return~ linkage, the compiler generates tail-recursive code.  Calling a procedure as the final step in a procedure body does a direct transfer, without saving any information on the stack.

Suppose instead that we had handled the case of a procedure call with a linkage of ~return~ and a target of ~val~ as shown above for a non-~val~ target.  This would destroy tail recursion.  Our system would still give the same value for any expression.  But each time we called a procedure, we would save ~continue~ and return after the call to undo the (useless) save.  These extra saves would accumulate during a nest of procedure calls.[fn:325]

~compile-proc-appl~ generates the above procedure-application code by considering four cases, depending on whether the target for the call is ~val~ and whether the linkage is ~return~.  Observe that the instruction sequences are declared to modify all the registers, since executing the procedure body can change the registers in arbitrary ways.[fn:326] Also note that the code sequence for the case with target ~val~ and linkage ~return~ is declared to need ~continue~: Even though ~continue~ is not explicitly used in the two-instruction sequence, we must be sure that ~continue~ will have the correct value when we enter the compiled procedure.

#+begin_src scheme
(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence
          '(proc) all-regs
          '((assign continue (label ,linkage))
            (assign val (op compiled-procedure-entry)
                    (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence
            '(proc) all-regs
            '((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                      (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence
          '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                    (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error "return linkage, target not val - COMPILE"
                target))))
#+end_src

*** 5.5.4 Combining Instruction Sequences
:properties:
:custom_id: section-5.5.4
:end:

This section describes the details on how instruction sequences are represented and combined.  Recall from section [[#section-5.5.1][5.5.1]] that an instruction sequence is represented as a list of the registers needed, the registers modified, and the actual instructions.  We will also consider a label (symbol) to be a degenerate case of an instruction sequence, which doesn't need or modify any registers.  So to determine the registers needed and modified by instruction sequences we use the selectors

#+begin_src scheme
(define (registers-needed s)
  (if (symbol? s) '() (car s)))

(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))

(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
#+end_src

and to determine whether a given sequence needs or modifies a given register we use the predicates

#+begin_src scheme
(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))

(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
#+end_src

In terms of these predicates and selectors, we can implement the various instruction sequence combiners used throughout the compiler.

The basic combiner is ~append-instruction-sequences~.  This takes as arguments an arbitrary number of instruction sequences that are to be executed sequentially and returns an instruction sequence whose statements are the statements of all the sequences appended together.  The subtle point is to determine the registers that are needed and modified by the resulting sequence.  It modifies those registers that are modified by any of the sequences; it needs those registers that must be initialized before the first sequence can be run (the registers needed by the first sequence), together with those registers needed by any of the other sequences that are not initialized (modified) by sequences preceding it.

The sequences are appended two at a time by ~append-2-sequences~.  This takes two instruction sequences ~seq1~ and ~seq2~ and returns the instruction sequence whose statements are the statements of ~seq1~ followed by the statements of ~seq2~, whose modified registers are those registers that are modified by either ~seq1~ or ~seq2~, and whose needed registers are the registers needed by ~seq1~ together with those registers needed by ~seq2~ that are not modified by ~seq1~.  (In terms of set operations, the new set of needed registers is the union of the set of registers needed by ~seq1~ with the set difference of the registers needed by ~seq2~ and the registers modified by ~seq1~.)  Thus, ~append-instruction-sequences~ is implemented as follows:

#+begin_src scheme
(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
                 (list-difference (registers-needed seq2)
                                  (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences (car seqs)
                            (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
#+end_src

This procedure uses some simple operations for manipulating sets represented as lists, similar to the (unordered) set representation described in section [[#section-2.3.3][2.3.3]]:

#+begin_src scheme
(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))

(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
#+end_src

~preserving~, the second major instruction sequence combiner, takes a list of registers ~regs~ and two instruction sequences ~seq1~ and ~seq2~ that are to be executed sequentially.  It returns an instruction sequence whose statements are the statements of ~seq1~ followed by the statements of ~seq2~, with appropriate ~save~ and ~restore~ instructions around ~seq1~ to protect the registers in ~regs~ that are modified by ~seq1~ but needed by ~seq2~.  To accomplish this, ~preserving~ first creates a sequence that has the required ~save~s followed by the statements of ~seq1~ followed by the required ~restore~s.  This sequence needs the registers being saved and restored in addition to the registers needed by ~seq1~, and modifies the registers modified by ~seq1~ except for the ones being saved and restored.  This augmented sequence and ~seq2~ are then appended in the usual way.  The following procedure implements this strategy recursively, walking down the list of registers to be preserved:[fn:327]

#+begin_src scheme
(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
                        (make-instruction-sequence
                         (list-union (list first-reg)
                                     (registers-needed seq1))
                         (list-difference (registers-modified seq1)
                                          (list first-reg))
                         (append '((save ,first-reg))
                                 (statements seq1)
                                 '((restore ,first-reg))))
                        seq2)
            (preserving (cdr regs) seq1 seq2)))))
#+end_src

Another sequence combiner, ~tack-on-instruction-sequence~, is used by ~compile-lambda~ to append a procedure body to another sequence.  Because the procedure body is not "in line" to be executed as part of the combined sequence, its register use has no impact on the register use of the sequence in which it is embedded.  We thus ignore the procedure body's sets of needed and modified registers when we tack it onto the other sequence.

#+begin_src scheme
(define (tack-on-instruction-sequence seq body-seq)
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq) (statements body-seq))))
#+end_src

~compile-if~ and ~compile-procedure-call~ use a special combiner called ~parallel-instruction-sequences~ to append the two alternative branches that follow a test.  The two branches will never be executed sequentially; for any particular evaluation of the test, one branch or the other will be entered.  Because of this, the registers needed by the second branch are still needed by the combined sequence, even if these are modified by the first branch.

#+begin_src scheme
(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1) (statements seq2))))
#+end_src
